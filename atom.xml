<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>entropy2333</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://entropy2333.github.io/"/>
  <updated>2021-04-21T13:17:37.107Z</updated>
  <id>https://entropy2333.github.io/</id>
  
  <author>
    <name>entropy2333</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CSAPP Chap3: 程序的机器级表示</title>
    <link href="https://entropy2333.github.io/2021/04/21/CSAPP-Chap3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/"/>
    <id>https://entropy2333.github.io/2021/04/21/CSAPP-Chap3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/</id>
    <published>2021-04-21T10:37:52.000Z</published>
    <updated>2021-04-21T13:17:37.107Z</updated>
    
    <content type="html"><![CDATA[<p>CSAPP第三章</p><a id="more"></a><h2 id="程序编码"><a href="#程序编码" class="headerlink" title="程序编码"></a>程序编码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linux&gt; gcc -Og -o p p1.c p2.c</span><br></pre></td></tr></table></figure><blockquote><p>-Og告诉编译器使用会生成符合原始C代码整体结构的机器代码的优化等级</p></blockquote><p>实际上gcc调用了一整套程序，将源代码转化成可执行代码。</p><ul><li><strong>预处理器</strong>扩展源代码，插入所有#include指定的文件，展开所有#define声明的宏。</li><li><strong>编译器</strong>（Compiler）产生两个源文件的汇编代码，分别为p1.s和p2.s。</li><li><strong>汇编器</strong>（Assembler）将汇编代码转化为二进制<strong>目标代码</strong>文件p1.o和p2.o。</li><li><strong>链接器</strong>（Linker）将目标代码文件和实现库函数的代码合并，生成可执行文件p。</li></ul><p>在命令行使用“-S”选项，可以看到编译器产生的汇编代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linux&gt; gcc -Og -S mstore.c</span><br></pre></td></tr></table></figure><p>使用“-c”选项，GCC会编译并汇编该代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linux&gt; gcc -Og -c mstore.c</span><br></pre></td></tr></table></figure><p>可以使用反汇编器查看机器代码文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linux&gt; objdump -d mstore.c</span><br></pre></td></tr></table></figure><h2 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h2><p>Intel用字表示16位数据类型</p><div class="table-container"><table><thead><tr><th>C声明</th><th>Intel数据类型</th><th>汇编代码后缀</th><th>大小（字节）</th></tr></thead><tbody><tr><td>char</td><td>字节</td><td>b</td><td>1</td></tr><tr><td>short</td><td>字</td><td>w</td><td>2</td></tr><tr><td>int</td><td>双字</td><td>l</td><td>4</td></tr><tr><td>long</td><td>四字</td><td>q</td><td>8</td></tr><tr><td>char*</td><td>四字</td><td>q</td><td>8</td></tr><tr><td>float</td><td>单精度</td><td>s</td><td>4</td></tr><tr><td>double</td><td>双精度</td><td>l</td><td>8</td></tr></tbody></table></div><h2 id="访问信息"><a href="#访问信息" class="headerlink" title="访问信息"></a>访问信息</h2><p>x86-64的CPU包含一组16个存储64位值的<strong>通用目的寄存器</strong>，这些寄存器用来存储整数数据和指针。</p><p>最特别的是栈指针%rsp，用来指明运行时栈的结束位置。</p><div class="table-container"><table><thead><tr><th>%rax</th><th>%eax</th><th>%ax</th><th>%al</th></tr></thead><tbody><tr><td>64(bit)</td><td>32</td><td>16</td><td>8</td></tr><tr><td>8(byte)</td><td>4</td><td>2</td><td>1</td></tr></tbody></table></div><p><img src="/2021/04/21/CSAPP-Chap3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/image-20210421194831181.png" alt="image-20210421194831181" style="zoom:67%;"></p><h3 id="操作数指示符"><a href="#操作数指示符" class="headerlink" title="操作数指示符"></a>操作数指示符</h3><p>大多数指令有一个或多个<strong>操作数</strong>，指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。操作数分为三种类型：</p><ul><li><strong>立即数</strong>：用来表示常数值，如$-577或$0x1F。</li><li><strong>寄存器</strong>：表示某个寄存器的内容，用<script type="math/tex">r_a</script>表示寄存器a，<script type="math/tex">R[r_a]</script>表示它的值。</li><li><strong>内存引用</strong>：它会根据计算出来的地址（通常称为<strong>有效地址</strong>）访问某个内存位置，用<script type="math/tex">M_b[Addr]</script>表示内存中从地址Addr开始的b个字节值的引用。</li></ul><div class="table-container"><table><thead><tr><th>类型</th><th>格式</th><th>操作数值</th><th>名称</th></tr></thead><tbody><tr><td>立即数</td><td><script type="math/tex">$Imm</script></td><td><script type="math/tex">Imm</script></td><td>立即数寻址</td></tr><tr><td>寄存器</td><td><script type="math/tex">r_a</script></td><td><script type="math/tex">R[r_a]</script></td><td>寄存器寻址</td></tr><tr><td>存储器</td><td><script type="math/tex">Imm</script></td><td><script type="math/tex">M[Imm]</script></td><td>绝对寻址</td></tr><tr><td>存储器</td><td><script type="math/tex">(r_a)</script></td><td><script type="math/tex">M[R[r_a]]</script></td><td>间接寻址</td></tr><tr><td>存储器</td><td><script type="math/tex">Imm(r_b)</script></td><td><script type="math/tex">M[Imm+R[r_a]]</script></td><td>（基址+偏移量）寻址</td></tr><tr><td>存储器</td><td><script type="math/tex">r_b, r_i</script></td><td><script type="math/tex">M[R[r_b]+R[r_a]]</script></td><td>变址寻址</td></tr><tr><td>存储器</td><td><script type="math/tex">Imm(r_b, r_i)</script></td><td><script type="math/tex">M[Imm+R[r_b]+R[r_a]]</script></td><td>变址寻址</td></tr><tr><td>存储器</td><td><script type="math/tex">(,r_i,s)</script></td><td><script type="math/tex">M[R[r_i]\cdot s]</script></td><td>比例变址寻址</td></tr><tr><td>存储器</td><td><script type="math/tex">Imm(,r_i,s)</script></td><td><script type="math/tex">M[Imm+R[r_i]\cdot s]</script></td><td>比例变址寻址</td></tr><tr><td>存储器</td><td><script type="math/tex">(r_b,r_i,s)</script></td><td><script type="math/tex">M[R[r_b]+R[r_i]\cdot s]</script></td><td>比例变址寻址</td></tr><tr><td>存储器</td><td><script type="math/tex">Imm(r_b,r_i,s)</script></td><td><script type="math/tex">M[Imm+R[r_b]+R[r_i]\cdot s]</script></td><td>比例变址寻址</td></tr></tbody></table></div><blockquote><p>比例因子<script type="math/tex">s\in\{1,2,4,8\}</script></p></blockquote><h3 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h3><p>最简单形式的数据传送指令MOV类，这些指令把数据从源位置复制到目的位置，不做任何变化。</p><div class="table-container"><table><thead><tr><th>指令</th><th>效果</th><th>描述</th></tr></thead><tbody><tr><td>MOV S, D</td><td><script type="math/tex">D\leftarrow S</script></td><td>传送</td></tr><tr><td>movb</td><td></td><td>传送字节</td></tr><tr><td>movw</td><td></td><td>传送字</td></tr><tr><td>movl</td><td></td><td>传送双字</td></tr><tr><td>movq</td><td></td><td>传送四字</td></tr><tr><td>movabsq I, R</td><td><script type="math/tex">R\leftarrow I</script></td><td>传送绝对的四字</td></tr></tbody></table></div><blockquote><p>传送指令的两个操作数不能都指向内存位置。</p></blockquote><p>MOV指令只会更新目的操作数制定的那些寄存器字节或内存位置。唯一的例外是movl指令以寄存器作为目的时，它会把该寄存器的高位4字节设置为0。</p><p>常规的movq指令只能以表示为32位补码数字的立即数作为源操作数。movabsq指令能以任意64位立即数值作为源操作数，并且只能以寄存器作为目的。</p><p><img src="/2021/04/21/CSAPP-Chap3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/image-20210421192335378.png" alt="image-20210421192335378" style="zoom:80%;"></p><p>MOVZ和MOVS可以将较小的源值复制到较大的目的。</p><ul><li>MOVZ类中的指令把目的中剩余的字节填充为0。</li><li>MOVS类中的指令通过符号拓展来填充。</li></ul><p><img src="/2021/04/21/CSAPP-Chap3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/image-20210421194448374.png" alt="image-20210421194448374" style="zoom:80%;"></p><p>pushq指令的功能是把数据压到栈上，而popq指令时弹出数据。这些指令只有一个操作数——压入的数据源和弹出的数据目的。</p><p><img src="/2021/04/21/CSAPP-Chap3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/image-20210421200607814.png" alt="image-20210421200607814" style="zoom: 80%;"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pushq %rsp</span><br><span class="line">&#x2F;&#x2F; 等价于</span><br><span class="line">subq $8, %rsp</span><br><span class="line">movq %rbp, (%rsp)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">popq %rax</span><br><span class="line">&#x2F;&#x2F; 等价于</span><br><span class="line">movq (%rsp), %rax</span><br><span class="line">addq $8, %rsp</span><br></pre></td></tr></table></figure><h2 id="算术和逻辑操作"><a href="#算术和逻辑操作" class="headerlink" title="算术和逻辑操作"></a>算术和逻辑操作</h2><p><img src="/2021/04/21/CSAPP-Chap3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/image-20210421200957477.png" alt="image-20210421200957477" style="zoom:80%;"></p><p><strong>加载有效地址</strong>指令leaq实际上是movq指令的变形。它的指令形式是从内存读数据到寄存器，但实际上它根本没有引用内存，该指令将有效地址写入目的操作数。</p><p><img src="/2021/04/21/CSAPP-Chap3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/image-20210421201159554.png" alt="image-20210421201159554" style="zoom:67%;"></p><p>一元操作只有一个操作数，这个操作数可以是一个寄存器，也可以是一个内存位置。</p><p>二元操作的第二个操作数既是源又是目的。第一个操作数可以是立即数 、寄存器或是内存位置，第二个操作数可以是寄存器或是内存位置。当第二个操作数为内存地址时，处理器必须从内存读出值，执行操作，再把结果写回内存。</p><p>移位操作，先给出移位量，第二项给出要移位的数。移位量可以是一个立即数，或者放在<strong>单字节</strong>寄存器%cl中。（只允许以这个特定的寄存器作为操作数）</p><h3 id="特殊的算术操作"><a href="#特殊的算术操作" class="headerlink" title="特殊的算术操作"></a>特殊的算术操作</h3><p><img src="/2021/04/21/CSAPP-Chap3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/image-20210421202823704.png" alt="image-20210421202823704" style="zoom:80%;"></p><p>对于imulq/mulq：</p><ul><li>双操作数，从两个64位操作数产生一个64位乘积。</li><li>单操作数，计算两个64位值的全128位乘积，要求一个参数在寄存器%rax中，另一个作为操作数给出。乘积存放在%rdx（高64位）和%rax（低64位）中。</li></ul><p>有符号数除法指令<strong>idivq</strong>将寄存器%rdx（高64位）和%rax（低64位）中的128位数作为被除数，除数作为指令的操作数给出。指令将商存在寄存器%rax中，将余数存在寄存器%rdx中。</p><p>指令cqto读出%rax的符号位，并将它复制到%rdx的所有位。</p><p>无符号除法使用divq指令。通常寄存器%rdx会事先设置为0。</p><h2 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h2><p>CPU维护着一组单个位的<strong>条件码</strong>寄存器，他们描述了最近的算术或逻辑操作的属性。</p><ul><li>CF：进位标志。最近的操作使最高位产生了进位。可用来检查无符号操作数的溢出。</li><li>ZF：零标志。最近的操作得出的结果为0。</li><li>SF：符号标志。最近的操作得到的结果为负数。</li><li>OF：溢出标志。最近的操作数导致一个补码溢出——正溢出或负溢出。</li><li>leaq指令不不改变任何条件码。</li><li>对于逻辑操作，进位和溢出标志会设置成0。</li><li>对于移位操作，进位标志将设置为最后一个被移出的位，溢出标志设置为0。</li><li>INC和DEC指令会设置溢出和零标志，但是不会改变进位标志。</li></ul><p><img src="/2021/04/21/CSAPP-Chap3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/image-20210421204107092.png" alt="image-20210421204107092" style="zoom:80%;"></p><blockquote><p>CMP和TEST指令只设置条件码而不改变任何其他寄存器。</p></blockquote><h3 id="访问条件码"><a href="#访问条件码" class="headerlink" title="访问条件码"></a>访问条件码</h3><p>SET指令根据条件码的某种组合，将一个字节设置为0或者1。</p><p>一条SET指令的目的操作数是低位单字节寄存器元素之一，或是一个字节的内存位置，指令会将这个字节设置为0或1。为了得到一个32位或64位结果，我们必须对高位清零（例如利用MOVZ指令）。</p><p><img src="/2021/04/21/CSAPP-Chap3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/image-20210421204419067.png" alt="image-20210421204419067" style="zoom: 67%;"></p><h3 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h3><p><strong>跳转</strong>指令会导致执行切换到程序中的一个全新的位置，这些跳转的目的地通常用一个<strong>标号</strong>指明。</p><p><img src="/2021/04/21/CSAPP-Chap3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/image-20210421204839498.png" alt="image-20210421204839498" style="zoom:67%;"></p><p>mp是无条件跳转。它可以是<strong>直接跳转</strong>，即跳转目标是作为指令的一部分编码的（标号）；也可以是<strong>间接跳转</strong>，即跳转目标是从寄存器或内存位置中读出的（“*”后跟一个操作数提示符）。</p><p>条件跳转指令根据条件码的某种组合，或跳转，或继续执行代码序列中下一条指令。条件跳转只能是直接跳转。</p><p>跳转指令有几种不同的编码，最常用的都是<strong>PC相对的</strong>，会将目标指令的地址与<strong>紧跟在跳转指令后面那条指令的地址</strong>之间的差作为编码。</p><p>第二种编码是给出“绝对”地址，用4个字节直接指定目标。</p><h3 id="用条件控制来实现条件分支"><a href="#用条件控制来实现条件分支" class="headerlink" title="用条件控制来实现条件分支"></a>用条件控制来实现条件分支</h3><p>C语言中的if-else语句的通用形式模版如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (test-expr)</span><br><span class="line">  then-statement</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="keyword">else</span>-statement</span><br></pre></td></tr></table></figure><p>对于这种通用形式，汇编实现通常会使用下面这种形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  t = test-expr;</span><br><span class="line">  <span class="keyword">if</span> (!t)</span><br><span class="line">    <span class="keyword">goto</span> <span class="literal">false</span>;</span><br><span class="line">  then-statement</span><br><span class="line">  <span class="keyword">goto</span> done;</span><br><span class="line"><span class="literal">false</span>:</span><br><span class="line">  <span class="keyword">else</span>-statement</span><br><span class="line">done:</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSAPP第三章&lt;/p&gt;
    
    </summary>
    
    
      <category term="CSAPP" scheme="https://entropy2333.github.io/categories/CSAPP/"/>
    
    
      <category term="CSAPP" scheme="https://entropy2333.github.io/tags/CSAPP/"/>
    
  </entry>
  
  <entry>
    <title>Rethinking Positional Encoding In Language Pre-Training</title>
    <link href="https://entropy2333.github.io/2021/04/17/Rethinking-Positional-Encoding-In-Language-Pre-Training/"/>
    <id>https://entropy2333.github.io/2021/04/17/Rethinking-Positional-Encoding-In-Language-Pre-Training/</id>
    <published>2021-04-17T12:55:44.000Z</published>
    <updated>2021-04-17T13:53:44.096Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2021/04/17/Rethinking-Positional-Encoding-In-Language-Pre-Training/image-20210417211502265.png" alt="image-20210417211502265" style="zoom:67%;"></p><p>重新思考预训练语言模型中的位置编码（ICLR2021）</p><a id="more"></a><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><ul><li>arxiv: <a href="https://arxiv.org/pdf/2006.15595v4.pdf">https://arxiv.org/pdf/2006.15595v4.pdf</a></li><li>code: <a href="https://github.com/guolinke/TUPE">https://github.com/guolinke/TUPE</a></li></ul><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>Transformer自提出以来，在语言表示学习领域大行其道。在Transformer中，位置编码是模型的关键部分，原始的Transformer使用绝对位置编码，将位置编码与词向量以相加的方式处理。后来还有其他研究者提出相对位置编码，在self-attention模块中加入一些精心设计的偏移项，以编码两个位置之间的距离信息。</p><p>本文主要针对两个问题进行研究</p><ul><li>绝对位置编码与词向量采用相加的方式是否合理，两者是明显异质（heterogenous）的，相加运算可能带来一些冗余的关联信息。</li><li>BERT中采用[CLS]这样一个特殊的token来编码句子的语义信息，但是它的位置却和其他token采用一样的位置编码，这种方式是否合理且有效？</li></ul><p>为了解决这两个问题，本文提出了采用结构位置编码的Transformer（TUPE）。</p><ul><li>将position embedding和word embedding分开计算</li><li>使用一个不同的函数计算[CLS]的语义</li></ul><h2 id="Methodology"><a href="#Methodology" class="headerlink" title="Methodology"></a>Methodology</h2><h3 id="解耦word和position的计算"><a href="#解耦word和position的计算" class="headerlink" title="解耦word和position的计算"></a>解耦word和position的计算</h3><p><img src="/2021/04/17/Rethinking-Positional-Encoding-In-Language-Pre-Training/image-20210417212824320.png" alt="image-20210417212824320" style="zoom: 67%;"></p><p>如上图，改进之处在于分别计算attention后再相加，而不是先相加再计算attention。</p><p>绝对位置编码：</p><script type="math/tex; mode=display">\alpha^{Abs}_{ij} = \frac1{\sqrt d}((w_i+p_i)W^{Q})((w_i+p_i)W^{K})^T</script><p>改进之后，对word和position计算不同的投影矩阵</p><script type="math/tex; mode=display">\alpha_{ij} = \frac1{\sqrt{2d}}(x_i^lW^{Q})(x_j^lW^{K})^T + \frac1{\sqrt{2d}}(p_iU^{Q})(p_jU^{K})^T</script><p>针对相对位置，只需要添加一个距离项</p><script type="math/tex; mode=display">\alpha_{ij} = \frac1{\sqrt{2d}}(x_i^lW^{Q})(x_j^lW^{K})^T + \frac1{\sqrt{2d}}(p_iU^{Q})(p_jU^{K})^T + b_{j-i}</script><h2 id="计算-CLS"><a href="#计算-CLS" class="headerlink" title="计算[CLS]"></a>计算[CLS]</h2><p>BERT中[CLS]作为输入语句的第一个字符，以捕获整个语句的全局信息。将这样一个特殊token和其他字符相提并论可能并不是一种好的选择，有一些可视化工作表明attention可能会出现只专注局部字符的现象（local concentration）。</p><p>为此，本文作了如下修改</p><p><img src="/2021/04/17/Rethinking-Positional-Encoding-In-Language-Pre-Training/image-20210417214551502.png" alt="image-20210417214551502" style="zoom:67%;"></p><p>其中，<script type="math/tex">\theta_1</script>和<script type="math/tex">\theta_2</script>是可学习的参数，计算方式的变化如下图。</p><p><img src="/2021/04/17/Rethinking-Positional-Encoding-In-Language-Pre-Training/image-20210417212900647.png" alt="image-20210417212900647" style="zoom:80%;"></p><h2 id="Experiment"><a href="#Experiment" class="headerlink" title="Experiment"></a>Experiment</h2><p>TUPE针对绝对和相对位置编码都做了实验，与BERT进行了比较，采用了GLUE数据集。</p><p><img src="/2021/04/17/Rethinking-Positional-Encoding-In-Language-Pre-Training/image-20210417215306237.png" alt="image-20210417215306237" style="zoom: 67%;"></p><p><img src="/2021/04/17/Rethinking-Positional-Encoding-In-Language-Pre-Training/image-20210417215048814.png" alt="image-20210417215048814" style="zoom:67%;"></p><blockquote><p>-A表示绝对位置编码，-R表示相对位置编码。</p></blockquote><p>总体来看，在GLUE上取得了更好的成绩，不过计算量相比之下多了30%（因为多算了一次attention）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2021/04/17/Rethinking-Positional-Encoding-In-Language-Pre-Training/image-20210417211502265.png&quot; alt=&quot;image-20210417211502265&quot; style=&quot;zoom:67%;&quot;&gt;&lt;/p&gt;
&lt;p&gt;重新思考预训练语言模型中的位置编码（ICLR2021）&lt;/p&gt;
    
    </summary>
    
    
      <category term="paper" scheme="https://entropy2333.github.io/categories/paper/"/>
    
    
      <category term="NLP" scheme="https://entropy2333.github.io/tags/NLP/"/>
    
      <category term="BERT" scheme="https://entropy2333.github.io/tags/BERT/"/>
    
  </entry>
  
  <entry>
    <title>Lattice-BERT</title>
    <link href="https://entropy2333.github.io/2021/04/16/Lattice-BERT/"/>
    <id>https://entropy2333.github.io/2021/04/16/Lattice-BERT/</id>
    <published>2021-04-16T07:28:11.000Z</published>
    <updated>2021-04-17T12:58:16.865Z</updated>
    
    <content type="html"><![CDATA[<p>将词汇信息融入BERT（NAACL 2021）</p><a id="more"></a><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><ul><li>arxiv: <a href="https://arxiv.org/pdf/2104.07204v1.pdf">https://arxiv.org/pdf/2104.07204v1.pdf</a></li><li>code: 暂无</li></ul><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>中文预训练模型将文本作为字符序列处理，忽略了粗粒度的语义特征。对于中文来说，词义并不完全是字义的组合，如”老板“并不等于“老的板”。将词级别的特征加入模型，可以有效补充字级别的不足。</p><p>本文设计了word lattice的结构来利用多粒度的输入，让预训练模型在下游任务中学会利用这些特征。</p><p>让Bert学会单词主要有两个难点：</p><ul><li>Bert原本的输入是字符序列，加入lattice后怎样描述位置信息。</li><li>对于Masked Languaged Model，怎样针对lattice结构设计mask任务。</li></ul><p>本文设计了lattice position attention（LPA），以帮助transformer利用lattice中文本单元的位置和距离信息。此外，还提出了masked segment prediction（MSP）任务。</p><script type="math/tex; mode=display">\rm{Lattice-BERT} = \rm{BERT} + \rm{word\ lattice} + LPA + MSP</script><h2 id="Methodology"><a href="#Methodology" class="headerlink" title="Methodology"></a>Methodology</h2><h3 id="Word-Lattice"><a href="#Word-Lattice" class="headerlink" title="Word Lattice"></a>Word Lattice</h3><p><img src="/2021/04/16/Lattice-BERT/image-20210416194914983.png" alt="image-20210416194914983" style="zoom: 80%;"></p><p>Lattice就是一个有向无环图，和Lattice-LSTM的思想类似。难点在于如何在编码层保持lattice的结构，以及如何避免冗余信息带来的潜在影响。</p><h3 id="Lattice-Position-Attention"><a href="#Lattice-Position-Attention" class="headerlink" title="Lattice Position Attention"></a>Lattice Position Attention</h3><p>在BERT的attention基础上，加了三个位置相关项。</p><script type="math/tex; mode=display">\tilde{\alpha}_{ij} = \alpha_{ij} + \rm{att}_{ij} + b_{ij} + r_{ij}</script><p>其中，<script type="math/tex">\alpha_{ij}</script>表示原来的attention，<script type="math/tex">\rm{att}_{ij}</script>计算了绝对位置的attention权重，<script type="math/tex">b_{ij}</script>则是对相对距离的计算，<script type="math/tex">r_{ij}</script>是对相对位置的缩放项。</p><script type="math/tex; mode=display">\rm{att}_{ij} = \frac {1} {\sqrt{2d_k}}([P_{s_i}^S;P_{e_i}^E]W^q)([P_{s_i}^S;P_{e_i}^E]W^k)^T</script><script type="math/tex; mode=display">b_{ij} = b_{s_j-s_i}^{ss} + b_{s_j-e_i}^{se} + b_{e_j-s_i}^{es} + b_{e_j-e_i}^{ee}</script><blockquote><p>感觉和FLAT类似，也是计算四个距离。</p></blockquote><h3 id="Masked-Segment-Prediction"><a href="#Masked-Segment-Prediction" class="headerlink" title="Masked Segment Prediction"></a>Masked Segment Prediction</h3><p>BERT对单字掩码，Lattice-BERT则是对Segment掩码。</p><p>Segment定义为：lattice的一个连通子图，且Segment之间彼此token不重叠，如下图。具体来说，为了句子分段，需要逐字遍历，判断当前的字是否是之前所有单词的结尾（真拗口）。</p><p><img src="/2021/04/16/Lattice-BERT/image-20210416195015009.png" alt="image-20210416195015009" style="zoom:80%;"></p><h2 id="Experiment"><a href="#Experiment" class="headerlink" title="Experiment"></a>Experiment</h2><p>本文在11个中文NLU任务上进行实验，包括文本分类、阅读理解、序列标注等，在MSRA-NER和CLUE数据集上进行了实验，并与RoBERTa等预训练模型进行了比较。</p><p><img src="/2021/04/16/Lattice-BERT/image-20210416201801843.png" alt="image-20210416201801843" style="zoom:80%;"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;将词汇信息融入BERT（NAACL 2021）&lt;/p&gt;
    
    </summary>
    
    
      <category term="Paper" scheme="https://entropy2333.github.io/categories/Paper/"/>
    
    
      <category term="NLP" scheme="https://entropy2333.github.io/tags/NLP/"/>
    
      <category term="BERT" scheme="https://entropy2333.github.io/tags/BERT/"/>
    
  </entry>
  
  <entry>
    <title>Simplify the Usage of Lexicon in Chinese NER</title>
    <link href="https://entropy2333.github.io/2021/02/27/Simplify-the-Usage-of-Lexicon-in-Chinese-NER/"/>
    <id>https://entropy2333.github.io/2021/02/27/Simplify-the-Usage-of-Lexicon-in-Chinese-NER/</id>
    <published>2021-02-27T04:52:04.000Z</published>
    <updated>2021-02-27T06:03:04.669Z</updated>
    
    <content type="html"><![CDATA[<p>介绍如何在中文NER模型中更好地结合词典信息（ACL 2020）</p><a id="more"></a><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><ul><li><p>arxiv: <a href="https://arxiv.org/pdf/1908.05969v2.pdf">https://arxiv.org/pdf/1908.05969v2.pdf</a></p></li><li><p>code: <a href="https://github.com/v-mipeng/LexiconAugmentedNER">https://github.com/v-mipeng/LexiconAugmentedNER</a></p></li></ul><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>ref：<a href="https://zhuanlan.zhihu.com/p/142615620">https://zhuanlan.zhihu.com/p/142615620</a></p><p>近几年，在中文NER模型中融合词典信息的工作有许多，这主要得益于Lattice-LSTM的工作。但是Lattice-LSTM有几个缺点：</p><ul><li>计算性能低下，采用RNN结构，不能batch并行化。</li><li>存在信息损失，每个字符只能获取以它为结尾的词汇信息。</li><li>可迁移性差，只适用于LSTM。</li></ul><p>本篇论文提出了一种简单的方法，在embedding层利用词典信息，避免了复杂的模型结构，易于迁移。</p><h2 id="Approach"><a href="#Approach" class="headerlink" title="Approach"></a>Approach</h2><p>本文比较了三种不同的融合方式</p><h3 id="Softword"><a href="#Softword" class="headerlink" title="Softword"></a>Softword</h3><p><img src="/2021/02/27/Simplify-the-Usage-of-Lexicon-in-Chinese-NER/v2-8924bacd6f5e4b98a1aea8ad51c01bfa_720w.jpg" alt="img" style="zoom:80%;"></p><p>Softword先对句子分词，然后对每个字符嵌入BMESO的embedding。这种方法存在分词造成的误差传播，也无法引入词汇对应的信息。</p><h3 id="ExSoftword"><a href="#ExSoftword" class="headerlink" title="ExSoftword"></a>ExSoftword</h3><p><img src="/2021/02/27/Simplify-the-Usage-of-Lexicon-in-Chinese-NER/image-20210227130546383.png" alt="image-20210227130546383" style="zoom:80%;"></p><p>ExSoftword在Softword的基础上，将所有匹配的词汇对字符进行编码，按照BMESO编码构建5维向量。比如山表示为[1, 1, 1, 0, 0]</p><script type="math/tex; mode=display">x_j^c \leftarrow [x_j^c; e^{seg}(segs(c_j))]</script><p>ExSoftword虽然引入了标注信息，但仍然没有引入词汇的embedding信息。并且这种方法无法恢复词汇匹配结果，从而导致信息损失。</p><h3 id="SoftLexicon"><a href="#SoftLexicon" class="headerlink" title="SoftLexicon"></a>SoftLexicon</h3><p><img src="/2021/02/27/Simplify-the-Usage-of-Lexicon-in-Chinese-NER/image-20210227130555211.png" alt="image-20210227130555211" style="zoom:80%;"></p><p>为了解决上述问题，SoftLexicon对每个字符依次获取BMES对应所有的词汇集合，然后再编码表示。</p><p><img src="/2021/02/27/Simplify-the-Usage-of-Lexicon-in-Chinese-NER/image-20210227131612177.png" alt="image-20210227131612177" style="zoom:80%;"></p><p>之后将词汇的embedding与词向量拼接作为输入</p><script type="math/tex; mode=display">e^s(B,M,E,S) = [v^s(B)\oplus v^s(M)\oplus v^s(E)\oplus v^s(S)]</script><script type="math/tex; mode=display">x^c \leftarrow [x^c;e^s(B,M,E,S)]</script><p>对于词汇集合编码，采取词频加权进行计算</p><script type="math/tex; mode=display">v^s(S) = \frac1{|S|}\sum_{w\in S}z(w)e^w(w)</script><h2 id="Detail"><a href="#Detail" class="headerlink" title="Detail"></a>Detail</h2><p>模型主要基于Lattice-LSTM，所以后续的模型结构依旧是BiLSTM-CRF，但因为只在embedding层修改，所以可以迁移到其他模型（CNN、BERT等）。</p><p>与Lattice-LSTM类似，采用了预训练的char+bichar embedding，还有一个word embedding文件（词典）。代码中中的预处理也主要分为三类：word、biword和gaz。</p><p>首先根据预训练embedding建立alphabet，存储字符到id的映射以及对应的embedding向量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_initialization</span>(<span class="params">data, gaz_file, train_file, dev_file, test_file</span>):</span></span><br><span class="line">    data.build_alphabet(train_file)</span><br><span class="line">    data.build_alphabet(dev_file)</span><br><span class="line">    data.build_alphabet(test_file)</span><br><span class="line">    data.build_gaz_file(gaz_file)</span><br><span class="line">    data.build_gaz_alphabet(train_file,count=<span class="literal">True</span>)</span><br><span class="line">    data.build_gaz_alphabet(dev_file,count=<span class="literal">True</span>)</span><br><span class="line">    data.build_gaz_alphabet(test_file,count=<span class="literal">True</span>)</span><br><span class="line">    data.fix_alphabet()</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">data = data_initialization(data, gaz_file, train_file, dev_file, test_file)</span><br></pre></td></tr></table></figure><p>代码中也提供了相应的接口查看数据信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">data.show_data_summary()</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">显示部分信息</span></span><br><span class="line"><span class="string">DATA SUMMARY START:</span></span><br><span class="line"><span class="string">     Tag          scheme: BMES</span></span><br><span class="line"><span class="string">     MAX SENTENCE LENGTH: 250</span></span><br><span class="line"><span class="string">     Use          bigram: False</span></span><br><span class="line"><span class="string">     Word  alphabet size: 1895</span></span><br><span class="line"><span class="string">     Biword alphabet size: 21408</span></span><br><span class="line"><span class="string">     Char  alphabet size: 1895</span></span><br><span class="line"><span class="string">     Gaz   alphabet size: 12583</span></span><br><span class="line"><span class="string">     Label alphabet size: 29</span></span><br><span class="line"><span class="string">     Word embedding size: 50</span></span><br><span class="line"><span class="string">     Biword embedding size: 50</span></span><br><span class="line"><span class="string">     Char embedding size: 30</span></span><br><span class="line"><span class="string">     Gaz embedding size: 50</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># print(data.gaz_alphabet.get_index(&#x27;国籍&#x27;))</span></span><br></pre></td></tr></table></figure><p>随后预处理训练集和测试集，根据现有的词典产生对应格式的数据。</p><p>具体来说，对于给定的一句话，依次遍历每个字符，如果遇到B，则开始匹配词典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">words = []</span><br><span class="line">biwords = []</span><br><span class="line">chars = []</span><br><span class="line">labels = []</span><br><span class="line">word, label = lines[idx]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> len(label) &gt; <span class="number">2</span>:</span><br><span class="line">    <span class="comment"># label != O</span></span><br><span class="line">    <span class="keyword">if</span> idx &lt; len(lines) - <span class="number">1</span> <span class="keyword">and</span> len(lines[idx + <span class="number">1</span>][<span class="number">1</span>]) &gt; <span class="number">2</span>:</span><br><span class="line">        biword = word + lines[idx + <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            biword = word + <span class="string">&quot;-null-&quot;</span></span><br><span class="line">            words.append(word)</span><br><span class="line">            biwords.append(biword)</span><br><span class="line">            labels.append(label)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># label == O</span></span><br><span class="line">    <span class="keyword">if</span> (len(words) &gt; <span class="number">0</span>):</span><br><span class="line">        w_length = len(words)</span><br><span class="line">        gazs = [ [[] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(w_length)]</span><br><span class="line">        <span class="comment"># gazs: [c1,c2,...,cn]  ci:[B,M,E,S]  B/M/E/S :[w_id1,w_id2,...]  None:0</span></span><br><span class="line">        gazs_count = [ [[] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(w_length)]</span><br><span class="line"></span><br><span class="line">        gaz_char_Id = [ [[] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(w_length)]</span><br><span class="line">        <span class="comment">## gaz_char_Id: [c1,c2,...,cn]  ci:[B,M,E,S]  B/M/E/S :[[w1c1,w1c2,...],[],...]</span></span><br></pre></td></tr></table></figure><p>词典在内存中以Trie树的形式存在，所以对于实体中的每个字符都判断是否有到达叶子节点的路径，从而匹配词典中的词汇。</p><p>以下面这句话为例，高勇的标签不为O，词典会匹配到“高勇”和“高”两个词，那么结果就是长度为2的向量。其中的元素又是一个四维向量[B, M, E, S]，分为存储单词对应的Id，这样就可以存储词汇的信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">text = [<span class="string">&#x27;高&#x27;</span>, <span class="string">&#x27;勇&#x27;</span>, <span class="string">&#x27;：&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;，&#x27;</span>, <span class="string">&#x27;中&#x27;</span>, <span class="string">&#x27;国&#x27;</span>, <span class="string">&#x27;国&#x27;</span>, <span class="string">&#x27;籍&#x27;</span>, <span class="string">&#x27;，&#x27;</span>, <span class="string">&#x27;无&#x27;</span>, <span class="string">&#x27;境&#x27;</span>, <span class="string">&#x27;外&#x27;</span>, <span class="string">&#x27;居&#x27;</span>, <span class="string">&#x27;留&#x27;</span>, <span class="string">&#x27;权&#x27;</span>, <span class="string">&#x27;，&#x27;</span>]</span><br><span class="line">labels = [<span class="string">&#x27;B-NAME&#x27;</span>, <span class="string">&#x27;E-NAME&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;B-CONT&#x27;</span>, <span class="string">&#x27;M-CONT&#x27;</span>, <span class="string">&#x27;M-CONT&#x27;</span>, <span class="string">&#x27;E-CONT&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;O&#x27;</span>]</span><br><span class="line">print(<span class="string">&quot;&quot;</span>.join(text))</span><br><span class="line"><span class="comment"># input: 高勇：男，中国国籍，无境外居留权，</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gazs: [[[2], [0], [0], [3]], [[0], [0], [2], [4]]]</span></span><br><span class="line"><span class="comment"># gaz_char_Id: [[[[2, 3]], [0], [0], [0]], [[0], [0], [[2, 3]], [0]]]</span></span><br><span class="line">result = [[[<span class="string">&#x27;&#x27;</span>.join([word_alphabet.get_instance(idx) <span class="keyword">if</span> word_alphabet.get_instance(idx) <span class="keyword">else</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">for</span> idx <span class="keyword">in</span> ___ ]) <span class="keyword">for</span> ___ <span class="keyword">in</span> __ ]<span class="keyword">for</span> __ <span class="keyword">in</span> _] <span class="keyword">for</span> _ <span class="keyword">in</span> gaz_char_Id]</span><br><span class="line"><span class="comment"># result: [[[&#x27;高勇&#x27;], [], [], [&#x27;高&#x27;]], [[], [], [&#x27;高勇&#x27;], []]]</span></span><br></pre></td></tr></table></figure><p>在得到了词汇信息后，还要引入mask，以标出哪些是有效信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gazchar_masks: [[[[0, 0]], [[0, 1]], [[0, 1]], [[0, 1]]], [[[0, 1]], [[0, 1]], [[0, 0]], [[0, 1]]]]</span></span><br></pre></td></tr></table></figure><p>最后，读取词典获取对应的embedding送入模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">model = SeqModel(data)</span><br><span class="line">print(model)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">build batched crf...</span></span><br><span class="line"><span class="string">GazLSTM(</span></span><br><span class="line"><span class="string">  (gaz_embedding): Embedding(12583, 50)</span></span><br><span class="line"><span class="string">  (word_embedding): Embedding(1895, 50)</span></span><br><span class="line"><span class="string">  (NERmodel): NERmodel(</span></span><br><span class="line"><span class="string">    (lstm): LSTM(250, 300, batch_first=True, bidirectional=True)</span></span><br><span class="line"><span class="string">    (drop): Dropout(p=0.5)</span></span><br><span class="line"><span class="string">  )</span></span><br><span class="line"><span class="string">  (drop): Dropout(p=0.5)</span></span><br><span class="line"><span class="string">  (hidden2tag): Linear(in_features=600, out_features=31, bias=True)</span></span><br><span class="line"><span class="string">  (crf): CRF()</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍如何在中文NER模型中更好地结合词典信息（ACL 2020）&lt;/p&gt;
    
    </summary>
    
    
      <category term="Paper" scheme="https://entropy2333.github.io/categories/Paper/"/>
    
    
      <category term="NLP" scheme="https://entropy2333.github.io/tags/NLP/"/>
    
      <category term="LSTM" scheme="https://entropy2333.github.io/tags/LSTM/"/>
    
      <category term="ACL" scheme="https://entropy2333.github.io/tags/ACL/"/>
    
  </entry>
  
  <entry>
    <title>K-BERT: Enabling Language Representation with Knowledge Graph</title>
    <link href="https://entropy2333.github.io/2021/02/25/K-BERT-Enabling-Language-Representation-with-Knowledge-Graph/"/>
    <id>https://entropy2333.github.io/2021/02/25/K-BERT-Enabling-Language-Representation-with-Knowledge-Graph/</id>
    <published>2021-02-24T16:32:01.000Z</published>
    <updated>2021-02-27T05:25:53.408Z</updated>
    
    <content type="html"><![CDATA[<p>介绍K-BERT模型（AAAI 2020）</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>arxiv：<a href="https://arxiv.org/abs/1909.07606v1">https://arxiv.org/abs/1909.07606v1</a></li><li>code：<a href="https://github.com/autoliuweijie/K-BERT">https://github.com/autoliuweijie/K-BERT</a></li></ul><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>模型结构如下图，输入的文本经过知识层后，变成树状结构后和可见矩阵一起送入模型训练。</p><p><img src="/2021/02/25/K-BERT-Enabling-Language-Representation-with-Knowledge-Graph/image-20210225003741712.png" alt="image-20210225003741712" style="zoom:67%;"></p><p>具体来说，算法分为以下几步。</p><ul><li>预先准备KG，建立查找表（关键词表）。</li><li>对于给定的输入文本，利用工具分词（pkuseg）。</li><li>将分词得到的结果去表中查询，得到对应的实体。</li><li>计算实体位置，得到位置编码，也即论文中的soft-position index。</li><li>计算可见矩阵，控制每个词受哪些词影响（如Cook不会被Beijing关联的China影响）。</li></ul><p><img src="/2021/02/25/K-BERT-Enabling-Language-Representation-with-Knowledge-Graph/image-20210225003844098.png" alt="image-20210225003844098"></p><p>K-BERT并不算预训练模型，嵌入层依旧是使用的BERT模型，应该算基于BERT的fine-tuning网络，可以用于分类和序列标注。同时，K-BERT也可以加载其他BERT类模型，如ERNIE、RoBERTa等。</p><p>创新点在于使用可见矩阵控制了Self-Attention的计算（如下图）。</p><p><img src="/2021/02/25/K-BERT-Enabling-Language-Representation-with-Knowledge-Graph/image-20210225005229317.png" alt="image-20210225005229317" style="zoom: 67%;"></p><h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><ul><li>模型的鲁棒性受限于知识图谱的质量，取自于开放领域图谱中的信息，其实BERT通过大语料学习也能获得，可以考虑特定领域的知识。</li><li>关联的三元组没有筛选，一词多义会引入错误的实体关联。</li><li>对于非知识驱动的任务，引入知识反而会效果下降。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍K-BERT模型（AAAI 2020）&lt;/p&gt;
    
    </summary>
    
    
      <category term="Paper" scheme="https://entropy2333.github.io/categories/Paper/"/>
    
    
      <category term="NLP" scheme="https://entropy2333.github.io/tags/NLP/"/>
    
      <category term="KG" scheme="https://entropy2333.github.io/tags/KG/"/>
    
      <category term="AAAI" scheme="https://entropy2333.github.io/tags/AAAI/"/>
    
  </entry>
  
  <entry>
    <title>现代密码学（八）信息隐藏与隐写分析</title>
    <link href="https://entropy2333.github.io/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%85%AB%EF%BC%89%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F%E4%B8%8E%E9%9A%90%E5%86%99%E5%88%86%E6%9E%90/"/>
    <id>https://entropy2333.github.io/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%85%AB%EF%BC%89%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F%E4%B8%8E%E9%9A%90%E5%86%99%E5%88%86%E6%9E%90/</id>
    <published>2020-12-27T09:09:54.000Z</published>
    <updated>2020-12-28T13:59:06.345Z</updated>
    
    <content type="html"><![CDATA[<p>介绍信息隐藏与隐写分析。</p><a id="more"></a><h2 id="信息隐藏"><a href="#信息隐藏" class="headerlink" title="信息隐藏"></a>信息隐藏</h2><p>信息隐藏可以分为</p><ul><li>空域，如LSB。</li><li>变换域，如DCT。</li></ul><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%85%AB%EF%BC%89%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F%E4%B8%8E%E9%9A%90%E5%86%99%E5%88%86%E6%9E%90/image-20201228213531671.png" alt="image-20201228213531671" style="zoom:67%;"></p><h2 id="数字水印的嵌入"><a href="#数字水印的嵌入" class="headerlink" title="数字水印的嵌入"></a>数字水印的嵌入</h2><ul><li>加法嵌入</li><li>乘法嵌入</li></ul><p>图像质量可以用峰值信噪比PSNR评价</p><h2 id="信息隐藏算法"><a href="#信息隐藏算法" class="headerlink" title="信息隐藏算法"></a>信息隐藏算法</h2><p>空域算法，通过直接修改像素值实现隐藏信息嵌入。</p><ul><li>简单、快速、容量大。</li><li>鲁棒性差。</li></ul><p>灰度256的图像有8个位平面。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%85%AB%EF%BC%89%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F%E4%B8%8E%E9%9A%90%E5%86%99%E5%88%86%E6%9E%90/image-20201228214154609.png" alt="image-20201228214154609" style="zoom:67%;"></p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%85%AB%EF%BC%89%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F%E4%B8%8E%E9%9A%90%E5%86%99%E5%88%86%E6%9E%90/image-20201228214300127.png" alt="image-20201228214300127" style="zoom:67%;"></p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%85%AB%EF%BC%89%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F%E4%B8%8E%E9%9A%90%E5%86%99%E5%88%86%E6%9E%90/image-20201228214310415.png" alt="image-20201228214310415" style="zoom:67%;"></p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%85%AB%EF%BC%89%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F%E4%B8%8E%E9%9A%90%E5%86%99%E5%88%86%E6%9E%90/image-20201228214318464.png" alt="image-20201228214318464" style="zoom:67%;"></p><h2 id="频域水印算法"><a href="#频域水印算法" class="headerlink" title="频域水印算法"></a>频域水印算法</h2><p>在频域，通过修改频域空间的系数实现水印嵌入。</p><ul><li>鲁棒性好</li><li>复杂度高</li></ul><p>JPEG只改中频系数，不会被消除掉。</p><ul><li>修改低频部分，容易看出变化，隐蔽性差。</li><li>修改高频部分，容易被图像压缩算法破坏，鲁棒性差。</li></ul><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%85%AB%EF%BC%89%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F%E4%B8%8E%E9%9A%90%E5%86%99%E5%88%86%E6%9E%90/image-20201228214606301.png" alt="image-20201228214606301" style="zoom:67%;"></p><h2 id="隐写分析"><a href="#隐写分析" class="headerlink" title="隐写分析"></a>隐写分析</h2><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%85%AB%EF%BC%89%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F%E4%B8%8E%E9%9A%90%E5%86%99%E5%88%86%E6%9E%90/image-20201228215318459.png" alt="image-20201228215318459" style="zoom:67%;"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍信息隐藏与隐写分析。&lt;/p&gt;
    
    </summary>
    
    
      <category term="现代密码学" scheme="https://entropy2333.github.io/categories/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
      <category term="信息隐藏" scheme="https://entropy2333.github.io/tags/%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F/"/>
    
      <category term="隐写分析" scheme="https://entropy2333.github.io/tags/%E9%9A%90%E5%86%99%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>现代密码学（七）数字签名算法</title>
    <link href="https://entropy2333.github.io/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%83%EF%BC%89%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E7%AE%97%E6%B3%95/"/>
    <id>https://entropy2333.github.io/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%83%EF%BC%89%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E7%AE%97%E6%B3%95/</id>
    <published>2020-12-27T09:09:31.000Z</published>
    <updated>2021-01-05T13:41:47.874Z</updated>
    
    <content type="html"><![CDATA[<p>介绍数字签名。</p><a id="more"></a><h2 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h2><script type="math/tex; mode=display">h = H(M) \\S = h^d\bmod N \\S^e = (h^e)^d = h\bmod N</script><h2 id="El-Gamal"><a href="#El-Gamal" class="headerlink" title="El Gamal"></a>El Gamal</h2><p>选择随机数k，满足<script type="math/tex">gck(k,\ p-1)=1</script>，计算密钥</p><script type="math/tex; mode=display">K = a^k\bmod p</script><p>用Euclidean扩展算法求解S</p><script type="math/tex; mode=display">M = x\cdot K + k\cdot S\bmod(p-1)</script><p>也即</p><script type="math/tex; mode=display">S = k^{-1}(M-x\cdot K)\bmod(p-1)</script><p>签名就是<script type="math/tex">(M,K,S)</script></p><script type="math/tex; mode=display">y^K\cdot K^S = (a^x)^K\cdot (a^k)^{k^{-1}(M-x\cdot K)} = a^M \bmod p</script><h2 id="DSA"><a href="#DSA" class="headerlink" title="DSA"></a>DSA</h2><p>基于离散对数，生成320bit签名。</p><h2 id="HMAC"><a href="#HMAC" class="headerlink" title="HMAC"></a>HMAC</h2><p>带密钥的HASH。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍数字签名。&lt;/p&gt;
    
    </summary>
    
    
      <category term="现代密码学" scheme="https://entropy2333.github.io/categories/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
      <category term="数字签名" scheme="https://entropy2333.github.io/tags/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>现代密码学（六）认证与哈希函数</title>
    <link href="https://entropy2333.github.io/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%85%AD%EF%BC%89%E8%AE%A4%E8%AF%81%E4%B8%8E%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/"/>
    <id>https://entropy2333.github.io/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%85%AD%EF%BC%89%E8%AE%A4%E8%AF%81%E4%B8%8E%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/</id>
    <published>2020-12-27T09:09:11.000Z</published>
    <updated>2020-12-28T13:17:49.640Z</updated>
    
    <content type="html"><![CDATA[<p>介绍认证方法与哈希函数。</p><a id="more"></a><h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><p>认证是为了防止主动攻击。</p><ul><li>实体认证（确认发送者的身份）</li><li>消息认证（验证消息的完整性）</li></ul><p>保密和认证是两个概念，纯认证的系统模型如下。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%85%AD%EF%BC%89%E8%AE%A4%E8%AF%81%E4%B8%8E%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/image-20201228193828037.png" alt="image-20201228193828037" style="zoom:67%;"></p><p>有三种方式产生认证符</p><ul><li>消息加密</li><li>消息认证码MAC<ul><li>需要密钥</li></ul></li><li>哈希函数</li></ul><p>基于公钥体制，可以实现加密与认证。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%85%AD%EF%BC%89%E8%AE%A4%E8%AF%81%E4%B8%8E%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/image-20201228195806099.png" alt="image-20201228195806099" style="zoom:67%;"></p><h2 id="消息认证码-MAC"><a href="#消息认证码-MAC" class="headerlink" title="消息认证码 MAC"></a>消息认证码 MAC</h2><p>MAC对给定消息，使用一个密钥，产生一个短小的定长数据分组。</p><p>可以提供认证，因为只有通信双方共享密钥。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%85%AD%EF%BC%89%E8%AE%A4%E8%AF%81%E4%B8%8E%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/image-20201228200208994.png" alt="image-20201228200208994" style="zoom: 67%;"></p><p>也可以实现认证与保密。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%85%AD%EF%BC%89%E8%AE%A4%E8%AF%81%E4%B8%8E%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/image-20201228200259938.png" alt="image-20201228200259938" style="zoom:67%;"></p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%85%AD%EF%BC%89%E8%AE%A4%E8%AF%81%E4%B8%8E%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/image-20201228202104394.png" alt="image-20201228202104394" style="zoom:67%;"></p><p>消息认证相较于常规加密</p><ul><li>适用于消息广播</li><li>认证的代价低</li><li>某些应用只关心消息的真实性</li><li>认证与保密的分离能提供结构上的灵活性</li><li>认证码可以延长消息的保护期限，同时能处理消息内容</li></ul><p>认证函数应抗选择明文攻击，且生成同样的认证码在计算上不可行。</p><p>可以基于DES实现MAC</p><ul><li>将消息分为连续的64bit分组</li></ul><script type="math/tex; mode=display">\begin{align}C_1 &= E_K(M_1) \\C_2 &= E_K(M_2\oplus C_1) \\&\dots \\C_n &= E_K(M_n\oplus C_{n-1})\end{align}</script><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>哈希函数将任意长度的消息映射为较短的定长消息。</p><ul><li><script type="math/tex; mode=display">E_K(M||H(M))</script><ul><li>提供保密与鉴别</li></ul></li><li><script type="math/tex; mode=display">M||E_K(H(M))</script><ul><li>提供鉴别</li></ul></li><li><script type="math/tex; mode=display">M||E_{K_{R_a}}(H(M))</script><ul><li>提供鉴别与数字签名</li></ul></li></ul><p>简单的哈希函数，对每个分组按bit异或（奇偶校验）。</p><script type="math/tex; mode=display">C_i = b_{i1}\oplus b_{i2}\oplus\cdots\oplus b_{im}</script><h3 id="Merkle-Damgard结构"><a href="#Merkle-Damgard结构" class="headerlink" title="Merkle-Damgard结构"></a>Merkle-Damgard结构</h3><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%85%AD%EF%BC%89%E8%AE%A4%E8%AF%81%E4%B8%8E%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/image-20201228204306226.png" alt="image-20201228204306226" style="zoom:67%;"></p><script type="math/tex; mode=display">CV_i = f(CV_{i-1}, Y_{i-1}) \\H(M) = CV_L</script><h2 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h2><p>符合Merkle-Damgard结构，输入分组长度512bit，输出128bit。</p><ul><li>添加填充位，满足<script type="math/tex">length\equiv448\bmod512</script>。</li><li>添加长度，用64bit表示，若超过只取低64位。</li><li>使用一个128bit缓存存放结果，表示为<script type="math/tex">(A,B,C,D)</script>。</li><li>处理512bit的报文分组，核心是包含4个循环的压缩函数f，每个循环包括16步。</li><li>所有L个51bit的分组处理后，第L个阶段的输出作为128bit摘要输出。</li></ul><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%85%AD%EF%BC%89%E8%AE%A4%E8%AF%81%E4%B8%8E%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/image-20201228205401841.png" alt="image-20201228205401841" style="zoom:67%;"></p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%85%AD%EF%BC%89%E8%AE%A4%E8%AF%81%E4%B8%8E%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/image-20201228205300355.png" alt="image-20201228205336335" style="zoom:67%;"></p><p>MD4有3轮，每轮16步。</p><p>MD5每轮加上前一步的结果，有雪崩效应。</p><h2 id="SHA-1"><a href="#SHA-1" class="headerlink" title="SHA-1"></a>SHA-1</h2><p>输入最大长度为<script type="math/tex">2^{64}</script>，输出160bit，分组大小512bit。</p><p>SHA-1的函数有四轮，每轮20步。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%85%AD%EF%BC%89%E8%AE%A4%E8%AF%81%E4%B8%8E%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/image-20201228210321190.png" alt="image-20201228210321190" style="zoom:67%;"></p><h2 id="安全性分析"><a href="#安全性分析" class="headerlink" title="安全性分析"></a>安全性分析</h2><ul><li>SHA = MD4 + 扩展变换 + 外加一轮 + 更好的雪崩</li><li>MD5 = MD4 + 改进的比特杂凑 + 外加一轮 + 更好的雪崩</li></ul><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%85%AD%EF%BC%89%E8%AE%A4%E8%AF%81%E4%B8%8E%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/image-20201228210617475.png" alt="image-20201228210617475" style="zoom:67%;"></p><p>哈希函数可以受到野蛮攻击和生日攻击</p><p>k个人中，至少存在两人生日相同的概率为</p><script type="math/tex; mode=display">P(365, k) = 1 - \frac {365!} {(365-k)365^k}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍认证方法与哈希函数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="现代密码学" scheme="https://entropy2333.github.io/categories/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
      <category term="MD5" scheme="https://entropy2333.github.io/tags/MD5/"/>
    
      <category term="MAC" scheme="https://entropy2333.github.io/tags/MAC/"/>
    
      <category term="SHA-1" scheme="https://entropy2333.github.io/tags/SHA-1/"/>
    
  </entry>
  
  <entry>
    <title>现代密码学（五）公钥密码</title>
    <link href="https://entropy2333.github.io/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%BA%94%EF%BC%89%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81/"/>
    <id>https://entropy2333.github.io/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%BA%94%EF%BC%89%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81/</id>
    <published>2020-12-27T09:08:56.000Z</published>
    <updated>2020-12-28T11:31:10.068Z</updated>
    
    <content type="html"><![CDATA[<p>介绍公钥密码学。</p><a id="more"></a><h2 id="公钥密码理论"><a href="#公钥密码理论" class="headerlink" title="公钥密码理论"></a>公钥密码理论</h2><p>公钥算法主要有三类</p><ul><li>密钥分配</li><li>公钥加密</li><li>签名算法</li></ul><h2 id="DH密钥交换"><a href="#DH密钥交换" class="headerlink" title="DH密钥交换"></a>DH密钥交换</h2><ul><li>选定素数p和本原元a</li><li>A选定<script type="math/tex">x_A</script>，计算<script type="math/tex">y_A=a^{x_A}\bmod p</script></li><li>B选定<script type="math/tex">x_B</script>，计算<script type="math/tex">y_B=a^{x_B}\bmod p</script></li><li>公开<script type="math/tex">y_A</script>和<script type="math/tex">y_B</script></li><li>A计算<script type="math/tex">K=y_B^{x_A}\bmod p</script></li><li>B计算<script type="math/tex">K=y_A^{x_B}\bmod p</script></li></ul><h2 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h2><p>算法流程</p><ul><li>选择两个大素数p和q</li><li>计算<script type="math/tex">N=p·q</script></li><li>随机选择加密密钥e，满足<script type="math/tex">gcd(e, \phi(N)) = 1,\ e < N</script></li><li>求解解密密钥d，满足<script type="math/tex">e·d\equiv1\bmod \phi(N)</script></li><li>公开<script type="math/tex">(N, e)</script>，保存<script type="math/tex">(p,q,d)</script></li></ul><p>原理如下</p><script type="math/tex; mode=display">C = M^e\bmod N \\D = C^d= (M^e)^d\bmod N \\D = M^{(1+k\phi(N))}= M\bmod N</script><p>RSA实际上是一种单表代换</p><script type="math/tex; mode=display">RSA: \mathbb{Z/nZ} \rightarrow \mathbb{Z/nZ},\ n=pq</script><p>RSA的安全性取决于计算<script type="math/tex">\phi(N)</script>的困难性，但分解模未必是攻击RSA的最佳方法。</p><p>RSA需要计算大指数模幂，可以用中国剩余定理CRT来加速。</p><script type="math/tex; mode=display">M_1 = M\bmod p = (C\bmod p)^{d\bmod(p-1)} \\M_2 = M\bmod q = (C\bmod q)^{d\bmod(q-1)}</script><p>对于方程组</p><script type="math/tex; mode=display">\begin{cases}M = M_1\bmod p \\M = M_2\bmod q\end{cases}</script><p>有唯一解</p><script type="math/tex; mode=display">M = (q·u·M_1 + p·u'·M_2)\bmod N \\p·u\equiv1\bmod q,\ q·u'\equiv1\bmod p</script><h2 id="Rabin公钥密码体制"><a href="#Rabin公钥密码体制" class="headerlink" title="Rabin公钥密码体制"></a>Rabin公钥密码体制</h2><p>有两个困难数学问题</p><ul><li>二次剩余问题：给定奇合数n和整数a，难以判断a是n的二次剩余。</li><li>模n的平方根问题：在n的分解未知情况下，难以求解n的平方根。</li></ul><p>Rabin体制利用求解平方根的困难性构造了一种安全公钥体制。</p><p>首先选定两个形如4k+3的素数p和q，以n=pq作为公钥。</p><p>加密过程</p><script type="math/tex; mode=display">C = M^2 \bmod n,\ 0 \leq M < n</script><p>解密首先计算</p><script type="math/tex; mode=display">\begin{align}M_1 &= C^{\frac{(p+1)}{4}} \bmod p \\M_2 &= p - C^{\frac{(p+1)}{4}} \bmod p \\M_3 &= C^{\frac{(q+1)}{4}} \bmod q \\M_4 &= q - C^{\frac{(p+1)}{4}} \bmod q\end{align}</script><p>利用中国剩余定理，可以得到四个解，必有一个与M相同。</p><p>Rabin体制的安全性等价于大整数分解，但是对选择密文攻击不安全。</p><script type="math/tex; mode=display">x_1^2\equiv x_2^2\equiv0\bmod n \\\iff (x_1-x_2)(x_1+x_2)\equiv0\bmod n</script><p>与RSA相比，Rabin只需要一次乘法运算，但解密时更困难。</p><h2 id="El-Gamal"><a href="#El-Gamal" class="headerlink" title="El Gamal"></a>El Gamal</h2><p>基于离散对数，但增加了消息长度（2倍）。</p><p>首先选定大素数p和本原元g，计算</p><script type="math/tex; mode=display">y_B = g^{x_B}\bmod p</script><p>发送者选择随机数k，计算消息密钥</p><script type="math/tex; mode=display">K = y_B^k\bmod p,\ 0\leq k\leq p-1</script><p>之后计算密文对</p><script type="math/tex; mode=display">\begin{align}C_1 &= g^k\bmod p \\C_2 &= M\cdot K\bmod p\end{align}</script><p>解密时先计算密钥再计算明文</p><script type="math/tex; mode=display">\begin{align}K &= C_1^{x_B}\bmod p = (g^k)^{x_B}\bmod p \\M &= C_2\cdot K^{-1}\bmod p\end{align}</script><h2 id="对于公钥密码的攻击"><a href="#对于公钥密码的攻击" class="headerlink" title="对于公钥密码的攻击"></a>对于公钥密码的攻击</h2><p>可以对RSA发动弱参数攻击</p><ul><li>共模攻击</li><li>低加密指数攻击</li></ul><p>可以对Rabin发动选择密文攻击</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍公钥密码学。&lt;/p&gt;
    
    </summary>
    
    
      <category term="现代密码学" scheme="https://entropy2333.github.io/categories/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
      <category term="RSA" scheme="https://entropy2333.github.io/tags/RSA/"/>
    
      <category term="Rabin" scheme="https://entropy2333.github.io/tags/Rabin/"/>
    
      <category term="El Gamal" scheme="https://entropy2333.github.io/tags/El-Gamal/"/>
    
  </entry>
  
  <entry>
    <title>现代密码学（四）序列密码</title>
    <link href="https://entropy2333.github.io/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%9B%9B%EF%BC%89%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81/"/>
    <id>https://entropy2333.github.io/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%9B%9B%EF%BC%89%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81/</id>
    <published>2020-12-27T09:08:45.000Z</published>
    <updated>2020-12-28T09:25:41.429Z</updated>
    
    <content type="html"><![CDATA[<p>介绍序列密码（流密码）。</p><a id="more"></a><h2 id="流密码"><a href="#流密码" class="headerlink" title="流密码"></a>流密码</h2><p>流密码的简单结构如下。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%9B%9B%EF%BC%89%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81/image-20201228165456897.png" alt="image-20201228165456897" style="zoom:67%;"></p><p>对于流密码来说，需要生成一个作为密钥流的“随机”比特序列。</p><p>流密码的安全性取决于密钥的安全等级。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%9B%9B%EF%BC%89%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81/image-20201228165551857.png" alt="image-20201228165551857" style="zoom:67%;"></p><p>流密码可以分为两种</p><ul><li>同步流密码<ul><li>密钥流的产生与明文消息相互独立</li></ul></li><li>自同步流密码<ul><li>密钥流的产生与之间产生的若干密文有关</li></ul></li></ul><h2 id="线性反馈移位寄存器-LFSR"><a href="#线性反馈移位寄存器-LFSR" class="headerlink" title="线性反馈移位寄存器 LFSR"></a>线性反馈移位寄存器 LFSR</h2><p>LFSR可以产生同步密钥流。</p><script type="math/tex; mode=display">a_i(t+1) = a_{i+1}(t),\ i=1,2,\dots,n-1 \\a_n(t+1) = c_na_1(t) \oplus c_{n-1}a_2(t) \oplus\dots\oplus c_1a_n(t)</script><p>联结多项式为</p><script type="math/tex; mode=display">c_nx^n + c_{n-1}x^{n-1} +\dots+ c_1x+1</script><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%9B%9B%EF%BC%89%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81/image-20201228170207505.png" alt="image-20201228170207505" style="zoom:67%;"></p><p>例如对于联接多项式<script type="math/tex">x^3+x^2+1</script>，对应的反馈函数为</p><script type="math/tex; mode=display">a_3 = a_1 \oplus a_2</script><p>对于LFSR来说，一个n级LFSR序列的周期最大为<script type="math/tex">2^n-1</script>。</p><p>如果产生了最大周期，则称为m序列，LFSR的状态转移图只有两个圈。</p><h2 id="伪随机序列"><a href="#伪随机序列" class="headerlink" title="伪随机序列"></a>伪随机序列</h2><h3 id="Golomb随机性假设"><a href="#Golomb随机性假设" class="headerlink" title="Golomb随机性假设"></a>Golomb随机性假设</h3><ul><li>在每一周期内，0和1的个数近似相等。</li><li>在每一周期内，长度为i的游程占游程总数的<script type="math/tex">\frac{1}{2^i}</script>。</li><li>定义自相关函数<script type="math/tex">C(\tau)=\sum_{i=1}^n(-1)^{a_i+a_{i+\tau}}</script>。<ul><li>那么<script type="math/tex">C(\tau)=\begin{cases}n,\quad\tau\equiv0\mod n\\c,\quad others\end{cases}</script></li></ul></li></ul><h3 id="m序列的伪随机性"><a href="#m序列的伪随机性" class="headerlink" title="m序列的伪随机性"></a>m序列的伪随机性</h3><h3 id="线性复杂度"><a href="#线性复杂度" class="headerlink" title="线性复杂度"></a>线性复杂度</h3><p>能够输出该序列的最短LFSR的级数。</p><p>一个好的流密码，应该具有大周期、大的线性复杂度，同时满足Golomb随机性假设。</p><h2 id="基于LFSR的伪随机序列生成器"><a href="#基于LFSR的伪随机序列生成器" class="headerlink" title="基于LFSR的伪随机序列生成器"></a>基于LFSR的伪随机序列生成器</h2><h3 id="滤波生成器"><a href="#滤波生成器" class="headerlink" title="滤波生成器"></a>滤波生成器</h3><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%9B%9B%EF%BC%89%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81/image-20201228171735794.png" alt="image-20201228171735794" style="zoom:67%;"></p><h3 id="组合生成器"><a href="#组合生成器" class="headerlink" title="组合生成器"></a>组合生成器</h3><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%9B%9B%EF%BC%89%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81/image-20201228171742568.png" alt="image-20201228171742568" style="zoom:67%;"></p><h3 id="钟控生成器"><a href="#钟控生成器" class="headerlink" title="钟控生成器"></a>钟控生成器</h3><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%9B%9B%EF%BC%89%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81/image-20201228171755691.png" alt="image-20201228171755691" style="zoom:67%;"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍序列密码（流密码）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="现代密码学" scheme="https://entropy2333.github.io/categories/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
      <category term="流密码" scheme="https://entropy2333.github.io/tags/%E6%B5%81%E5%AF%86%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>现代密码学（三）分组密码</title>
    <link href="https://entropy2333.github.io/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/"/>
    <id>https://entropy2333.github.io/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/</id>
    <published>2020-12-27T09:08:30.000Z</published>
    <updated>2021-01-05T13:42:24.067Z</updated>
    
    <content type="html"><![CDATA[<p>介绍分组密码，包括Feistel Cipher、DES和IDEA等。</p><a id="more"></a><h2 id="分组密码"><a href="#分组密码" class="headerlink" title="分组密码"></a>分组密码</h2><p>分组密码（Block Cipher），是指将明文分成许多块，利用加密算法对每一块进行加密，形式如下。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201227181933426.png" alt="image-20201227181933426" style="zoom:67%;"></p><p>分组密码希望使用对每一块使用尽可能大的替换模块，但并不现实。</p><p>当分组长度为64bit时，即需要<script type="math/tex">2^{64}</script>个实体的替换表，因此使用乘积密码的思想，用一些小的模块替代。</p><h2 id="替换-置换密码"><a href="#替换-置换密码" class="headerlink" title="替换-置换密码"></a>替换-置换密码</h2><p>Shannon在那篇著名的文章中，介绍了替换-置换（S-P）网络的概念。</p><ul><li>替换 Substitution</li><li>置换 Permutation</li></ul><p>其实和古典密码的思想类似，替换运算用另一个二进制字代替原来的字。</p><p>替换函数就构成密钥，可以看成一个大的查表运算，替换函数也被称为S-box。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201227182545313.png" alt="image-20201227182545313" style="zoom:67%;"></p><p>置换运算则打乱一个二进制字的次序，重新排列的方法构成密钥，称为P-box。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201227182648209.png" alt="image-20201227182648209" style="zoom: 67%;"></p><p>S-P网络就是将这两种运算组合在一起，称为混合变换。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201227182900185.png" alt="image-20201227182900185" style="zoom:67%;"></p><h2 id="Feistel-Cipher"><a href="#Feistel-Cipher" class="headerlink" title="Feistel Cipher"></a>Feistel Cipher</h2><p>Feitel密码将输入块分为左右两部分L(i-1)和R(i-1)，在密码变换的第i轮只使用R(i-1)。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201227183335455.png" alt="image-20201227183335455" style="zoom:67%;"></p><p>变换过程可以表示为</p><script type="math/tex; mode=display">\begin{align}L(i) &= R(i-1) \\R(i) &= L(i-1) \oplus g(K(i), R(i-1))\end{align}</script><p>S盒提供输入bits混合作用（confusion）。</p><ul><li>使密钥和密文之间关系复杂化</li><li>极小化统计特性，使统计分析攻击不能奏效。</li></ul><p>P盒提供扩散作用（diffusion）</p><ul><li>将明文和密钥的影响尽可能散步到较多个输出的密文中（将明文冗余度分散到密文中）。</li></ul><h3 id="雪崩效应"><a href="#雪崩效应" class="headerlink" title="雪崩效应"></a>雪崩效应</h3><ul><li>输入改变1bit，导致近半的bit发生变化。</li><li>对于一个函数<script type="math/tex">f</script>来说，较好的雪崩特性是指<ul><li>对于<script type="math/tex">2^m</script>个明文向量，分为<script type="math/tex">2^{m-1}</script>个向量对<script type="math/tex">(x_i, x_i')</script>，每对向量只有一个bit不同。</li><li>定义<script type="math/tex">v_i = f(x) \oplus f(x_i)</script>，则近半的<script type="math/tex">v_i</script>为1。</li></ul></li></ul><h3 id="完备性效应"><a href="#完备性效应" class="headerlink" title="完备性效应"></a>完备性效应</h3><ul><li>每个输出比特是所有输入比特的复杂函数的输出。</li><li>对于一个函数<script type="math/tex">f</script>来说，较好的完备性是指<ul><li>对密文输出向量的每一个比特j，至少存在一个明文对<script type="math/tex">(x_i, x_i')</script>。</li><li>此明文对只在第i比特不同，且<script type="math/tex">f(x_i)</script>与<script type="math/tex">f(x_i')</script>的第j比特不同。</li></ul></li></ul><h3 id="Feistel-Cipher设计"><a href="#Feistel-Cipher设计" class="headerlink" title="Feistel Cipher设计"></a>Feistel Cipher设计</h3><p>雪崩特性保证了小的输入变化会导致大的输出变化，完备性保证了每个输出比特依赖于所有的输入比特。</p><p>设计密码时需要以下参数</p><ul><li>分组大小</li><li>密钥大小</li><li>轮数</li><li>子密钥生成</li><li>轮函数</li></ul><p>设计一个快速/安全的算法是困难的。</p><h2 id="Lucifer"><a href="#Lucifer" class="headerlink" title="Lucifer"></a>Lucifer</h2><p>第一个可用的替换-置换密码。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201227190818450.png" alt="image-20201227190818450" style="zoom:67%;"></p><p>分组长度128bit，密钥长度128bit，每一轮的子密钥是密钥的左半部分。</p><p>密钥每次向左旋转56bit，密钥的每部分都参与运算。</p><script type="math/tex; mode=display">\begin{align}L_i &= R_{i-1} \\R_i &= L_{i-1} \oplus P(K_{i-1}\oplus S(K_{i-1})) \\K_i &= ROL(K_{i-1})\end{align}</script><p>Lucifer共有16轮数据计算，使用8对4bitS盒实现替换，用几个8-bit置换组成64bit的简单置换。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201227191928132.png" alt="image-20201227191928132" style="zoom:67%;"></p><h2 id="S-DES"><a href="#S-DES" class="headerlink" title="S-DES"></a>S-DES</h2><p>S-DES即Simplified DES，供教学使用，有着和DES相似的特性和结构，但参数小。</p><p>S-DES主要有以下几个函数</p><ul><li>初始置换IP（initial permutation）</li><li>复合函数<script type="math/tex">f_k</script><ul><li>由密钥K确定，具有转换和替换的运算。</li></ul></li><li>转换函数SW</li></ul><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201227193325791.png" alt="image-20201227193325791" style="zoom:67%;"></p><p>加密算法可以表示为</p><script type="math/tex; mode=display">cipher = IP^{-1}(f_{k2}(SW(f_{k1}(IP(plain)))))</script><p>其中</p><script type="math/tex; mode=display">K_1 = P_8(移位(P_{10}(K))) \\K_2 = P_8(移位(移位(P_{10}(K))）)</script><p>密钥生成可以用下图表示，LS代表循环左移</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201227193303826.png" alt="image-20201227193303826" style="zoom:67%;"></p><p>初始置换</p><script type="math/tex; mode=display">IP = \begin{pmatrix} 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 \\ 2 & 6 & 3 & 1 & 4 & 8 & 5 & 7 \end{pmatrix}</script><script type="math/tex; mode=display">IP^{-1} = \begin{pmatrix} 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 \\ 4 & 1 & 3 & 5 & 7 & 2 & 8 & 6 \end{pmatrix}</script><p>S-DES的加密过程如下</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201227195605766.png" style="zoom:67%;"></p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201227195620844.png" style="zoom:67%;"></p><p>对于S-DES，<script type="math/tex">f_k</script>是加密方案中最重要的部分</p><script type="math/tex; mode=display">f_k(L, R) = (L\oplus F(R, SK), R)</script><p>其中对于映射F，输入为4bit，第一步进行扩张/置换（E/P）运算</p><script type="math/tex; mode=display">(n_1, n_2, n_3, n_4) \xrightarrow{E/P} \begin{pmatrix} n_4 & n_1 & n_2 & n_3 \\ n_2 & n_3 & n_4 & n_1 \end{pmatrix}</script><p>之后将密钥与E/P的结果作异或</p><script type="math/tex; mode=display">\begin{pmatrix} n_4+k_{11} & n_1+k_{12} & n_2+k_{13} & n_3+k_{14} \\ n_2+k_{15} & n_3+j_{16} & n_4+k_{17} & n_1+k_{18} \end{pmatrix} = \begin{pmatrix} P_{0,0} & P_{0,1} & P_{0,2} & P_{0,3} \\ P_{1,0} & P_{1,1} & P_{1,2} & P_{1,3} \end{pmatrix}</script><p>将第一行和第二行分别输入两个S盒，得到两个2bit的输出。</p><p>S盒接收4bit输入，将第1和第4比特组成的数作为行，第2和第3比特组成的数作为列。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201227201918812.png" alt="image-20201227201918812" style="zoom:67%;"></p><h3 id="安全分析"><a href="#安全分析" class="headerlink" title="安全分析"></a>安全分析</h3><p>对10bit密钥的强行攻击是可行的，可以利用已知明文攻击。</p><p>密钥空间：<script type="math/tex">2^{10}=1024</script></p><p>已知明文<script type="math/tex">(p_1, p_2,\dots,p_8)</script>和密文<script type="math/tex">(c_1, c_2,\dots,c_8)</script>，密钥<script type="math/tex">(k_1, k_2,\dots,k_{10})</script>作为未知数。</p><p>S-DES可以表示为8个含10个变量的非线性方程，非线性是S盒作用的结果。</p><h2 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h2><p>分组长度64bit，密文64bit。密钥为64bit，只有56bit参与运算，8bit作为奇偶校验位。</p><p>算法有以下三个阶段</p><ul><li>对明文X，通过初始置换IP得到<script type="math/tex">X_0 = IP(X) = L_0R_0</script></li><li>函数F进行16次迭代<ul><li><script type="math/tex; mode=display">L_i = R_{i-1}, R_i = L_{i-1} \oplus F(R_{i-1}, K_i)\quad 1\leq i\leq 16</script></li><li><script type="math/tex">K_i</script>是长为48位的子密钥。</li></ul></li><li>对比特串使用逆置换得到密文<script type="math/tex">Y=IP^{-1}(R_{16}L_{16})</script></li></ul><p>每一轮的结构可以用下图表示</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201227204624671.png" alt="image-20201227204624671" style="zoom:67%;"></p><p>相比于S-DES，DES的F函数更加复杂。</p><ul><li>F的输入为32bit的消息和48bit的密钥，输出为32bit。</li><li>第一步利用扩展函数，将消息扩展为48bit。</li><li>随后计算消息与密钥的异或，将48bit写成8个6bit数。</li><li>用8个S盒接收6bit数的输入，输出8个4bit数。每个S盒是4×16的矩阵，b1b6确定行号，b3b4b5b6确定列号。</li><li>最后经过一个置换函数得到结果。</li></ul><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201227204728767.png" alt="image-20201227204728767" style="zoom:67%;"></p><p>子密钥的生成如下图所示</p><ul><li>PC-1和PC-2都是固定置换，<script type="math/tex">LS_i</script>表示循环左移。</li><li>注意<script type="math/tex">K_i</script>为48bit。</li></ul><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201227205558988.png" alt="image-20201227205558988" style="zoom:67%;"></p><h3 id="DES的改进"><a href="#DES的改进" class="headerlink" title="DES的改进"></a>DES的改进</h3><p>双重DES</p><script type="math/tex; mode=display">C = E_{K_2}[E_{K_1}[P]] \\ P = D_{K_1}[D_{K_2}[C]]</script><p>三重DES</p><script type="math/tex; mode=display">C = E_{K_1}[D_{K_2}[E_{K_1}[P]]] \\ P = D_{K_1}[E_{K_2}[D_{K_1}[C]]]</script><p>三种DES的密钥长度为<script type="math/tex">2^{112}</script>，而标准DES的密钥长度为<script type="math/tex">2^{56}</script>。</p><h2 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h2><p>分组长度64bit，密钥长度128bit，进行8轮迭代操作。</p><p>IDEA中，定义了三种运算。</p><ul><li>逐位异或</li><li>整数模<script type="math/tex">2^{16}</script>加<script type="math/tex">\boxplus</script></li><li>整数模<script type="math/tex">2^{16}+1</script>乘<script type="math/tex">\boxdot</script>（IDEA的S盒）</li></ul><p>IDEA的扩散来自于MA结构，它接收两个16bit的明文消息和两个子密钥作为输入，产生两个16bit的输出。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201228100105211.png" alt="image-20201228100105211"></p><p>IDEA一共产生52个16bit的子密钥，每一轮使用6个子密钥，另外还需要4个额外子密钥。</p><p>前8个子密钥直接从密钥中取出，之后的密钥由25bit的循环左移产生。</p><ul><li>IDEA是PGP的一部分。</li><li>IDEA能抗差分分析和相关分析。</li><li>IDEA似乎没有DES意义下的弱密钥。</li></ul><h2 id="AES-Rijndael"><a href="#AES-Rijndael" class="headerlink" title="AES-Rijndael"></a>AES-Rijndael</h2><ul><li><p>分组长度128bit，密钥长度为128、192或256bit，相应的迭代轮数为10、12和14。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201228160159238.png" alt="image-20201228160159238" style="zoom:67%;"></p></li><li><p>AES的轮函数由四个变换构成，最后一轮省略了列混合。</p><ul><li><p>字节替换</p><ul><li>替换表是一个16×16的矩阵（S盒）。</li><li>输入8bit，高4位作为行，低4位作为列，输出8bit。</li></ul></li><li><p>行移位</p><ul><li>字节的循环移位运算。</li></ul><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201228160612036.png" alt="image-20201228160612036" style="zoom:67%;"></p></li><li><p>列混合</p><ul><li>在<script type="math/tex">GF(2^8)</script>上乘以固定多项式<script type="math/tex">a(x)</script>并模除<script type="math/tex">(x^4+1)</script></li><li><script type="math/tex; mode=display">S'(x)=a(x)\otimes S(x),\ a(x)=3x^3+x^2+x+2</script></li></ul></li><li><p>轮密钥加</p><ul><li>与每轮的子密钥进行异或操作，子密钥长度等于分组长度。</li></ul><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201228160836700.png" alt="image-20201228160836700" style="zoom:67%;"></p></li></ul><p>四种变换可以用下图表示</p></li></ul><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201228160043732.png" alt="image-20201228160043732" style="zoom:67%;"></p><p>AES的子密钥长度为128bit，也即16个字节，子密钥的生成过程如下。</p><ul><li>首先将16个字节分为4组，每组4个字节。</li><li>循环移位后，经过S盒实现替换处理。</li><li>第一个字节与轮常数异或。</li><li>将得到的字节与原先的字节按位异或，即为下一轮的密钥。</li></ul><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201228161702983.png" alt="image-20201228161702983" style="zoom:67%;"></p><h2 id="分组密码的工作模式"><a href="#分组密码的工作模式" class="headerlink" title="分组密码的工作模式"></a>分组密码的工作模式</h2><p>DES定义了4种工作模式。</p><ul><li>Block Mode<ul><li>ECB</li><li>CBC</li></ul></li><li>Stream Mode<ul><li>CFB</li><li>OFB</li></ul></li></ul><h3 id="ECB-Electronic-Codebook-Book"><a href="#ECB-Electronic-Codebook-Book" class="headerlink" title="ECB - Electronic Codebook Book"></a>ECB - Electronic Codebook Book</h3><p>将消息分为独立的加密模块，分组长度为64bit，每块单独使用DES。</p><p>适合少量的数据加密，但是对于相同的明文来说，产生的密文也相同（不安全）。</p><p>如果需要安全传递DES密钥，ECB是最合适的模式。</p><script type="math/tex; mode=display">C_i = E_K(P_i) \\P_i = D_K(C_i)</script><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201228161945839.png" alt="image-20201228161945839" style="zoom:67%;"></p><h3 id="CBC-Cipher-Block-Chaining"><a href="#CBC-Cipher-Block-Chaining" class="headerlink" title="CBC - Cipher Block Chaining"></a>CBC - Cipher Block Chaining</h3><p>密码分组链接模式构造一个初始向量，将密文与明文联结。</p><p>为了提高安全性，应该保护初始向量，可使用ECB加密模式发送。</p><p>CBC对于加密长于64bit的消息非常合适，除了能够获得保密性，还可以实现认证（因为初始向量的保密性）。</p><p>值得一提的是，如果攻击者能修改IV，则会发生错误传播。</p><script type="math/tex; mode=display">C_i = E_K(C_{i-1}\oplus X_i) \\X_i = C_{i-1} \oplus D_K(C_i)</script><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201228162226305.png" alt="image-20201228162226305" style="zoom:67%;"><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201228162308253.png" alt="image-20201228162308253"></p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201228162327881.png" alt="image-20201228162327881" style="zoom:67%;"></p><h3 id="CFB-Cipher-FeedBack"><a href="#CFB-Cipher-FeedBack" class="headerlink" title="CFB - Cipher FeedBack"></a>CFB - Cipher FeedBack</h3><p>DES是分组长为64bit的分组密码，利用CFB模式或OFB模式可以将其转换为流密码。</p><p>对于密码反馈模式，加密算法的输入是64bit移位寄存器，初值为一个初始向量。</p><p>和CBC模式一样，CFB也可以实现保密与认证，也会发生错误传播。</p><script type="math/tex; mode=display">C_i = P_i \oplus DES_K(C_{i-1}) \\C_{-1} = IV</script><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201228163342807.png" alt="image-20201228163342807" style="zoom:67%;"></p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201228163350510.png" alt="image-20201228163350510" style="zoom:67%;"></p><h3 id="OFB-Output-FeedBack"><a href="#OFB-Output-FeedBack" class="headerlink" title="OFB - Output FeedBack"></a>OFB - Output FeedBack</h3><p>输出反馈方式的结构类似于CFB，不过OFB将加密算法的输出反馈到移位寄存器，而CFB将密文单元反馈到移位寄存器。</p><p>OFB的优点是避免了错误传播，如果第一段密文中出错，解密结果中只有第一段明文受影响。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201228164324675.png" alt="image-20201228164324675" style="zoom:67%;"></p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201228164338403.png" alt="image-20201228164338403" style="zoom:67%;"></p><h3 id="CTR-Counter"><a href="#CTR-Counter" class="headerlink" title="CTR - Counter"></a>CTR - Counter</h3><p>计算器模式可以并行加密，并且实现了加密数据块的随机访问。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201228164700793.png" alt="image-20201228164700793" style="zoom:67%;"></p><h2 id="密码分析攻击"><a href="#密码分析攻击" class="headerlink" title="密码分析攻击"></a>密码分析攻击</h2><ul><li>唯密文攻击</li><li>已知明文攻击</li><li>选择明文攻击</li><li>自适应选择明文攻击</li><li>选择密文攻击</li><li>自适应选择密文攻击</li></ul><p>DES可能会受到差分分析攻击（分析明文对的差值对密文对的影响）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍分组密码，包括Feistel Cipher、DES和IDEA等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="现代密码学" scheme="https://entropy2333.github.io/categories/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
      <category term="分组密码" scheme="https://entropy2333.github.io/tags/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>现代密码学（二）古典密码</title>
    <link href="https://entropy2333.github.io/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/"/>
    <id>https://entropy2333.github.io/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/</id>
    <published>2020-12-27T09:08:17.000Z</published>
    <updated>2020-12-27T10:15:18.993Z</updated>
    
    <content type="html"><![CDATA[<p>介绍古典代换密码和古典置换密码。</p><a id="more"></a><h2 id="古典密码"><a href="#古典密码" class="headerlink" title="古典密码"></a>古典密码</h2><p>古典密码只要有两种加密方式，替换和置换（substitution and transposition）。</p><p>替换是用新的字符代替原字符，置换是不改变原文字母集，打乱字符顺序。</p><h2 id="古典代换密码"><a href="#古典代换密码" class="headerlink" title="古典代换密码"></a>古典代换密码</h2><h3 id="Caesar-Cipher-恺撒密码"><a href="#Caesar-Cipher-恺撒密码" class="headerlink" title="Caesar Cipher-恺撒密码"></a>Caesar Cipher-恺撒密码</h3><p>恺撒密码的替换方法是，每个字母用其后的第三个字母替换。</p><script type="math/tex; mode=display">\alpha\leftarrow\alpha+3</script><p>恺撒密码可以表示为</p><ul><li>Plain: ABCDEFGHIJKLMNOPQRSTUVWXYZ</li><li>Cipher: DEFGHIJKLMNOPQRSTUVWXYZABC</li></ul><p>如密文L FDPH L VDZ L FRQTXHUHG，对应的明文即为移位三位，I CAME I SAW CONQUERED。</p><p>当然，恺撒密码也可以将移位的长度改成1-25的任一个，换言之，共有25种可能的密码算法（移位0不可用）。</p><h3 id="混合单表替换密码"><a href="#混合单表替换密码" class="headerlink" title="混合单表替换密码"></a>混合单表替换密码</h3><p>单字母替换密码用一个字母代替另外一个字母，相当于构造了字母表到字母表的双射，密钥长度是26个字母。</p><h3 id="Vigenere-Cipher"><a href="#Vigenere-Cipher" class="headerlink" title="Vigenère Cipher"></a>Vigenère Cipher</h3><p>发明了多字母替换密码，一个字母可以被多个字母替换，通过密钥选择对每个字母使用哪个字母表。</p><p>密钥的第i个字母表示使用第i个字母表。</p><p>如下例，密钥为CIPHER，分别定义了六张字母表（六个双射）。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/image-20201227175332395.png" alt="image-20201227175332395"></p><p>对于明文，用密钥选择字母用哪个字母表，这里的效果相当于明文与密钥相加减一。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/image-20201227175322132.png" alt="image-20201227175322132"></p><h3 id="Ciphers-Machines"><a href="#Ciphers-Machines" class="headerlink" title="Ciphers Machines"></a>Ciphers Machines</h3><ul><li>Jefferson Cylinder</li><li>Wheatstone disc</li><li>the German Enigma</li><li>the Swedish Hagelin</li><li>the Janpanese Purple</li></ul><h2 id="古典置换密码"><a href="#古典置换密码" class="headerlink" title="古典置换密码"></a>古典置换密码</h2><p>置换密码的核心思想是，按一定规则写出明文，按另一规则读出密文。</p><p>密钥就是用于读密文和写明文的方法。</p><h3 id="Scytale密码"><a href="#Scytale密码" class="headerlink" title="Scytale密码"></a>Scytale密码</h3><p>消息沿着圆柱横写，密钥是纸条和圆柱的宽度。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/image-20201227180058573.png" alt="image-20201227180058573"></p><h3 id="Rail-Fence-Cipher-轨道栅栏密码"><a href="#Rail-Fence-Cipher-轨道栅栏密码" class="headerlink" title="Rail Fence Cipher-轨道栅栏密码"></a>Rail Fence Cipher-轨道栅栏密码</h3><p>在不同行写下消息字母，按行读取消息。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/image-20201227180208972.png" alt="image-20201227180208972"></p><h3 id="几何图形密码"><a href="#几何图形密码" class="headerlink" title="几何图形密码"></a>几何图形密码</h3><p>以一种形式写，用另一种形式读。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/image-20201227180223935.png" alt="image-20201227180223935"></p><h3 id="行变换密码"><a href="#行变换密码" class="headerlink" title="行变换密码"></a>行变换密码</h3><p>按行写出字母，以密钥给出的顺序按行读出密文。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/image-20201227180454135.png" alt="image-20201227180454135"></p><p>对上图的解释：</p><ul><li>给定明文，分组长度为5，按25413的顺序对字母重新编排，如THESI变成STIEH。</li><li>给定密文，分组长度为5，按41532的顺序读取信息，如STIEH变成THESI。</li></ul><p>其实相当于定义了置换</p><script type="math/tex; mode=display">\sigma = \begin{pmatrix} 1 & 2 & 3 & 4 & 5 \\ 2 & 5 & 4 & 1 & 3 \end{pmatrix}</script><p>对应的逆置换即为</p><script type="math/tex; mode=display">\sigma^{-1} = \begin{pmatrix} 2 & 5 & 4 & 1 & 3 \\ 1 & 2 & 3 & 4 & 5 \end{pmatrix} = \begin{pmatrix} 1 & 2 & 3 & 4 & 5 \\ 4 & 1 & 5 & 3 & 2 \end{pmatrix}</script><h4 id="密码分析"><a href="#密码分析" class="headerlink" title="密码分析"></a>密码分析</h4><p>我们希望猜测密钥周期，再对可能的行列变换进行猜测。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/image-20201227181407687.png" alt="image-20201227181407687"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍古典代换密码和古典置换密码。&lt;/p&gt;
    
    </summary>
    
    
      <category term="现代密码学" scheme="https://entropy2333.github.io/categories/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
      <category term="古典密码" scheme="https://entropy2333.github.io/tags/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>现代密码学（一）绪论</title>
    <link href="https://entropy2333.github.io/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%80%EF%BC%89%E7%BB%AA%E8%AE%BA/"/>
    <id>https://entropy2333.github.io/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%80%EF%BC%89%E7%BB%AA%E8%AE%BA/</id>
    <published>2020-12-27T09:07:53.000Z</published>
    <updated>2020-12-27T09:27:40.070Z</updated>
    
    <content type="html"><![CDATA[<p>介绍密码学的基本概念。</p><a id="more"></a><h2 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h2><p>密码学是一门研究秘密信息隐写技术的学科。</p><ul><li>可以使消息的内容对所有人（除了发送者和接收者）保密</li><li>可以使接收者验证消息的正确性</li></ul><p>常用的术语如下</p><ul><li>明文 plaintext</li><li>密文 ciphertext</li><li>密码算法 cipher</li><li>密钥 key</li><li>编码 encipher/encode</li><li>译码 decipher/decode</li><li>密码分析 cryptanalysis/codebreaking</li><li>密码学 cryptology</li></ul><h3 id="符号记法"><a href="#符号记法" class="headerlink" title="符号记法"></a>符号记法</h3><p>加密 Encryption</p><script type="math/tex; mode=display">C = EK(P)</script><p>解密 Decryption</p><script type="math/tex; mode=display">P = EK_{-1}(C)</script><p>可以把密码系统理解为明文空间到密文空间的变换，其中密钥取自密钥空间。</p><script type="math/tex; mode=display">P\xrightarrow{EK}C \\C\xrightarrow{EK_{-1}}P</script><h2 id="算法分类"><a href="#算法分类" class="headerlink" title="算法分类"></a>算法分类</h2><ul><li>私钥加密算法<ul><li>分组密码</li><li>流密码（序列密码）</li></ul></li><li>公钥加密算法</li><li>数字签名算法</li><li>哈希函数</li></ul><h2 id="密码分析"><a href="#密码分析" class="headerlink" title="密码分析"></a>密码分析</h2><p>密码分析学是指在没有加密密钥的情况下，攻击密文的过程。</p><ul><li>唯密文攻击<ul><li>只知道算法与一些密文</li><li>利用统计方法</li><li>需要能够识别明文</li></ul></li><li>已知明文攻击<ul><li>知道一些明文/密文对</li><li>利用已知的明文/密文对进行攻击</li></ul></li><li>选择明文攻击<ul><li>能够选择明文并得到相应的密文</li><li>利用算法的结构进行攻击</li></ul></li><li>选择密文攻击<ul><li>能够选择密文并得到相应的明文</li><li>利用对算法结构的知识进行攻击</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍密码学的基本概念。&lt;/p&gt;
    
    </summary>
    
    
      <category term="现代密码学" scheme="https://entropy2333.github.io/categories/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
      <category term="密码学" scheme="https://entropy2333.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>《C++ Primer》 Chapter 3 字符串、向量和数组</title>
    <link href="https://entropy2333.github.io/2020/11/23/%E3%80%8AC++%20Primer%E3%80%8B%20Chapter%203%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/"/>
    <id>https://entropy2333.github.io/2020/11/23/%E3%80%8AC++%20Primer%E3%80%8B%20Chapter%203%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/</id>
    <published>2020-11-23T08:48:44.000Z</published>
    <updated>2020-11-30T07:03:57.402Z</updated>
    
    <content type="html"><![CDATA[<p>介绍标准库string和vector，以及迭代器和数组的使用。</p><a id="more"></a><h3 id="命名空间的using声明"><a href="#命名空间的using声明" class="headerlink" title="命名空间的using声明"></a>命名空间的using声明</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>::name;</span><br></pre></td></tr></table></figure><p>头文件不应该包含using声明。</p><h2 id="标准库类型string"><a href="#标准库类型string" class="headerlink" title="标准库类型string"></a>标准库类型string</h2><p>string定义在命名空间std中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std::string;</span><br></pre></td></tr></table></figure><h3 id="定义和初始化"><a href="#定义和初始化" class="headerlink" title="定义和初始化"></a>定义和初始化</h3><p>如果使用等号，实际上执行的是拷贝初始化。反之，执行的是直接初始化。</p><p><img src="/2020/11/23/%E3%80%8AC++%20Primer%E3%80%8B%20Chapter%203%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/image-20201130133107639.png" alt="image-20201130133107639"></p><h3 id="string对象上的操作"><a href="#string对象上的操作" class="headerlink" title="string对象上的操作"></a>string对象上的操作</h3><p><img src="/2020/11/23/%E3%80%8AC++%20Primer%E3%80%8B%20Chapter%203%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/image-20201130125844111.png" alt="image-20201130125844111"></p><h4 id="读写"><a href="#读写" class="headerlink" title="读写"></a>读写</h4><p>执行读取操作时，会自动忽略开头的空白字符，直至遇到下一处空白。</p><p>输入”    Hello World!    “，输出则为”Hello”。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以用getline读取一整行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">line</span>;</span><br><span class="line">    <span class="keyword">while</span> (getline(<span class="built_in">cin</span>, <span class="built_in">line</span>))</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">line</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="empty-amp-size"><a href="#empty-amp-size" class="headerlink" title="empty&amp;size"></a>empty&amp;size</h4><p>empty判断string对象是否为空，返回bool。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (getline(<span class="built_in">cin</span>, <span class="built_in">line</span>))</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">line</span>.empty())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">line</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>size返回string对象的长度，类型为string::size_type。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (getline(<span class="built_in">cin</span>, <span class="built_in">line</span>))</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">line</span>.empty())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">line</span>.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><blockquote><p>此时，空字符也会计数。</p></blockquote><p>当使用size_type进行比较时，注意不要与int混用，因为负值的带符号数会转化为大整数的无符号数。</p><h4 id="比较-amp-加法"><a href="#比较-amp-加法" class="headerlink" title="比较&amp;加法"></a>比较&amp;加法</h4><p>string对象逐字符比较，按字典序比较。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> s2 = <span class="string">&quot;abc def&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> s3 = <span class="string">&quot;abdef&quot;</span>;</span><br><span class="line"><span class="comment">// res: s1 &lt; s2 &lt; s3</span></span><br></pre></td></tr></table></figure><p>两个string对象可以相加，字面值也可以和string对象相加。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1 = <span class="string">&quot;hello&quot;</span>, s2 = <span class="string">&quot;world&quot;</span>。</span><br><span class="line"><span class="built_in">string</span> s3 = s1 + s2。</span><br><span class="line"><span class="built_in">string</span> s4 = s1 + <span class="string">&quot; &quot;</span> + s2 + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> s5 = <span class="string">&quot;hello&quot;</span> + <span class="string">&quot; &quot;</span> + s2; <span class="comment">// error</span></span><br></pre></td></tr></table></figure><blockquote><p>运算时，应保证+两侧的运算对象至少有一个是string。</p></blockquote><h3 id="处理string中的字符"><a href="#处理string中的字符" class="headerlink" title="处理string中的字符"></a>处理string中的字符</h3><p>下表给出了一些关于字符属性的函数。</p><p><img src="/2020/11/23/%E3%80%8AC++%20Primer%E3%80%8B%20Chapter%203%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/image-20201130125720977.png" alt="image-20201130125720977"></p><blockquote><p>C++标准库为了兼容C，将C的头文件如name.h，命名为cname。</p><p>C++程序应该使用cname形式的头文件，以区分从C继承的头文件。</p></blockquote><p>为了遍历string对象，可以使用下标，也可以使用范围for语句（推荐）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> c : s)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>如果想要改变字符，需要把循环变量定义为引用类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : s)</span><br><span class="line">    c = <span class="built_in">toupper</span>(c);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s;</span><br></pre></td></tr></table></figure><p>有时候只需要处理部分字符，可以使用下标，也可以使用迭代器（后续介绍）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现单词首字母大写</span></span><br><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">decltype</span>(s.<span class="built_in">size</span>()) index = <span class="number">0</span>;</span><br><span class="line">     index != s.<span class="built_in">size</span>(); ++index) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span> &amp;&amp; <span class="built_in">isalpha</span>(s[index])) &#123;</span><br><span class="line">        s[index] = <span class="built_in">toupper</span>(s[index]);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isalpha</span>(s[index]) &amp;&amp; !<span class="built_in">isalpha</span>(s[index<span class="number">-1</span>]))</span><br><span class="line">        s[index] = <span class="built_in">toupper</span>(s[index]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s; <span class="comment">// output: &quot;Hello world&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>使用下标时，切忌下标越界，应该时刻检查下标的合法性。</p></blockquote><h2 id="标准库类型vector"><a href="#标准库类型vector" class="headerlink" title="标准库类型vector"></a>标准库类型vector</h2><p>vector表示相同类型对象的集合，每个对象都有一个索引用于访问对象。因此vector也被称为容器，vector同时也是一个类模板（距离还比较遥远）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br></pre></td></tr></table></figure><p>模板实例化时，需要提供对象类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec;                <span class="comment">// 元素是int</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; file;    <span class="comment">// 元素是存放string的vector</span></span><br></pre></td></tr></table></figure><p>vector作为类模板，不是类型。</p><p>引用不是对象，不存在包含引用的vector。</p><h3 id="定义和初始化vector对象"><a href="#定义和初始化vector对象" class="headerlink" title="定义和初始化vector对象"></a>定义和初始化vector对象</h3><p><img src="/2020/11/23/%E3%80%8AC++%20Primer%E3%80%8B%20Chapter%203%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/image-20201130133133358.png" alt="image-20201130133133358"></p><p>注意区分列表初始化和元素数量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1&#123;<span class="number">10</span>&#125;; <span class="comment">// 列表初始化，v1有1个元素，值为10。</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// v2有10个元素，值为0。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v3&#123;<span class="number">10</span>, <span class="number">1</span>&#125;; <span class="comment">// 列表初始化，v3有2个元素，值为10和1。</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v4</span><span class="params">(<span class="number">10</span>, <span class="number">1</span>)</span></span>; <span class="comment">// v4有10个元素，值为1。</span></span><br></pre></td></tr></table></figure><h3 id="向vector对象添加元素"><a href="#向vector对象添加元素" class="headerlink" title="向vector对象添加元素"></a>向vector对象添加元素</h3><p>可以用vector的成员函数push_back添加元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">    v.push_back(i);</span><br></pre></td></tr></table></figure><blockquote><p>与C不同，C++推荐先定义一个空的vector对象，运行时向其中添加具体值。</p></blockquote><h3 id="其他vector操作"><a href="#其他vector操作" class="headerlink" title="其他vector操作"></a>其他vector操作</h3><p><img src="/2020/11/23/%E3%80%8AC++%20Primer%E3%80%8B%20Chapter%203%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/image-20201130133935086.png" alt="image-20201130133935086"></p><p>vector同样支持范围for语句。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : v)    <span class="comment">// 使用引用对vector的元素赋值</span></span><br><span class="line">    i *= <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : v)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure><p>与string类似，vector的size函数返回类型为vector<T>::size_type。</T></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 统计各分数段内的人数</span></span><br><span class="line"><span class="comment">// input: 42 65 95 100 39 67 95 76 88 76 83 92 76 93 101</span></span><br><span class="line"><span class="comment">// output: 0 0 0 1 1 0 2 3 2 4 1</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span>&gt; <span class="title">scores</span><span class="params">(<span class="number">11</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">unsigned</span> grade = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; grade) &#123;</span><br><span class="line">    <span class="keyword">if</span> (grade &lt;= <span class="number">100</span>)</span><br><span class="line">        ++scores[grade/<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : scores)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="迭代器介绍"><a href="#迭代器介绍" class="headerlink" title="迭代器介绍"></a>迭代器介绍</h2><h3 id="使用迭代器"><a href="#使用迭代器" class="headerlink" title="使用迭代器"></a>使用迭代器</h3><p>有迭代器的类型拥有名为begin和end的成员。</p><p>begin成员返回指向第一个元素的迭代器，end成员返回指向容器“尾后”元素的迭代器，通常被称作尾后迭代器。</p><p>如果容器为空，begin和end返回的是同一个迭代器，都是尾后迭代器。</p><p><img src="/2020/11/23/%E3%80%8AC++%20Primer%E3%80%8B%20Chapter%203%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/image-20201130135012221.png" alt="image-20201130135012221"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isalpha</span>(*it))</span><br><span class="line">        *it = <span class="built_in">toupper</span>(*it);</span><br></pre></td></tr></table></figure><blockquote><p>C++习惯在for循环中使用!=进行判断，因为大多数迭代器都没有定义&lt;运算符。</p></blockquote><p>迭代器也有const类型，能读取但不能修改vector。</p><p>为了便捷，C++11引入了两个新函数cbegin和cend。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line"><span class="keyword">auto</span> it1 = v1.<span class="built_in">begin</span>();    <span class="comment">// type: vector&lt;int&gt;::iterator</span></span><br><span class="line"><span class="keyword">auto</span> it2 = v2.<span class="built_in">begin</span>();  <span class="comment">// type: vector&lt;int&gt;::const_iterator</span></span><br><span class="line"><span class="keyword">auto</span> it3 = v1.cbegin(); <span class="comment">// type: vector&lt;int&gt;::const_iterator</span></span><br></pre></td></tr></table></figure><p>为了简化解引用和成员访问操作一起使用，C++定义了箭头运算符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*it.empty;   <span class="comment">// error</span></span><br><span class="line">(*it).empty;</span><br><span class="line">it-&gt;empty;</span><br></pre></td></tr></table></figure><h3 id="迭代器运算"><a href="#迭代器运算" class="headerlink" title="迭代器运算"></a>迭代器运算</h3><p><img src="/2020/11/23/%E3%80%8AC++%20Primer%E3%80%8B%20Chapter%203%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/image-20201130135031052.png" alt="image-20201130135031052"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到最接近中间元素的迭代器</span></span><br><span class="line"><span class="keyword">auto</span> mid = v.<span class="built_in">begin</span>() + v.<span class="built_in">size</span>() / <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>C++定义了迭代器的差值，类型为difference_type。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分搜索</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="built_in">text</span>;</span><br><span class="line"><span class="built_in">string</span> sought;</span><br><span class="line"><span class="keyword">auto</span> beg = <span class="built_in">text</span>.<span class="built_in">begin</span>(), <span class="built_in">end</span> = <span class="built_in">text</span>.<span class="built_in">end</span>();</span><br><span class="line"><span class="keyword">auto</span> mid = <span class="built_in">text</span>.<span class="built_in">begin</span>() + (<span class="built_in">end</span> - beg) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (mid != <span class="built_in">end</span> &amp;&amp; *mid != sought) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sought &lt; *mid) <span class="comment">// 在前半部分则忽略后半部分</span></span><br><span class="line">        <span class="built_in">end</span> = mid;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        beg = mid + <span class="number">1</span>; <span class="comment">// 否则忽略前半部分</span></span><br><span class="line">    mid = beg + (<span class="built_in">end</span> - beg) /<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>与vector不同，数组的大小确定不变，不能随意增加元素。</p><h3 id="定义和初始化-1"><a href="#定义和初始化-1" class="headerlink" title="定义和初始化"></a>定义和初始化</h3><p>数组的长度在编译时必须已知，所以维度必须是常量表达式。</p><p>定义数组时，必须指定类型，不能使用auto。和vector一样，不存在引用的数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> cnt = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">unsigned</span> sz = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> *parr[sz];     <span class="comment">// 包含42个整型指针的数组</span></span><br><span class="line"><span class="built_in">string</span> bad[cnt]; <span class="comment">// error</span></span><br></pre></td></tr></table></figure><p>数组也支持列表初始化，此时可以不指明长度，编译器会自动计算。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> sz = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> ial[sz] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a2[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a3[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;    <span class="comment">// a3[] = &#123;0, 1, 2, 0, 0&#125;</span></span><br></pre></td></tr></table></figure><p>值得注意的是，在使用字符数组时，会在结尾添加一个空字符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a1[] = &#123;<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;+&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> a2[] = &#123;<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;    <span class="comment">// 显式添加空字符</span></span><br><span class="line"><span class="keyword">char</span> a3[] = <span class="string">&quot;C++&quot;</span>;    <span class="comment">// 自动添加空字符</span></span><br><span class="line"><span class="keyword">char</span> a4[<span class="number">6</span>] = <span class="string">&quot;Daniel&quot;</span>; <span class="comment">// error</span></span><br></pre></td></tr></table></figure><p>上述表达式中，a1长度为3，a2和a3的长度都是4，a4长度应改为7。</p><p>数组不允许拷贝和赋值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a2[] = a; <span class="comment">// error</span></span><br><span class="line">a2 = a; <span class="comment">// error</span></span><br></pre></td></tr></table></figure><p>为了理解复杂的数组声明，可以从内向外阅读。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptrs[<span class="number">10</span>]; <span class="comment">// 含有10个整型指针的数组</span></span><br><span class="line"><span class="keyword">int</span> &amp;refs[<span class="number">10</span>]; <span class="comment">// 不存在引用的数组</span></span><br><span class="line"><span class="keyword">int</span> (*Parray)[<span class="number">10</span>] = &amp;arr; <span class="comment">// Parray指向一个含有10个整数的数组</span></span><br><span class="line"><span class="keyword">int</span> (&amp;arrRef)[<span class="number">10</span>] = arr;  <span class="comment">// arrRef引用一个含有10个整数的数组</span></span><br><span class="line"><span class="keyword">int</span> *(&amp;arry)[<span class="number">10</span>] = ptrs;  <span class="comment">// arry是数组的引用，该数组含有10个指针</span></span><br></pre></td></tr></table></figure><h3 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h3><p>数组也可以用范围for语句或下标运算符访问。</p><p>数组下标被定义为size_t类型，定义在cstddef头文件中。</p><h3 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h3><p>使用数组的时候，编译器一般会把它转换成指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> nums[] = &#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">string</span> *p1 = &amp;nums[<span class="number">0</span>]; <span class="comment">// p1指向nums的第一个元素</span></span><br><span class="line"><span class="built_in">string</span> *p2 = &amp;nums;       <span class="comment">// p2和p1等价</span></span><br></pre></td></tr></table></figure><p>尽管能计算得到数组的尾后指针，但容易出错。C++11引入两个函数begin和end，与容器的同名成员功能类似。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *beg = <span class="built_in">begin</span>(ia);</span><br><span class="line"><span class="keyword">int</span> *last = <span class="built_in">end</span>(ia);</span><br></pre></td></tr></table></figure><p>与容器相似，指针相减的类型名为ptrdiff_t，也定义在cstddef中。</p><h4 id="C风格字符串"><a href="#C风格字符串" class="headerlink" title="C风格字符串"></a>C风格字符串</h4><blockquote><p>尽管C++支持，但最好不好使用。</p></blockquote><p><img src="/2020/11/23/%E3%80%8AC++%20Primer%E3%80%8B%20Chapter%203%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/image-20201130144349734.png" alt="image-20201130144349734"></p><h4 id="与旧代码的接口"><a href="#与旧代码的接口" class="headerlink" title="与旧代码的接口"></a>与旧代码的接口</h4><p>允许使用字符串字面值初始化string对象，反过来则不行，需要使用c_str函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">&quot;hello world&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">char</span> *str = s; <span class="comment">// error</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *str = s.c_str();</span><br></pre></td></tr></table></figure><p>可以使用数组初始化vector对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> int_arr[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ivec</span><span class="params">(<span class="built_in">begin</span>(int_arr), <span class="built_in">end</span>(int_arr))</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>C++应当尽量使用vector和迭代器，而非内置数组和指针；应当尽量使用string，而非C风格字符串。</p></blockquote><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>多维数组实际上就是数组的数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia1[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;,</span><br><span class="line">    &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> ia2[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> ia3[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123; <span class="number">0</span> &#125;, &#123; <span class="number">1</span> &#125;, &#123; <span class="number">2</span> &#125;&#125;; <span class="comment">// 初始化每行的第一个元素</span></span><br><span class="line"><span class="keyword">int</span> ia4[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>&#125;; <span class="comment">// 初始化第一行</span></span><br></pre></td></tr></table></figure><p>可以通过下标运算符访问多维数组的元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">size_t</span> rowCnt = <span class="number">3</span>, colCnt = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> ia[rowCnt][colCnt];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != rowCnt; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j != colCnt; ++j) &#123;</span><br><span class="line">        ia[i][j] = i * colCnt + j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以用范围for语句访问，实现同样的效果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;row : ia) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;col : row) &#123;</span><br><span class="line">        col = cnt;</span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为循环中要赋值，所以选用引用类型。其实除了内层循环，其他所有循环的控制变量都应该是引用类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> row : ia)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> col : row)</span><br></pre></td></tr></table></figure><p>上面这段语句将无法通过编译，因为row不是引用类型，所以row的类型是int*。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ip[<span class="number">4</span>];   <span class="comment">// 整形指针的数组</span></span><br><span class="line"><span class="keyword">int</span> (*ip)[<span class="number">4</span>]; <span class="comment">// 指向含有4个整数的数组</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍标准库string和vector，以及迭代器和数组的使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="《C++ Primer》" scheme="https://entropy2333.github.io/categories/%E3%80%8AC-Primer%E3%80%8B/"/>
    
    
      <category term="C++" scheme="https://entropy2333.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>《C++ Primer》 Chapter 2 变量和基本类型</title>
    <link href="https://entropy2333.github.io/2020/11/23/%E3%80%8AC++%20Primer%E3%80%8B%20Chapter%202%20%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"/>
    <id>https://entropy2333.github.io/2020/11/23/%E3%80%8AC++%20Primer%E3%80%8B%20Chapter%202%20%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-11-23T07:01:27.000Z</published>
    <updated>2020-11-23T08:46:26.994Z</updated>
    
    <content type="html"><![CDATA[<p>介绍C++的基本内置类型和复合类型，包括引用和指针的声明，以及const限定符的使用方法。</p><a id="more"></a><h2 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h2><p>下表列出了各内置类型的最小尺寸。</p><p><img src="/2020/11/23/%E3%80%8AC++%20Primer%E3%80%8B%20Chapter%202%20%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/image-20201123150453260.png" alt="image-20201123150453260"></p><blockquote><p>2^31 - 1= 2147483647是个常见的数字。</p></blockquote><h3 id="带符号类型和无符号类型"><a href="#带符号类型和无符号类型" class="headerlink" title="带符号类型和无符号类型"></a>带符号类型和无符号类型</h3><p>无符号类型只能表示大于等于0的值，带符号类型可以表示正负数和0。</p><p>8bit的unsigned char可以表示0~255之间的值，signed char则为-128~127。</p><blockquote><p>执行浮点数运算时选用double</p></blockquote><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul><li>当把非bool的算术值赋给bool时，初始值为0结果为false，否则为true。</li><li>把bool值赋给非bool时，初始值为false则结果为0，true则结果为1。</li><li>赋给无符号类型一个超出表示范围的值，结果是取模后的余数。<ul><li>赋-1给unsigned char，结果是255。</li><li><strong>切勿混用带符号类型和无符号类型！</strong></li><li>因为无符号数非负，所以下面这段代码为死循环。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">10</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h3 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h3><p>C++规定的转义序列如下</p><p><img src="/2020/11/23/%E3%80%8AC++%20Primer%E3%80%8B%20Chapter%202%20%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/image-20201123153641722.png" alt="image-20201123153641722"></p><p>C++还可以对常量添加前缀和后缀，改变默认类型。</p><ul><li>比如L’a’定义了宽字符型字面值，类型是wchar_t。</li></ul><p><img src="/2020/11/23/%E3%80%8AC++%20Primer%E3%80%8B%20Chapter%202%20%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/image-20201123153731472.png" alt="image-20201123153731472"></p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><p>以下四条语句都可以定义一个int变量并初始化为0。</p><p>在C++11，可以用花括号来初始化变量，称为列表初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> cnt = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cnt</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> cnt&#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>初始化：创建变量时，赋予其一个初始值。</p><p>赋值：把对象的当前值擦除，用一个新值代替。</p></blockquote><p>定义在函数体内部的内置类型变量将不被初始化，此时值是未定义的。</p><h3 id="变量定义-amp-声明"><a href="#变量定义-amp-声明" class="headerlink" title="变量定义&amp;声明"></a>变量定义&amp;声明</h3><ul><li>变量声明：规定了变量的类型和名字</li><li>变量定义：还申请存储空间，也可能会为变量赋一个初始值。</li><li>如果想声明一个变量而非定义，要添加关键字extern。</li><li>变量的定义只出现在一个文件中，其他使用该变量的文件对其声明，但不能重复定义。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i; <span class="comment">// 声明变量</span></span><br><span class="line"><span class="keyword">int</span> j;          <span class="comment">// 声明并定义</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>; <span class="comment">// 定义</span></span><br></pre></td></tr></table></figure><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><ul><li>标识符以字母或数字开头，大小写敏感。</li><li>变量名一般小写，类名一般以大写字母开头。</li><li>标识符由多个单词组成，应有区分，如student_loan或studentLoan。</li></ul><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ul><li>如果函数要用到全局变量，则不宜再定义一个同名的局部变量。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">// 用::cnt显式访问全局变量</span></span><br><span class="line">    <span class="comment">// result: 10 20</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ::cnt &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h2><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li>引用为对象起另外一个名字</li><li>无法令引用重新绑定到另外一个对象，所以引用必须初始化。</li><li>引用只能绑定在对象上，引用自身不是对象。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;refVal = val;</span><br><span class="line"><span class="keyword">int</span> refVal;        <span class="comment">// 报错：引用必须初始化</span></span><br></pre></td></tr></table></figure><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><ul><li>指针存放某个对象的地址，使用取地址符&amp;获取地址。</li><li>使用解引用符*访问指针指向的对象。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;val;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p &lt;&lt; *p; <span class="comment">// result: 008FF9F8 1024</span></span><br></pre></td></tr></table></figure><p>空指针不指向任何对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="number">0</span>; <span class="comment">// 指针不能指向字面值常量，0表示空指针。</span></span><br><span class="line"><span class="keyword">int</span> *p3 = <span class="literal">NULL</span>; <span class="comment">// include &lt;cstdlib&gt;</span></span><br></pre></td></tr></table></figure><p>void*是一种特殊的指针，可以指向任意非常量，不能执行解引用操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> pi = <span class="number">3.14</span>, *pd = &amp; pi;</span><br><span class="line"><span class="keyword">void</span> *pv = &amp;pi;</span><br><span class="line">pv = pd;</span><br></pre></td></tr></table></figure><h3 id="理解复合类型的声明"><a href="#理解复合类型的声明" class="headerlink" title="理解复合类型的声明"></a>理解复合类型的声明</h3><p>定义指针和引用时，最好将*和&amp;与变量名连在一起，以免引起误导。</p><p>指针可以指向指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> *pi = &amp;val;</span><br><span class="line"><span class="keyword">int</span> **ppi = &amp;pi;</span><br></pre></td></tr></table></figure><p>引用不是对象，所以不存在指向引用的指针。</p><p>但指针是对象，所以引用可以绑定指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;i;</span><br><span class="line"><span class="keyword">int</span> *&amp;r = p;    <span class="comment">// r是一个对指针p的引用</span></span><br><span class="line"></span><br><span class="line">r = &amp;i;</span><br><span class="line">*r = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h2><h3 id="const的引用"><a href="#const的引用" class="headerlink" title="const的引用"></a>const的引用</h3><p>使用const定义变量时，变量的值不能被改变，const对象必须初始化。</p><blockquote><p>一般const对象仅在文件内有效，多个文件中出现同名的const变量，等同于在不同文件中分别定义了独立的变量。</p><p>如果想共享const变量，需要用extern修饰。</p></blockquote><p>可以把引用绑定到const对象上，称为对常量的引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> val = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;refVal = val;</span><br><span class="line">refVal = <span class="number">10</span>;        <span class="comment">// 错误：对常量的引用不能修改绑定的对象</span></span><br><span class="line"><span class="keyword">int</span> &amp;refVal2 = val; <span class="comment">// 错误：非常量引用不能绑定常量对象</span></span><br></pre></td></tr></table></figure><p>允许为一个常量引用绑定非常量的对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = i * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r4 = r1 * <span class="number">2</span>;    <span class="comment">// 错误：r1是常量引用，r4是非常量引用。</span></span><br></pre></td></tr></table></figure><p>常量引用绑定非常量对象时，不能通过常量引用改变值，但可以通过其他途径改变绑定对象的值。</p><h3 id="const与指针"><a href="#const与指针" class="headerlink" title="const与指针"></a>const与指针</h3><p>指向常量指针不能改变所指对象的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *p = &amp;pi;</span><br><span class="line">*p = <span class="number">10</span>;        <span class="comment">// error</span></span><br></pre></td></tr></table></figure><p>const指针不能改变指针本身的值，而非指向的那个值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> pi = <span class="number">3.14</span>, i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">double</span> *<span class="keyword">const</span> p = &amp;pi;</span><br><span class="line">p = &amp;i;            <span class="comment">// error</span></span><br></pre></td></tr></table></figure><h3 id="顶层const"><a href="#顶层const" class="headerlink" title="顶层const"></a>顶层const</h3><p><strong>顶层const表示指针本身是常量，底层const表示指针指向的对象是一个常量。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> ci = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p1 = &amp;i;        <span class="comment">// top-level</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p2 = &amp;ci;    <span class="comment">// low-level</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p3 = p2; <span class="comment">// low-level &amp; top-level</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r = ci;        <span class="comment">// low-level</span></span><br></pre></td></tr></table></figure><h3 id="constexpr和常量表达式"><a href="#constexpr和常量表达式" class="headerlink" title="constexpr和常量表达式"></a>constexpr和常量表达式</h3><p>常量表达式是指值不会改变并且在编译过程中就能得到计算结果的表达式。</p><h2 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h2><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>有两种方法可以定义类型别名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> wages;</span><br><span class="line"><span class="keyword">using</span> wages = <span class="keyword">double</span>;</span><br></pre></td></tr></table></figure><h3 id="auto-amp-decltype"><a href="#auto-amp-decltype" class="headerlink" title="auto &amp; decltype"></a>auto &amp; decltype</h3><p>auto让编译器去分析表达式所属的类型，auto定义的变量必须有初始值。</p><p>decltype可以返回操作数的数据类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(f()) sum = x;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>, *p = &amp;i;</span><br><span class="line"><span class="keyword">decltype</span>(*p) c; <span class="comment">// 错误：c是int&amp;，必须初始化。</span></span><br></pre></td></tr></table></figure><h2 id="自定义数据结构"><a href="#自定义数据结构" class="headerlink" title="自定义数据结构"></a>自定义数据结构</h2><h3 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SALES_DATA_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SALES_DATA_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍C++的基本内置类型和复合类型，包括引用和指针的声明，以及const限定符的使用方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="《C++ Primer》" scheme="https://entropy2333.github.io/categories/%E3%80%8AC-Primer%E3%80%8B/"/>
    
    
      <category term="C++" scheme="https://entropy2333.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>《C++ Primer》 Chapter 1 开始</title>
    <link href="https://entropy2333.github.io/2020/11/23/%E3%80%8AC++%20Primer%E3%80%8B%20Chapter%201%20%E5%BC%80%E5%A7%8B%20/"/>
    <id>https://entropy2333.github.io/2020/11/23/%E3%80%8AC++%20Primer%E3%80%8B%20Chapter%201%20%E5%BC%80%E5%A7%8B%20/</id>
    <published>2020-11-23T06:29:28.000Z</published>
    <updated>2020-11-23T07:00:11.346Z</updated>
    
    <content type="html"><![CDATA[<p>初识C++。</p><a id="more"></a><h2 id="编写一个简单的C-程序"><a href="#编写一个简单的C-程序" class="headerlink" title="编写一个简单的C++程序"></a>编写一个简单的C++程序</h2><p>每个C++程序都包含若干个函数，其中一个必须命名为main，操作系统通过调用main运行C++程序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编译、运行程序"><a href="#编译、运行程序" class="headerlink" title="编译、运行程序"></a>编译、运行程序</h3><p>程序运行后，可以通过echo命令访问main的返回值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> $? // UNIX</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$ERRORLEVEL</span>% // Windows</span><br></pre></td></tr></table></figure><h2 id="初识输入输出"><a href="#初识输入输出" class="headerlink" title="初识输入输出"></a>初识输入输出</h2><div class="table-container"><table><thead><tr><th>对象</th><th>用途</th></tr></thead><tbody><tr><td>cin</td><td>标准输入</td></tr><tr><td>cout</td><td>标准输出</td></tr><tr><td>cerr</td><td>标准错误</td></tr><tr><td>clog</td><td>程序运行时的一般性信息</td></tr></tbody></table></div><h3 id="注释简介"><a href="#注释简介" class="headerlink" title="注释简介"></a>注释简介</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单行注释</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    多行注释</span></span><br><span class="line"><span class="comment">    不能嵌套</span></span><br><span class="line"><span class="comment">/*</span></span><br></pre></td></tr></table></figure><h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><p>while &amp; for &amp; if</p><h3 id="读取数量不定的输入数据"><a href="#读取数量不定的输入数据" class="headerlink" title="读取数量不定的输入数据"></a>读取数量不定的输入数据</h3><p>当遇到文件结束符（EOF）或遇到一个无效输入时，istream对象的状态会变成无效，条件为假。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; value)</span><br><span class="line">        sum += value;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Sum is &quot;</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Windows系统中，输入EOF的方式是Ctrl + Z；UNIX中，方法是Ctrl + D。</p></blockquote><h3 id="统计输入的词频"><a href="#统计输入的词频" class="headerlink" title="统计输入的词频"></a>统计输入的词频</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> currVal = <span class="number">0</span>, val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; currVal) &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; val)</span><br><span class="line">            <span class="keyword">if</span> (val == currVal)</span><br><span class="line">                ++cnt;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; currVal &lt;&lt; <span class="string">&quot; occurs &quot;</span></span><br><span class="line">                          &lt;&lt; cnt &lt;&lt; <span class="string">&quot; times &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                currVal = val;</span><br><span class="line">                cnt = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; currVal &lt;&lt; <span class="string">&quot; occurs &quot;</span></span><br><span class="line">                  &lt;&lt; cnt &lt;&lt; <span class="string">&quot; times &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类简介"><a href="#类简介" class="headerlink" title="类简介"></a>类简介</h2><blockquote><p>包含来自标准库的头文件，使用&lt;&gt;包含头文件名；不属于标准库的头文件，使用””包围。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;初识C++。&lt;/p&gt;
    
    </summary>
    
    
      <category term="《C++ Primer》" scheme="https://entropy2333.github.io/categories/%E3%80%8AC-Primer%E3%80%8B/"/>
    
    
      <category term="C++" scheme="https://entropy2333.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Internet安全协议与分析（八）课程复习</title>
    <link href="https://entropy2333.github.io/2020/10/31/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AB%EF%BC%89%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/"/>
    <id>https://entropy2333.github.io/2020/10/31/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AB%EF%BC%89%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/</id>
    <published>2020-10-31T06:19:48.000Z</published>
    <updated>2020-10-31T11:01:15.894Z</updated>
    
    <content type="html"><![CDATA[<p>复习所学知识，应付考试orz。</p><a id="more"></a><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><h3 id="挑战-应答"><a href="#挑战-应答" class="headerlink" title="挑战-应答"></a>挑战-应答</h3><ul><li>客户端向服务器发出请求，请求身份认证。</li><li>服务器查询用户是否合法，合法则进行下一步。</li><li>服务器产生随机数，作为“挑战”发给客户端。</li><li>客户端将ID和随机数Hash，发送给服务器。</li><li>服务器比较结果，相同则通过认证，并通知客户端。</li></ul><h3 id="数字信封"><a href="#数字信封" class="headerlink" title="数字信封"></a>数字信封</h3><ul><li>将对称密钥通过非对称加密的方式分发。</li><li>发送方用对称密钥加密明文，并用接收方公钥加密对称密钥，将消息发给接收方。</li><li>接收方用私钥解密获得对称密钥，随后解密得到明文。</li></ul><h3 id="公钥环-amp-私钥环"><a href="#公钥环-amp-私钥环" class="headerlink" title="公钥环&amp;私钥环"></a>公钥环&amp;私钥环</h3><ul><li>公钥环保存该结点拥有的其他用户的公钥</li><li>私钥环保存该节点拥有的公私钥对（加密）</li></ul><h3 id="隧道模式"><a href="#隧道模式" class="headerlink" title="隧道模式"></a>隧道模式</h3><ul><li><p>AH</p><p><img src="/2020/10/31/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AB%EF%BC%89%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/image-20201031143043915.png" alt="image-20201031143043915"></p></li><li><p>ESP</p><p><img src="/2020/10/31/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AB%EF%BC%89%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/image-20201031143105550.png" alt="image-20201031143105550"></p></li></ul><h2 id="简答"><a href="#简答" class="headerlink" title="简答"></a>简答</h2><h3 id="BAN分析Otway-Rees"><a href="#BAN分析Otway-Rees" class="headerlink" title="BAN分析Otway-Rees"></a>BAN分析Otway-Rees</h3><ul><li>密钥有效性</li></ul><script type="math/tex; mode=display">bel(A, goodkey(S, K_{as}, S)) \\bel(B, goodkey(S, K_{bs}, S))</script><ul><li>S的权威性</li></ul><script type="math/tex; mode=display">bel(A, cont(S, skey(A, K_{ab}, B))) \\ bel(B, cont(S, skey(A, K_{ab}, B))) \\bel(A, cont(S, fresh(skey(A, K_{ab}, B)))</script><ul><li>随机数的新鲜性</li></ul><script type="math/tex; mode=display">bel(A, fresh(N_a)) \\bel(B, fresh(N_b))</script><h3 id="Kerberos协议中Ticket-v和认证头的结构和作用"><a href="#Kerberos协议中Ticket-v和认证头的结构和作用" class="headerlink" title="Kerberos协议中Ticket_v和认证头的结构和作用"></a>Kerberos协议中<script type="math/tex">Ticket_v</script>和认证头的结构和作用</h3><ul><li><script type="math/tex">Ticket_v</script>表示该用户已被AS认证</li><li>验证头用于验证ticket有效</li></ul><h3 id="安全协议中Nonce和时戳的作用和区别"><a href="#安全协议中Nonce和时戳的作用和区别" class="headerlink" title="安全协议中Nonce和时戳的作用和区别"></a>安全协议中Nonce和时戳的作用和区别</h3><ul><li>随机数是为了提供消息的新鲜性<ul><li>可以用于挑战应答，只使用一次，防止重放攻击。</li></ul></li><li>时戳依赖于时钟的同步。</li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="PGP"><a href="#PGP" class="headerlink" title="PGP"></a>PGP</h3><ul><li>发送方<ul><li>签名消息<ul><li>使用用户ID作为索引获取发送者的私钥</li><li>提示用户输入口令解密私钥</li><li>创建签名</li></ul></li><li>加密消息<ul><li>生成会话密钥，加密消息。</li><li>使用用户ID作为索引获取接收方公钥</li><li>创建会话消息</li></ul></li></ul></li><li>接收方<ul><li>解密消息<ul><li>使用消息内ID字段作为索引获取私钥</li><li>提示用户输入密钥解密私钥</li><li>恢复会话密钥，解密消息。</li></ul></li><li>认证消息<ul><li>使用签名密钥ID作为索引获取公钥</li><li>恢复消息摘要</li><li>计算消息摘要并和传输版本比较认证</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;复习所学知识，应付考试orz。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Internet安全协议与分析" scheme="https://entropy2333.github.io/categories/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>Internet安全协议与分析（零）安全协议基础</title>
    <link href="https://entropy2333.github.io/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/"/>
    <id>https://entropy2333.github.io/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/</id>
    <published>2020-10-27T06:31:21.000Z</published>
    <updated>2020-10-27T07:54:50.530Z</updated>
    
    <content type="html"><![CDATA[<p>介绍密码学的基础知识，包括公钥体制、数字签名、密钥分配等。</p><a id="more"></a><h2 id="信息安全"><a href="#信息安全" class="headerlink" title="信息安全"></a>信息安全</h2><h3 id="信息安全的范围"><a href="#信息安全的范围" class="headerlink" title="信息安全的范围"></a>信息安全的范围</h3><ul><li>物理安全</li><li>计算机安全</li><li>网络安全</li></ul><h3 id="信息安全的目标"><a href="#信息安全的目标" class="headerlink" title="信息安全的目标"></a>信息安全的目标</h3><ul><li>保密性</li><li>完整性</li><li>可用性</li></ul><h3 id="计算机网络面临的安全性威胁"><a href="#计算机网络面临的安全性威胁" class="headerlink" title="计算机网络面临的安全性威胁"></a>计算机网络面临的安全性威胁</h3><p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027143622649.png" alt="image-20201027143622649"></p><h2 id="密码学回顾"><a href="#密码学回顾" class="headerlink" title="密码学回顾"></a>密码学回顾</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>明文、密文、加密（算法）、解密（算法）</p><p>加密系统可以用五元组描述（P, C, K, E, D）</p><ul><li>P表示明文空间</li><li>C表示密文空间</li><li>K表示密钥空间</li><li>E表示加密算法</li><li>D表示解密算法</li></ul><p>数据加密系统可以用下图表示</p><p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027143901553.png" alt="image-20201027143901553"></p><h3 id="密码体制"><a href="#密码体制" class="headerlink" title="密码体制"></a>密码体制</h3><h4 id="对称密钥"><a href="#对称密钥" class="headerlink" title="对称密钥"></a>对称密钥</h4><ul><li>加密密钥和解密密钥相同</li><li>DES是一种分组密码<ul><li>加密前对明文分组，组长64位。</li><li>密钥为64位（8位用于奇偶校验）</li></ul></li></ul><h4 id="公钥体制"><a href="#公钥体制" class="headerlink" title="公钥体制"></a>公钥体制</h4><ul><li><p>使用不同的加密密钥和解密密钥</p></li><li><p>可以解决密钥分配问题，也用于数字签名。</p></li><li><p>公钥不能用于解密</p><script type="math/tex; mode=display">D_{PK_B}(E_{PK_B}(X))\neq X</script></li><li><p>加密和解密可以对调</p><script type="math/tex; mode=display">D_{PK_B}(E_{SK_B}(X)) = D_{SK_B}(E_{PK_B}(X)) = X</script></li></ul><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><ul><li>签名者事后不能否认自己的签名。</li><li>接收者可以验证签名，但其他人不能伪造签名。</li><li>双方关于签名真伪发生争执时，第三方可以解决争执。</li></ul><h4 id="鉴别"><a href="#鉴别" class="headerlink" title="鉴别"></a>鉴别</h4><ul><li>发送方用自己的私钥加密摘要，附到明文之后。</li><li>提供完整性鉴别，但不提供保密性。</li><li>为了满足保密性，需要结合加密。</li></ul><p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027144539975.png" alt="image-20201027144539975"></p><h4 id="数字信封"><a href="#数字信封" class="headerlink" title="数字信封"></a>数字信封</h4><ul><li>发送方用对称密钥加密明文，并用接收方的公钥加密对称密钥，附到密文之后。</li></ul><p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027144803675.png" alt="image-20201027144803675"></p><h4 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h4><ul><li>用户提交公钥等信息P，CA机构用私钥签名摘要产生S，P和S一起被称为数字证书。</li><li>用户可以用CA的公钥解密获取证书里的公钥，结合数字签名，验证证书的完整性。</li><li>下图的解释<ul><li>发送方首先产生摘要，用自己的私钥加密形成数字签名，附到消息之后。</li><li>因为有数字签名，所以接收方需要获得发送方的公钥，发送方需要发送自己的数字证书。</li><li>因为需要传递对称密钥，所以需要数字信封，用接收方的公钥加密对称密钥。</li><li>接收方收到消息后，首先用私钥解密获得对称密钥，随后解密获得明文。用CA公钥验证证书的完整性，由此获得发送方的公钥，用其解密数字签名，确保消息没有被篡改。</li><li>满足了保密性和完整性。</li></ul></li></ul><p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027145220754.png" alt="image-20201027145220754"></p><h2 id="基于Hash的鉴别"><a href="#基于Hash的鉴别" class="headerlink" title="基于Hash的鉴别"></a>基于Hash的鉴别</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ul><li>直接Hash</li></ul><p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027151324589.png" alt="image-20201027151324589"></p><ul><li>与加密结合</li></ul><p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027151338394.png" alt="image-20201027151338394"></p><ul><li>结合公钥体制（数字签名）</li></ul><p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027151349653.png" alt="image-20201027151349653"></p><ul><li>结合对称密钥体制</li></ul><p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027151400579.png" alt="image-20201027151400579"></p><ul><li>加盐</li></ul><p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027151416972.png" alt="image-20201027151416972"></p><ul><li>大杂烩</li></ul><p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027151432750.png" alt="image-20201027151432750"></p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>根据安全水平<ul><li>弱无碰撞</li><li>强无碰撞</li></ul></li><li>根据是否使用密钥<ul><li>带私密密钥，此时称作MAC。</li><li>不带私密密钥，此时称为MDC。</li></ul></li></ul><h2 id="密钥管理与分配"><a href="#密钥管理与分配" class="headerlink" title="密钥管理与分配"></a>密钥管理与分配</h2><h3 id="密钥生命周期"><a href="#密钥生命周期" class="headerlink" title="密钥生命周期"></a>密钥生命周期</h3><ul><li>产生、存储、使用、更新、删除</li></ul><p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027152018368.png" alt="image-20201027152018368"></p><h3 id="对称密钥的分配"><a href="#对称密钥的分配" class="headerlink" title="对称密钥的分配"></a>对称密钥的分配</h3><ul><li>设立密钥分配中心KDC。</li><li>KDC给需要进行秘密通信的用户临时分配一个会话密钥。</li><li>KDC的登记用户在KDC的服务器上安装了自己与KDC进行通信的主密钥，可简称为密钥。</li></ul><p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027152326907.png" alt="image-20201027152326907"></p><h4 id="基于公钥体制的对称密钥分配"><a href="#基于公钥体制的对称密钥分配" class="headerlink" title="基于公钥体制的对称密钥分配"></a>基于公钥体制的对称密钥分配</h4><ul><li>公钥密码体制未必在通讯中直接使用，但却很适合用于对称密钥分配。</li></ul><p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027152457757.png" alt="image-20201027152457757"></p><p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027152509596.png" alt="image-20201027152509596"></p><h3 id="公钥体制的密钥分配"><a href="#公钥体制的密钥分配" class="headerlink" title="公钥体制的密钥分配"></a>公钥体制的密钥分配</h3><h4 id="公开发布"><a href="#公开发布" class="headerlink" title="公开发布"></a>公开发布</h4><p>用户将自己的公钥发给其他用户，一般将公钥附在消息上（PGP）。</p><ul><li>实现简单</li><li>容易假冒</li></ul><h4 id="公用目录表"><a href="#公用目录表" class="headerlink" title="公用目录表"></a>公用目录表</h4><p>建立一个公用的公钥动态目录表，由可信的实体建立、维护和发布。</p><ul><li>有一定的安全性</li><li>目录表容易受到攻击</li></ul><h4 id="公钥授权"><a href="#公钥授权" class="headerlink" title="公钥授权"></a>公钥授权</h4><p>在公钥目录表的基础上，由公钥管理机构为用户建立、维护和发布公钥目录表。</p><p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027155129036.png" alt="image-20201027155129036"></p><h4 id="公钥证书"><a href="#公钥证书" class="headerlink" title="公钥证书"></a>公钥证书</h4><p>用户通过公钥证书相互交换公钥，公钥证书由CA为用户建立。</p><p>公钥证书的数据项包括</p><ul><li>用户的公钥、用户身份标识和时间戳等。</li><li>所有数据项经CA的私钥签名后形成证书。</li></ul><p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027155335650.png" alt="image-20201027155335650"></p><p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027155414152.png" alt="image-20201027155414152"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍密码学的基础知识，包括公钥体制、数字签名、密钥分配等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Internet安全协议与分析" scheme="https://entropy2333.github.io/categories/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="数字签名" scheme="https://entropy2333.github.io/tags/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/"/>
    
      <category term="数字证书" scheme="https://entropy2333.github.io/tags/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/"/>
    
      <category term="公钥体制" scheme="https://entropy2333.github.io/tags/%E5%85%AC%E9%92%A5%E4%BD%93%E5%88%B6/"/>
    
      <category term="Hash鉴别" scheme="https://entropy2333.github.io/tags/Hash%E9%89%B4%E5%88%AB/"/>
    
      <category term="密钥分配" scheme="https://entropy2333.github.io/tags/%E5%AF%86%E9%92%A5%E5%88%86%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>Internet安全协议与分析（七）CSP</title>
    <link href="https://entropy2333.github.io/2020/10/25/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%83%EF%BC%89CSP/"/>
    <id>https://entropy2333.github.io/2020/10/25/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%83%EF%BC%89CSP/</id>
    <published>2020-10-25T06:04:55.000Z</published>
    <updated>2020-10-25T06:19:23.873Z</updated>
    
    <content type="html"><![CDATA[<p>介绍攻击结构性方法。</p><a id="more"></a><h2 id="攻击结构性方法"><a href="#攻击结构性方法" class="headerlink" title="攻击结构性方法"></a>攻击结构性方法</h2><p>从反面寻找协议的漏洞，如果能找到合适的攻击步骤，则说明协议有缺陷。</p><p>如果找不到攻击，不能说明协议是安全的，但安全性可以得到一定程度的保证。</p><ul><li>主体数据的有限性：通常只分析有限个主体实例</li><li>无法解决状态空间爆炸问题</li><li>无法揭示安全协议的内部机理</li></ul><h2 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h2><p>通信顺序进程（Communicating Sequential Processes）</p><ul><li>描述并发系统的消息交互</li><li>将协议的安全问题描述为CSP进行是否满足其CSP规约的问题，并用FDR对协议的性质进行分析与验证。</li></ul><h3 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h3><ul><li><p>事件</p><ul><li>一个典型的CSP事件形式为：c.i.j.m，包括信道c、消息源i、目的地j和消息m。</li></ul></li><li><p>信道</p><ul><li>不同事件类型看成不同信道，并规定它所传递的数据类型。</li></ul></li><li><p>进程</p><ul><li>包括执行状态中的一个动作（事件）以及动作结束后的状态。</li></ul><p><img src="/2020/10/25/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%83%EF%BC%89CSP/image-20201025141246384.png" alt="image-20201025141246384"></p></li><li><p>进程间选择 P▢Q</p><ul><li>表示在两个进程事件间的外部选择</li></ul><p><img src="/2020/10/25/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%83%EF%BC%89CSP/image-20201025141612756.png" alt="image-20201025141612756"></p></li><li><p>并行进程</p><p><img src="/2020/10/25/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%83%EF%BC%89CSP/image-20201025141658434.png" alt="image-20201025141658434"></p></li><li><p>重命名</p><p><img src="/2020/10/25/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%83%EF%BC%89CSP/image-20201025141716208.png" alt="image-20201025141716208"></p></li><li><p>条件结构</p><p><img src="/2020/10/25/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%83%EF%BC%89CSP/image-20201025141742620.png" alt="image-20201025141742620"></p></li><li><p>迹与精炼</p><p><img src="/2020/10/25/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%83%EF%BC%89CSP/image-20201025141807851.png" alt="image-20201025141807851"></p></li></ul><h3 id="协议目标的CSP描述"><a href="#协议目标的CSP描述" class="headerlink" title="协议目标的CSP描述"></a>协议目标的CSP描述</h3><p>看得头大，啥也记不住</p><p>TO BE COMPLETED</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍攻击结构性方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Internet安全协议与分析" scheme="https://entropy2333.github.io/categories/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="CSP" scheme="https://entropy2333.github.io/tags/CSP/"/>
    
  </entry>
  
  <entry>
    <title>Internet安全协议与分析（六）BAN</title>
    <link href="https://entropy2333.github.io/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/"/>
    <id>https://entropy2333.github.io/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/</id>
    <published>2020-10-19T06:33:15.000Z</published>
    <updated>2020-10-25T07:07:14.742Z</updated>
    
    <content type="html"><![CDATA[<p>介绍基于推理结构性方法。</p><a id="more"></a><h2 id="安全协议的形式化分析"><a href="#安全协议的形式化分析" class="headerlink" title="安全协议的形式化分析"></a>安全协议的形式化分析</h2><ul><li>目前的技术主要用于对密钥正确的认证。</li><li>安全协议的形式化有助于减轻协议设计者的工作量<ul><li>界定安全协议的边界，即协议系统与其运行环境的界面。</li><li>更准确地描述安全协议的行为。</li><li>更准确地定义安全协议的特性。</li><li>证明安全协议满足其说明，以及证明安全协议在什么条件下不能满足其说明。</li></ul></li></ul><h3 id="逻辑—推理结构性方法简介"><a href="#逻辑—推理结构性方法简介" class="headerlink" title="逻辑—推理结构性方法简介"></a>逻辑—推理结构性方法简介</h3><ul><li>运用逻辑系统从用户接收和发送的消息出发，通过一系列的推理公理推证协议是否满足其安全说明。</li><li>典型：BAN逻辑、Kailer逻辑、RV逻辑。</li><li>特点<ul><li>简洁直观，易于使用。</li><li>理想化方法。分析协议之前对协议进行形式化处理，依赖经验。</li><li>使用假设和推理规则。<ul><li>假设不正确，不能得到正确的信念。</li><li>公理和推理规则是否合理和完备也影响性能。</li></ul></li></ul></li></ul><h2 id="BAN逻辑系统"><a href="#BAN逻辑系统" class="headerlink" title="BAN逻辑系统"></a>BAN逻辑系统</h2><ul><li>定义：基于主体知识和信念推理的模态逻辑。</li><li>过程：通过推导主体是否能够从接收到的消息中获得信念来判断协议是否能够达到认证目标。</li></ul><h3 id="常用符号"><a href="#常用符号" class="headerlink" title="常用符号"></a>常用符号</h3><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/image-20201019144255278.png" alt="image-20201019144255278"></p><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/image-20201019144302408.png" alt="image-20201019144302408"></p><h3 id="推理规则"><a href="#推理规则" class="headerlink" title="推理规则"></a>推理规则</h3><h4 id="消息意义规则"><a href="#消息意义规则" class="headerlink" title="消息意义规则"></a>消息意义规则</h4><ul><li>从加密消息所使用的密钥以及消息中包含的秘密来推断消息发送者的身份</li></ul><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/image-20201019144714766.png" alt="image-20201019144714766"></p><h4 id="随机数验证规则"><a href="#随机数验证规则" class="headerlink" title="随机数验证规则"></a>随机数验证规则</h4><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/image-20201019144948197.png" alt="image-20201019144948197"></p><h4 id="仲裁规则"><a href="#仲裁规则" class="headerlink" title="仲裁规则"></a>仲裁规则</h4><ul><li>拓展主体的推知能力，使主体可以基于已有信仰上推知新的信仰。</li></ul><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/image-20201019145140729.png" alt="image-20201019145140729"></p><h4 id="信念规则"><a href="#信念规则" class="headerlink" title="信念规则"></a>信念规则</h4><ul><li>反映信念在消息的级联与分割的不同操作中的一致性以及信仰在此类操作中的传递性。</li></ul><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/image-20201019145246885.png" alt="image-20201019145246885"></p><h4 id="接收规则"><a href="#接收规则" class="headerlink" title="接收规则"></a>接收规则</h4><ul><li>定义了主体在协议运行中获取消息</li></ul><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/image-20201019145343321.png" alt="image-20201019145343321"></p><h4 id="新鲜规则"><a href="#新鲜规则" class="headerlink" title="新鲜规则"></a>新鲜规则</h4><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/image-20201019145354518.png" alt="image-20201019145354518"></p><h4 id="传递规则"><a href="#传递规则" class="headerlink" title="传递规则"></a>传递规则</h4><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/image-20201019145402495.png" alt="image-20201019145402495"></p><h3 id="若干假设"><a href="#若干假设" class="headerlink" title="若干假设"></a>若干假设</h3><h4 id="时间假设"><a href="#时间假设" class="headerlink" title="时间假设"></a>时间假设</h4><ul><li>current-time：起始于本次协议运行的开始阶段</li><li>past-time：current-time之前的时间</li><li>如果某一观点在协议开始时是成立的，那么在整个current-time中也是成立的，但是在past-time中成立的观点在current-time中却并不一定成立。</li></ul><h4 id="密钥假设"><a href="#密钥假设" class="headerlink" title="密钥假设"></a>密钥假设</h4><ul><li>密钥不能从密文中推导出来。</li><li>不拥有正确密钥不能解密报文。</li><li>主体能够知道他是否正确地使用了解密密钥。正确的密钥解密得到的明文有意义，错误的密钥解密得到的明文没有意义。</li></ul><h4 id="主体假设"><a href="#主体假设" class="headerlink" title="主体假设"></a>主体假设</h4><ul><li>假设参与协议运行的主体都是诚实的。</li></ul><h4 id="自身消息可识别假设"><a href="#自身消息可识别假设" class="headerlink" title="自身消息可识别假设"></a>自身消息可识别假设</h4><ul><li>假设接收方能分辨接收到的消息是否为自己发送过的消息。使得消息含义规则的成立有合理性。</li></ul><h3 id="应用BAN逻辑"><a href="#应用BAN逻辑" class="headerlink" title="应用BAN逻辑"></a>应用BAN逻辑</h3><ul><li>对协议进行理想化预处理（初始化）</li><li>给出协议初始状态及其所基于的假设。</li><li>形式化说明协议将达成的安全目标。</li><li>运用公理和推理规则以及协议会话事实和假设，从协议的开始进行推证直至验证协议是否满足最终运行目标。</li></ul><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/image-20201019150350421.png" alt="image-20201019150350421"></p><h4 id="实例：NS协议漏洞"><a href="#实例：NS协议漏洞" class="headerlink" title="实例：NS协议漏洞"></a>实例：NS协议漏洞</h4><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/image-20201019150426012.png" alt="image-20201019150426012"></p><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/image-20201019150432923.png" alt="image-20201019150432923"></p><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/image-20201019150438422.png" alt="image-20201019150438422"></p><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/image-20201019150445257.png" alt="image-20201019150445257"></p><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/image-20201019150451862.png" alt="image-20201019150451862"></p><p>goodkey = skey + fresh</p><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/image-20201019150458530.png" alt="image-20201019150458530"></p><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/image-20201019150504901.png" alt="image-20201019150504901"></p><h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><ul><li>省略掉对于推知主体信仰无用部分，如明文。</li><li>协议的理想化过于依赖于分享者的直觉，使得原始协议与理想化协议间存在语义鸿沟。</li><li>协议的理想化是将协议过程语言中对协议主体行为的描述解释为用逻辑语言描述的主体的知识和信仰，并以此来表示协议说明的语义。现有的逻辑形式化分析系统很难解决此问题。</li><li>BAN证明没有问题，并不能保证该协议没有问题。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍基于推理结构性方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Internet安全协议与分析" scheme="https://entropy2333.github.io/categories/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="BAN" scheme="https://entropy2333.github.io/tags/BAN/"/>
    
  </entry>
  
</feed>
