<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>entropy2333</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://entropy2333.github.io/"/>
  <updated>2020-12-28T13:59:06.345Z</updated>
  <id>https://entropy2333.github.io/</id>
  
  <author>
    <name>entropy2333</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>现代密码学（八）信息隐藏与隐写分析</title>
    <link href="https://entropy2333.github.io/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%85%AB%EF%BC%89%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F%E4%B8%8E%E9%9A%90%E5%86%99%E5%88%86%E6%9E%90/"/>
    <id>https://entropy2333.github.io/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%85%AB%EF%BC%89%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F%E4%B8%8E%E9%9A%90%E5%86%99%E5%88%86%E6%9E%90/</id>
    <published>2020-12-27T09:09:54.000Z</published>
    <updated>2020-12-28T13:59:06.345Z</updated>
    
    <content type="html"><![CDATA[<p>介绍信息隐藏与隐写分析。</p><a id="more"></a><h2 id="信息隐藏"><a href="#信息隐藏" class="headerlink" title="信息隐藏"></a>信息隐藏</h2><p>信息隐藏可以分为</p><ul><li>空域，如LSB。</li><li>变换域，如DCT。</li></ul><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%85%AB%EF%BC%89%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F%E4%B8%8E%E9%9A%90%E5%86%99%E5%88%86%E6%9E%90/image-20201228213531671.png" alt="image-20201228213531671" style="zoom:67%;"></p><h2 id="数字水印的嵌入"><a href="#数字水印的嵌入" class="headerlink" title="数字水印的嵌入"></a>数字水印的嵌入</h2><ul><li>加法嵌入</li><li>乘法嵌入</li></ul><p>图像质量可以用峰值信噪比PSNR评价</p><h2 id="信息隐藏算法"><a href="#信息隐藏算法" class="headerlink" title="信息隐藏算法"></a>信息隐藏算法</h2><p>空域算法，通过直接修改像素值实现隐藏信息嵌入。</p><ul><li>简单、快速、容量大。</li><li>鲁棒性差。</li></ul><p>灰度256的图像有8个位平面。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%85%AB%EF%BC%89%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F%E4%B8%8E%E9%9A%90%E5%86%99%E5%88%86%E6%9E%90/image-20201228214154609.png" alt="image-20201228214154609" style="zoom:67%;"></p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%85%AB%EF%BC%89%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F%E4%B8%8E%E9%9A%90%E5%86%99%E5%88%86%E6%9E%90/image-20201228214300127.png" alt="image-20201228214300127" style="zoom:67%;"></p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%85%AB%EF%BC%89%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F%E4%B8%8E%E9%9A%90%E5%86%99%E5%88%86%E6%9E%90/image-20201228214310415.png" alt="image-20201228214310415" style="zoom:67%;"></p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%85%AB%EF%BC%89%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F%E4%B8%8E%E9%9A%90%E5%86%99%E5%88%86%E6%9E%90/image-20201228214318464.png" alt="image-20201228214318464" style="zoom:67%;"></p><h2 id="频域水印算法"><a href="#频域水印算法" class="headerlink" title="频域水印算法"></a>频域水印算法</h2><p>在频域，通过修改频域空间的系数实现水印嵌入。</p><ul><li>鲁棒性好</li><li>复杂度高</li></ul><p>JPEG只改中频系数，不会被消除掉。</p><ul><li>修改低频部分，容易看出变化，隐蔽性差。</li><li>修改高频部分，容易被图像压缩算法破坏，鲁棒性差。</li></ul><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%85%AB%EF%BC%89%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F%E4%B8%8E%E9%9A%90%E5%86%99%E5%88%86%E6%9E%90/image-20201228214606301.png" alt="image-20201228214606301" style="zoom:67%;"></p><h2 id="隐写分析"><a href="#隐写分析" class="headerlink" title="隐写分析"></a>隐写分析</h2><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%85%AB%EF%BC%89%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F%E4%B8%8E%E9%9A%90%E5%86%99%E5%88%86%E6%9E%90/image-20201228215318459.png" alt="image-20201228215318459" style="zoom:67%;"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍信息隐藏与隐写分析。&lt;/p&gt;
    
    </summary>
    
    
      <category term="现代密码学" scheme="https://entropy2333.github.io/categories/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
      <category term="信息隐藏" scheme="https://entropy2333.github.io/tags/%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F/"/>
    
      <category term="隐写分析" scheme="https://entropy2333.github.io/tags/%E9%9A%90%E5%86%99%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>现代密码学（七）数字签名算法</title>
    <link href="https://entropy2333.github.io/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%83%EF%BC%89%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E7%AE%97%E6%B3%95/"/>
    <id>https://entropy2333.github.io/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%83%EF%BC%89%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E7%AE%97%E6%B3%95/</id>
    <published>2020-12-27T09:09:31.000Z</published>
    <updated>2020-12-28T13:32:02.145Z</updated>
    
    <content type="html"><![CDATA[<p>介绍数字签名。</p><h2 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h2><script type="math/tex; mode=display">h = H(M) \\S = h^d\bmod N \\S^e = (h^e)^d = h\bmod N</script><h2 id="El-Gamal"><a href="#El-Gamal" class="headerlink" title="El Gamal"></a>El Gamal</h2><p>选择随机数k，满足<script type="math/tex">gck(k,\ p-1)=1</script>，计算密钥</p><script type="math/tex; mode=display">K = a^k\bmod p</script><p>用Euclidean扩展算法求解S</p><script type="math/tex; mode=display">M = x\cdot K + k\cdot S\bmod(p-1)</script><p>也即</p><script type="math/tex; mode=display">S = k^{-1}(M-x\cdot K)\bmod(p-1)</script><p>签名就是<script type="math/tex">(M,K,S)</script></p><script type="math/tex; mode=display">y^K\cdot K^S = (a^x)^K\cdot (a^k)^{k^{-1}(M-x\cdot K)} = a^M \bmod p</script><h2 id="DSA"><a href="#DSA" class="headerlink" title="DSA"></a>DSA</h2><p>基于离散对数，生成320bit签名。</p><h2 id="HMAC"><a href="#HMAC" class="headerlink" title="HMAC"></a>HMAC</h2><p>带密钥的HASH。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;介绍数字签名。&lt;/p&gt;
&lt;h2 id=&quot;RSA&quot;&gt;&lt;a href=&quot;#RSA&quot; class=&quot;headerlink&quot; title=&quot;RSA&quot;&gt;&lt;/a&gt;RSA&lt;/h2&gt;&lt;script type=&quot;math/tex; mode=display&quot;&gt;
h = H(M) \\
S =
      
    
    </summary>
    
    
      <category term="现代密码学" scheme="https://entropy2333.github.io/categories/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
      <category term="数字签名" scheme="https://entropy2333.github.io/tags/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>现代密码学（六）认证与哈希函数</title>
    <link href="https://entropy2333.github.io/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%85%AD%EF%BC%89%E8%AE%A4%E8%AF%81%E4%B8%8E%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/"/>
    <id>https://entropy2333.github.io/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%85%AD%EF%BC%89%E8%AE%A4%E8%AF%81%E4%B8%8E%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/</id>
    <published>2020-12-27T09:09:11.000Z</published>
    <updated>2020-12-28T13:17:49.640Z</updated>
    
    <content type="html"><![CDATA[<p>介绍认证方法与哈希函数。</p><a id="more"></a><h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><p>认证是为了防止主动攻击。</p><ul><li>实体认证（确认发送者的身份）</li><li>消息认证（验证消息的完整性）</li></ul><p>保密和认证是两个概念，纯认证的系统模型如下。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%85%AD%EF%BC%89%E8%AE%A4%E8%AF%81%E4%B8%8E%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/image-20201228193828037.png" alt="image-20201228193828037" style="zoom:67%;"></p><p>有三种方式产生认证符</p><ul><li>消息加密</li><li>消息认证码MAC<ul><li>需要密钥</li></ul></li><li>哈希函数</li></ul><p>基于公钥体制，可以实现加密与认证。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%85%AD%EF%BC%89%E8%AE%A4%E8%AF%81%E4%B8%8E%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/image-20201228195806099.png" alt="image-20201228195806099" style="zoom:67%;"></p><h2 id="消息认证码-MAC"><a href="#消息认证码-MAC" class="headerlink" title="消息认证码 MAC"></a>消息认证码 MAC</h2><p>MAC对给定消息，使用一个密钥，产生一个短小的定长数据分组。</p><p>可以提供认证，因为只有通信双方共享密钥。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%85%AD%EF%BC%89%E8%AE%A4%E8%AF%81%E4%B8%8E%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/image-20201228200208994.png" alt="image-20201228200208994" style="zoom: 67%;"></p><p>也可以实现认证与保密。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%85%AD%EF%BC%89%E8%AE%A4%E8%AF%81%E4%B8%8E%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/image-20201228200259938.png" alt="image-20201228200259938" style="zoom:67%;"></p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%85%AD%EF%BC%89%E8%AE%A4%E8%AF%81%E4%B8%8E%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/image-20201228202104394.png" alt="image-20201228202104394" style="zoom:67%;"></p><p>消息认证相较于常规加密</p><ul><li>适用于消息广播</li><li>认证的代价低</li><li>某些应用只关心消息的真实性</li><li>认证与保密的分离能提供结构上的灵活性</li><li>认证码可以延长消息的保护期限，同时能处理消息内容</li></ul><p>认证函数应抗选择明文攻击，且生成同样的认证码在计算上不可行。</p><p>可以基于DES实现MAC</p><ul><li>将消息分为连续的64bit分组</li></ul><script type="math/tex; mode=display">\begin{align}C_1 &= E_K(M_1) \\C_2 &= E_K(M_2\oplus C_1) \\&\dots \\C_n &= E_K(M_n\oplus C_{n-1})\end{align}</script><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>哈希函数将任意长度的消息映射为较短的定长消息。</p><ul><li><script type="math/tex; mode=display">E_K(M||H(M))</script><ul><li>提供保密与鉴别</li></ul></li><li><script type="math/tex; mode=display">M||E_K(H(M))</script><ul><li>提供鉴别</li></ul></li><li><script type="math/tex; mode=display">M||E_{K_{R_a}}(H(M))</script><ul><li>提供鉴别与数字签名</li></ul></li></ul><p>简单的哈希函数，对每个分组按bit异或（奇偶校验）。</p><script type="math/tex; mode=display">C_i = b_{i1}\oplus b_{i2}\oplus\cdots\oplus b_{im}</script><h3 id="Merkle-Damgard结构"><a href="#Merkle-Damgard结构" class="headerlink" title="Merkle-Damgard结构"></a>Merkle-Damgard结构</h3><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%85%AD%EF%BC%89%E8%AE%A4%E8%AF%81%E4%B8%8E%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/image-20201228204306226.png" alt="image-20201228204306226" style="zoom:67%;"></p><script type="math/tex; mode=display">CV_i = f(CV_{i-1}, Y_{i-1}) \\H(M) = CV_L</script><h2 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h2><p>符合Merkle-Damgard结构，输入分组长度512bit，输出128bit。</p><ul><li>添加填充位，满足<script type="math/tex">length\equiv448\bmod512</script>。</li><li>添加长度，用64bit表示，若超过只取低64位。</li><li>使用一个128bit缓存存放结果，表示为<script type="math/tex">(A,B,C,D)</script>。</li><li>处理512bit的报文分组，核心是包含4个循环的压缩函数f，每个循环包括16步。</li><li>所有L个51bit的分组处理后，第L个阶段的输出作为128bit摘要输出。</li></ul><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%85%AD%EF%BC%89%E8%AE%A4%E8%AF%81%E4%B8%8E%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/image-20201228205401841.png" alt="image-20201228205401841" style="zoom:67%;"></p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%85%AD%EF%BC%89%E8%AE%A4%E8%AF%81%E4%B8%8E%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/image-20201228205300355.png" alt="image-20201228205336335" style="zoom:67%;"></p><p>MD4有3轮，每轮16步。</p><p>MD5每轮加上前一步的结果，有雪崩效应。</p><h2 id="SHA-1"><a href="#SHA-1" class="headerlink" title="SHA-1"></a>SHA-1</h2><p>输入最大长度为<script type="math/tex">2^{64}</script>，输出160bit，分组大小512bit。</p><p>SHA-1的函数有四轮，每轮20步。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%85%AD%EF%BC%89%E8%AE%A4%E8%AF%81%E4%B8%8E%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/image-20201228210321190.png" alt="image-20201228210321190" style="zoom:67%;"></p><h2 id="安全性分析"><a href="#安全性分析" class="headerlink" title="安全性分析"></a>安全性分析</h2><ul><li>SHA = MD4 + 扩展变换 + 外加一轮 + 更好的雪崩</li><li>MD5 = MD4 + 改进的比特杂凑 + 外加一轮 + 更好的雪崩</li></ul><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%85%AD%EF%BC%89%E8%AE%A4%E8%AF%81%E4%B8%8E%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/image-20201228210617475.png" alt="image-20201228210617475" style="zoom:67%;"></p><p>哈希函数可以受到野蛮攻击和生日攻击</p><p>k个人中，至少存在两人生日相同的概率为</p><script type="math/tex; mode=display">P(365, k) = 1 - \frac {365!} {(365-k)365^k}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍认证方法与哈希函数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="现代密码学" scheme="https://entropy2333.github.io/categories/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
      <category term="MD5" scheme="https://entropy2333.github.io/tags/MD5/"/>
    
      <category term="MAC" scheme="https://entropy2333.github.io/tags/MAC/"/>
    
      <category term="SHA-1" scheme="https://entropy2333.github.io/tags/SHA-1/"/>
    
  </entry>
  
  <entry>
    <title>现代密码学（五）公钥密码</title>
    <link href="https://entropy2333.github.io/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%BA%94%EF%BC%89%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81/"/>
    <id>https://entropy2333.github.io/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%BA%94%EF%BC%89%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81/</id>
    <published>2020-12-27T09:08:56.000Z</published>
    <updated>2020-12-28T11:31:10.068Z</updated>
    
    <content type="html"><![CDATA[<p>介绍公钥密码学。</p><a id="more"></a><h2 id="公钥密码理论"><a href="#公钥密码理论" class="headerlink" title="公钥密码理论"></a>公钥密码理论</h2><p>公钥算法主要有三类</p><ul><li>密钥分配</li><li>公钥加密</li><li>签名算法</li></ul><h2 id="DH密钥交换"><a href="#DH密钥交换" class="headerlink" title="DH密钥交换"></a>DH密钥交换</h2><ul><li>选定素数p和本原元a</li><li>A选定<script type="math/tex">x_A</script>，计算<script type="math/tex">y_A=a^{x_A}\bmod p</script></li><li>B选定<script type="math/tex">x_B</script>，计算<script type="math/tex">y_B=a^{x_B}\bmod p</script></li><li>公开<script type="math/tex">y_A</script>和<script type="math/tex">y_B</script></li><li>A计算<script type="math/tex">K=y_B^{x_A}\bmod p</script></li><li>B计算<script type="math/tex">K=y_A^{x_B}\bmod p</script></li></ul><h2 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h2><p>算法流程</p><ul><li>选择两个大素数p和q</li><li>计算<script type="math/tex">N=p·q</script></li><li>随机选择加密密钥e，满足<script type="math/tex">gcd(e, \phi(N)) = 1,\ e < N</script></li><li>求解解密密钥d，满足<script type="math/tex">e·d\equiv1\bmod \phi(N)</script></li><li>公开<script type="math/tex">(N, e)</script>，保存<script type="math/tex">(p,q,d)</script></li></ul><p>原理如下</p><script type="math/tex; mode=display">C = M^e\bmod N \\D = C^d= (M^e)^d\bmod N \\D = M^{(1+k\phi(N))}= M\bmod N</script><p>RSA实际上是一种单表代换</p><script type="math/tex; mode=display">RSA: \mathbb{Z/nZ} \rightarrow \mathbb{Z/nZ},\ n=pq</script><p>RSA的安全性取决于计算<script type="math/tex">\phi(N)</script>的困难性，但分解模未必是攻击RSA的最佳方法。</p><p>RSA需要计算大指数模幂，可以用中国剩余定理CRT来加速。</p><script type="math/tex; mode=display">M_1 = M\bmod p = (C\bmod p)^{d\bmod(p-1)} \\M_2 = M\bmod q = (C\bmod q)^{d\bmod(q-1)}</script><p>对于方程组</p><script type="math/tex; mode=display">\begin{cases}M = M_1\bmod p \\M = M_2\bmod q\end{cases}</script><p>有唯一解</p><script type="math/tex; mode=display">M = (q·u·M_1 + p·u'·M_2)\bmod N \\p·u\equiv1\bmod q,\ q·u'\equiv1\bmod p</script><h2 id="Rabin公钥密码体制"><a href="#Rabin公钥密码体制" class="headerlink" title="Rabin公钥密码体制"></a>Rabin公钥密码体制</h2><p>有两个困难数学问题</p><ul><li>二次剩余问题：给定奇合数n和整数a，难以判断a是n的二次剩余。</li><li>模n的平方根问题：在n的分解未知情况下，难以求解n的平方根。</li></ul><p>Rabin体制利用求解平方根的困难性构造了一种安全公钥体制。</p><p>首先选定两个形如4k+3的素数p和q，以n=pq作为公钥。</p><p>加密过程</p><script type="math/tex; mode=display">C = M^2 \bmod n,\ 0 \leq M < n</script><p>解密首先计算</p><script type="math/tex; mode=display">\begin{align}M_1 &= C^{\frac{(p+1)}{4}} \bmod p \\M_2 &= p - C^{\frac{(p+1)}{4}} \bmod p \\M_3 &= C^{\frac{(q+1)}{4}} \bmod q \\M_4 &= q - C^{\frac{(p+1)}{4}} \bmod q\end{align}</script><p>利用中国剩余定理，可以得到四个解，必有一个与M相同。</p><p>Rabin体制的安全性等价于大整数分解，但是对选择密文攻击不安全。</p><script type="math/tex; mode=display">x_1^2\equiv x_2^2\equiv0\bmod n \\\iff (x_1-x_2)(x_1+x_2)\equiv0\bmod n</script><p>与RSA相比，Rabin只需要一次乘法运算，但解密时更困难。</p><h2 id="El-Gamal"><a href="#El-Gamal" class="headerlink" title="El Gamal"></a>El Gamal</h2><p>基于离散对数，但增加了消息长度（2倍）。</p><p>首先选定大素数p和本原元g，计算</p><script type="math/tex; mode=display">y_B = g^{x_B}\bmod p</script><p>发送者选择随机数k，计算消息密钥</p><script type="math/tex; mode=display">K = y_B^k\bmod p,\ 0\leq k\leq p-1</script><p>之后计算密文对</p><script type="math/tex; mode=display">\begin{align}C_1 &= g^k\bmod p \\C_2 &= M\cdot K\bmod p\end{align}</script><p>解密时先计算密钥再计算明文</p><script type="math/tex; mode=display">\begin{align}K &= C_1^{x_B}\bmod p = (g^k)^{x_B}\bmod p \\M &= C_2\cdot K^{-1}\bmod p\end{align}</script><h2 id="对于公钥密码的攻击"><a href="#对于公钥密码的攻击" class="headerlink" title="对于公钥密码的攻击"></a>对于公钥密码的攻击</h2><p>可以对RSA发动弱参数攻击</p><ul><li>共模攻击</li><li>低加密指数攻击</li></ul><p>可以对Rabin发动选择密文攻击</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍公钥密码学。&lt;/p&gt;
    
    </summary>
    
    
      <category term="现代密码学" scheme="https://entropy2333.github.io/categories/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
      <category term="RSA" scheme="https://entropy2333.github.io/tags/RSA/"/>
    
      <category term="Rabin" scheme="https://entropy2333.github.io/tags/Rabin/"/>
    
      <category term="El Gamal" scheme="https://entropy2333.github.io/tags/El-Gamal/"/>
    
  </entry>
  
  <entry>
    <title>现代密码学（四）序列密码</title>
    <link href="https://entropy2333.github.io/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%9B%9B%EF%BC%89%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81/"/>
    <id>https://entropy2333.github.io/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%9B%9B%EF%BC%89%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81/</id>
    <published>2020-12-27T09:08:45.000Z</published>
    <updated>2020-12-28T09:25:41.429Z</updated>
    
    <content type="html"><![CDATA[<p>介绍序列密码（流密码）。</p><a id="more"></a><h2 id="流密码"><a href="#流密码" class="headerlink" title="流密码"></a>流密码</h2><p>流密码的简单结构如下。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%9B%9B%EF%BC%89%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81/image-20201228165456897.png" alt="image-20201228165456897" style="zoom:67%;"></p><p>对于流密码来说，需要生成一个作为密钥流的“随机”比特序列。</p><p>流密码的安全性取决于密钥的安全等级。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%9B%9B%EF%BC%89%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81/image-20201228165551857.png" alt="image-20201228165551857" style="zoom:67%;"></p><p>流密码可以分为两种</p><ul><li>同步流密码<ul><li>密钥流的产生与明文消息相互独立</li></ul></li><li>自同步流密码<ul><li>密钥流的产生与之间产生的若干密文有关</li></ul></li></ul><h2 id="线性反馈移位寄存器-LFSR"><a href="#线性反馈移位寄存器-LFSR" class="headerlink" title="线性反馈移位寄存器 LFSR"></a>线性反馈移位寄存器 LFSR</h2><p>LFSR可以产生同步密钥流。</p><script type="math/tex; mode=display">a_i(t+1) = a_{i+1}(t),\ i=1,2,\dots,n-1 \\a_n(t+1) = c_na_1(t) \oplus c_{n-1}a_2(t) \oplus\dots\oplus c_1a_n(t)</script><p>联结多项式为</p><script type="math/tex; mode=display">c_nx^n + c_{n-1}x^{n-1} +\dots+ c_1x+1</script><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%9B%9B%EF%BC%89%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81/image-20201228170207505.png" alt="image-20201228170207505" style="zoom:67%;"></p><p>例如对于联接多项式<script type="math/tex">x^3+x^2+1</script>，对应的反馈函数为</p><script type="math/tex; mode=display">a_3 = a_1 \oplus a_2</script><p>对于LFSR来说，一个n级LFSR序列的周期最大为<script type="math/tex">2^n-1</script>。</p><p>如果产生了最大周期，则称为m序列，LFSR的状态转移图只有两个圈。</p><h2 id="伪随机序列"><a href="#伪随机序列" class="headerlink" title="伪随机序列"></a>伪随机序列</h2><h3 id="Golomb随机性假设"><a href="#Golomb随机性假设" class="headerlink" title="Golomb随机性假设"></a>Golomb随机性假设</h3><ul><li>在每一周期内，0和1的个数近似相等。</li><li>在每一周期内，长度为i的游程占游程总数的<script type="math/tex">\frac{1}{2^i}</script>。</li><li>定义自相关函数<script type="math/tex">C(\tau)=\sum_{i=1}^n(-1)^{a_i+a_{i+\tau}}</script>。<ul><li>那么<script type="math/tex">C(\tau)=\begin{cases}n,\quad\tau\equiv0\mod n\\c,\quad others\end{cases}</script></li></ul></li></ul><h3 id="m序列的伪随机性"><a href="#m序列的伪随机性" class="headerlink" title="m序列的伪随机性"></a>m序列的伪随机性</h3><h3 id="线性复杂度"><a href="#线性复杂度" class="headerlink" title="线性复杂度"></a>线性复杂度</h3><p>能够输出该序列的最短LFSR的级数。</p><p>一个好的流密码，应该具有大周期、大的线性复杂度，同时满足Golomb随机性假设。</p><h2 id="基于LFSR的伪随机序列生成器"><a href="#基于LFSR的伪随机序列生成器" class="headerlink" title="基于LFSR的伪随机序列生成器"></a>基于LFSR的伪随机序列生成器</h2><h3 id="滤波生成器"><a href="#滤波生成器" class="headerlink" title="滤波生成器"></a>滤波生成器</h3><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%9B%9B%EF%BC%89%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81/image-20201228171735794.png" alt="image-20201228171735794" style="zoom:67%;"></p><h3 id="组合生成器"><a href="#组合生成器" class="headerlink" title="组合生成器"></a>组合生成器</h3><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%9B%9B%EF%BC%89%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81/image-20201228171742568.png" alt="image-20201228171742568" style="zoom:67%;"></p><h3 id="钟控生成器"><a href="#钟控生成器" class="headerlink" title="钟控生成器"></a>钟控生成器</h3><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%9B%9B%EF%BC%89%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81/image-20201228171755691.png" alt="image-20201228171755691" style="zoom:67%;"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍序列密码（流密码）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="现代密码学" scheme="https://entropy2333.github.io/categories/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
      <category term="流密码" scheme="https://entropy2333.github.io/tags/%E6%B5%81%E5%AF%86%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>现代密码学（三）分组密码</title>
    <link href="https://entropy2333.github.io/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/"/>
    <id>https://entropy2333.github.io/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/</id>
    <published>2020-12-27T09:08:30.000Z</published>
    <updated>2020-12-28T08:49:21.798Z</updated>
    
    <content type="html"><![CDATA[<p>介绍分组密码，包括Feistel Cipher、DES和IDEA等。</p><a id="more"></a><h2 id="分组密码"><a href="#分组密码" class="headerlink" title="分组密码"></a>分组密码</h2><p>分组密码（Block Cipher），是指将明文分成许多块，利用加密算法对每一块进行加密，形式如下。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201227181933426.png" alt="image-20201227181933426" style="zoom:67%;"></p><p>分组密码希望使用对每一块使用尽可能大的替换模块，但并不现实。</p><p>当分组长度为64bit时，即需要<script type="math/tex">2^{64}</script>个实体的替换表，因此使用乘积密码的思想，用一些小的模块替代。</p><h2 id="替换-置换密码"><a href="#替换-置换密码" class="headerlink" title="替换-置换密码"></a>替换-置换密码</h2><p>Shannon在那篇著名的文章中，介绍了替换-置换（S-P）网络的概念。</p><ul><li>替换 Substitution</li><li>置换 Permutation</li></ul><p>其实和古典密码的思想类似，替换运算用另一个二进制字代替原来的字。</p><p>替换函数就构成密钥，可以看成一个大的查表运算，替换函数也被称为S-box。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201227182545313.png" alt="image-20201227182545313" style="zoom:67%;"></p><p>置换运算则打乱一个二进制字的次序，重新排列的方法构成密钥，称为P-box。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201227182648209.png" alt="image-20201227182648209" style="zoom: 67%;"></p><p>S-P网络就是将这两种运算组合在一起，称为混合变换。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201227182900185.png" alt="image-20201227182900185" style="zoom:67%;"></p><h2 id="Feistel-Cipher"><a href="#Feistel-Cipher" class="headerlink" title="Feistel Cipher"></a>Feistel Cipher</h2><p>Feitel密码将输入块分为左右两部分L(i-1)和R(i-1)，在密码变换的第i轮只使用R(i-1)。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201227183335455.png" alt="image-20201227183335455" style="zoom:67%;"></p><p>变换过程可以表示为</p><script type="math/tex; mode=display">\begin{align}L(i) &= R(i-1) \\R(i) &= L(i-1) \oplus g(K(i), R(i-1))\end{align}</script><p>S盒提供输入bits混合作用（confusion）。</p><ul><li>使密钥和密文之间关系复杂化</li><li>极小化统计特性，使统计分析攻击不能奏效。</li></ul><p>P盒提供扩散作用（diffusion）</p><ul><li>将明文和密钥的影响尽可能散步到较多个输出的密文中（将明文冗余度分散到密文中）。</li></ul><h3 id="雪崩效应"><a href="#雪崩效应" class="headerlink" title="雪崩效应"></a>雪崩效应</h3><ul><li>输入改变1bit，导致近半的bit发生变化。</li><li>对于一个函数<script type="math/tex">f</script>来说，较好的雪崩特性是指<ul><li>对于<script type="math/tex">2^m</script>个明文向量，分为<script type="math/tex">2^{m-1}</script>个向量对<script type="math/tex">(x_i, x_i')</script>，每对向量只有一个bit不同。</li><li>定义<script type="math/tex">v_i = f(x) \oplus f(x_i)</script>，则近半的<script type="math/tex">v_i</script>为1。</li></ul></li></ul><h3 id="完备性效应"><a href="#完备性效应" class="headerlink" title="完备性效应"></a>完备性效应</h3><ul><li>每个输出比特是所有输入比特的复杂函数的输出。</li><li>对于一个函数<script type="math/tex">f</script>来说，较好的完备性是指<ul><li>对密文输出向量的每一个比特j，至少存在一个明文对<script type="math/tex">(x_i, x_i')</script>。</li><li>此明文对只在第i比特不同，且<script type="math/tex">f(x_i)</script>与<script type="math/tex">f(x_i')</script>的第j比特不同。</li></ul></li></ul><h3 id="Feistel-Cipher设计"><a href="#Feistel-Cipher设计" class="headerlink" title="Feistel Cipher设计"></a>Feistel Cipher设计</h3><p>雪崩特性保证了小的输入变化会导致大的输出变化，完备性保证了每个输出比特依赖于所有的输入比特。</p><p>设计密码时需要以下参数</p><ul><li>分组大小</li><li>密钥大小</li><li>轮数</li><li>子密钥生成</li><li>轮函数</li></ul><p>设计一个快速/安全的算法是困难的。</p><h2 id="Lucifer"><a href="#Lucifer" class="headerlink" title="Lucifer"></a>Lucifer</h2><p>第一个可用的替换-置换密码。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201227190818450.png" alt="image-20201227190818450" style="zoom:67%;"></p><p>分组长度128bit，密钥长度128bit，每一轮的子密钥是密钥的左半部分。</p><p>密钥每次向左旋转56bit，密钥的每部分都参与运算。</p><script type="math/tex; mode=display">\begin{align}L_i &= R_{i-1} \\R_i &= L_{i-1} \oplus P(K_{i-1}\oplus S(K_{i-1})) \\K_i &= ROL(K_{i-1})\end{align}</script><p>Lucifer共有16轮数据计算，使用8对4bitS盒实现替换，用几个8-bit置换组成64bit的简单置换。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201227191928132.png" alt="image-20201227191928132" style="zoom:67%;"></p><h2 id="S-DES"><a href="#S-DES" class="headerlink" title="S-DES"></a>S-DES</h2><p>S-DES即Simplified DES，供教学使用，有着和DES相似的特性和结构，但参数小。</p><p>S-DES主要有以下几个函数</p><ul><li>初始置换IP（initial permutation）</li><li>复合函数<script type="math/tex">f_k</script><ul><li>由密钥K确定，具有转换和替换的运算。</li></ul></li><li>转换函数SW</li></ul><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201227193325791.png" alt="image-20201227193325791" style="zoom:67%;"></p><p>加密算法可以表示为</p><script type="math/tex; mode=display">cipher = IP^{-1}(f_{k2}(SW(f_{k1}(IP(plain)))))</script><p>其中</p><script type="math/tex; mode=display">K_1 = P_8(移位(P_{10}(K))) \\K_2 = P_8(移位(移位(P_{10}(K))）)</script><p>密钥生成可以用下图表示，LS代表循环左移</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201227193303826.png" alt="image-20201227193303826" style="zoom:67%;"></p><p>初始置换</p><script type="math/tex; mode=display">IP = \begin{pmatrix} 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 \\ 2 & 6 & 3 & 1 & 4 & 8 & 5 & 7 \end{pmatrix}</script><script type="math/tex; mode=display">IP^{-1} = \begin{pmatrix} 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 \\ 4 & 1 & 3 & 5 & 7 & 2 & 8 & 6 \end{pmatrix}</script><p>S-DES的加密过程如下</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201227195605766.png" style="zoom:67%;"></p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201227195620844.png" style="zoom:67%;"></p><p>对于S-DES，<script type="math/tex">f_k</script>是加密方案中最重要的部分</p><script type="math/tex; mode=display">f_k(L, R) = (L\oplus F(R, SK), R)</script><p>其中对于映射F，输入为4bit，第一步进行扩张/置换（E/P）运算</p><script type="math/tex; mode=display">(n_1, n_2, n_3, n_4) \xrightarrow{E/P} \begin{pmatrix} n_4 & n_1 & n_2 & n_3 \\ n_2 & n_3 & n_4 & n_1 \end{pmatrix}</script><p>之后将密钥与E/P的结果作异或</p><script type="math/tex; mode=display">\begin{pmatrix} n_4+k_{11} & n_1+k_{12} & n_2+k_{13} & n_3+k_{14} \\ n_2+k_{15} & n_3+j_{16} & n_4+k_{17} & n_1+k_{18} \end{pmatrix} = \begin{pmatrix} P_{0,0} & P_{0,1} & P_{0,2} & P_{0,3} \\ P_{1,0} & P_{1,1} & P_{1,2} & P_{1,3} \end{pmatrix}</script><p>将第一行和第二行分别输入两个S盒，得到两个2bit的输出。</p><p>S盒接收4bit输入，将第1和第4比特组成的数作为行，第2和第3比特组成的数作为列。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201227201918812.png" alt="image-20201227201918812" style="zoom:67%;"></p><h3 id="安全分析"><a href="#安全分析" class="headerlink" title="安全分析"></a>安全分析</h3><p>对10bit密钥的强行攻击是可行的，可以利用已知明文攻击。</p><p>密钥空间：<script type="math/tex">2^{10}=1024</script></p><p>已知明文<script type="math/tex">(p_1, p_2,\dots,p_8)</script>和密文<script type="math/tex">(c_1, c_2,\dots,c_8)</script>，密钥<script type="math/tex">(k_1, k_2,\dots,k_{10})</script>作为未知数。</p><p>S-DES可以表示为8个含10个变量的非线性方程，非线性是S盒作用的结果。</p><h2 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h2><p>分组长度64bit，密文64bit。密钥为64bit，只有56bit参与运算，8bit作为奇偶校验位。</p><p>算法有以下三个阶段</p><ul><li>对明文X，通过初始置换IP得到<script type="math/tex">X_0 = IP(X) = L_0R_0</script></li><li>函数F进行16次迭代<ul><li><script type="math/tex; mode=display">L_i = R_{i-1}, R_i = L_{i-1} \oplus F(R_{i-1}, K_i)\quad 1\leq i\leq 16</script></li><li><script type="math/tex">K_i</script>是长为48位的子密钥。</li></ul></li><li>对比特串使用逆置换得到密文<script type="math/tex">Y=IP^{-1}(R_{16}L_{16})</script></li></ul><p>每一轮的结构可以用下图表示</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201227204624671.png" alt="image-20201227204624671" style="zoom:67%;"></p><p>相比于S-DES，DES的F函数更加复杂。</p><ul><li>F的输入为32bit的消息和48bit的密钥，输出为32bit。</li><li>第一步利用扩展函数，将消息扩展为48bit。</li><li>随后计算消息与密钥的异或，将48bit写成8个6bit数。</li><li>用8个S盒接收6bit数的输入，输出8个4bit数。每个S盒是4×16的矩阵，b1b6确定行号，b3b4b5b6确定列号。</li><li>最后经过一个置换函数得到结果。</li></ul><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201227204728767.png" alt="image-20201227204728767" style="zoom:67%;"></p><p>子密钥的生成如下图所示</p><ul><li>PC-1和PC-2都是固定置换，<script type="math/tex">LS_i</script>表示循环左移。</li><li>注意<script type="math/tex">K_i</script>为48bit。</li></ul><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201227205558988.png" alt="image-20201227205558988" style="zoom:67%;"></p><h3 id="DES的改进"><a href="#DES的改进" class="headerlink" title="DES的改进"></a>DES的改进</h3><p>双重DES</p><script type="math/tex; mode=display">C = E_{K_2}[E_{K_1}[P]] \\ P = D_{K_1}[D_{K_2}[C]]</script><p>三重DES</p><script type="math/tex; mode=display">C = E_{K_1}[D_{K_2}[E_{K_1}[P]]] \\ P = D_{K_1}[E_{K_2}[D_{K_1}[C]]]</script><p>三种DES的密钥长度为<script type="math/tex">2^{112}</script>，而标准DES的密钥长度为<script type="math/tex">2^{56}</script>。</p><h2 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h2><p>分组长度64bit，密钥长度128bit，进行8轮迭代操作。</p><p>IDEA中，定义了三种运算。</p><ul><li>逐位异或</li><li>整数模<script type="math/tex">2^{16}</script>加<script type="math/tex">\boxplus</script></li><li>整数模<script type="math/tex">2^{16}</script>乘<script type="math/tex">\boxdot</script>（IDEA的S盒）</li></ul><p>IDEA的扩散来自于MA结构，它接收两个16bit的明文消息和两个子密钥作为输入，产生两个16bit的输出。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201228100105211.png" alt="image-20201228100105211"></p><p>IDEA一共产生52个16bit的子密钥，每一轮使用6个子密钥，另外还需要4个额外子密钥。</p><p>前8个子密钥直接从密钥中取出，之后的密钥由25bit的循环左移产生。</p><ul><li>IDEA是PGP的一部分。</li><li>IDEA能抗差分分析和相关分析。</li><li>IDEA似乎没有DES意义下的弱密钥。</li></ul><h2 id="AES-Rijndael"><a href="#AES-Rijndael" class="headerlink" title="AES-Rijndael"></a>AES-Rijndael</h2><ul><li><p>分组长度128bit，密钥长度为128、192或256bit，相应的迭代轮数为10、12和14。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201228160159238.png" alt="image-20201228160159238" style="zoom:67%;"></p></li><li><p>AES的轮函数由四个变换构成，最后一轮省略了列混合。</p><ul><li><p>字节替换</p><ul><li>替换表是一个16×16的矩阵（S盒）。</li><li>输入8bit，高4位作为行，低4位作为列，输出8bit。</li></ul></li><li><p>行移位</p><ul><li>字节的循环移位运算。</li></ul><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201228160612036.png" alt="image-20201228160612036" style="zoom:67%;"></p></li><li><p>列混合</p><ul><li>在<script type="math/tex">GF(2^8)</script>上乘以固定多项式<script type="math/tex">a(x)</script>并模除<script type="math/tex">(x^4+1)</script></li><li><script type="math/tex; mode=display">S'(x)=a(x)\otimes S(x),\ a(x)=3x^3+x^2+x+2</script></li></ul></li><li><p>轮密钥加</p><ul><li>与每轮的子密钥进行异或操作，子密钥长度等于分组长度。</li></ul><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201228160836700.png" alt="image-20201228160836700" style="zoom:67%;"></p></li></ul><p>四种变换可以用下图表示</p></li></ul><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201228160043732.png" alt="image-20201228160043732" style="zoom:67%;"></p><p>AES的子密钥长度为128bit，也即16个字节，子密钥的生成过程如下。</p><ul><li>首先将16个字节分为4组，每组4个字节。</li><li>循环移位后，经过S盒实现替换处理。</li><li>第一个字节与轮常数异或。</li><li>将得到的字节与原先的字节按位异或，即为下一轮的密钥。</li></ul><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201228161702983.png" alt="image-20201228161702983" style="zoom:67%;"></p><h2 id="分组密码的工作模式"><a href="#分组密码的工作模式" class="headerlink" title="分组密码的工作模式"></a>分组密码的工作模式</h2><p>DES定义了4种工作模式。</p><ul><li>Block Mode<ul><li>ECB</li><li>CBC</li></ul></li><li>Stream Mode<ul><li>CFB</li><li>OFB</li></ul></li></ul><h3 id="ECB-Electronic-Codebook-Book"><a href="#ECB-Electronic-Codebook-Book" class="headerlink" title="ECB - Electronic Codebook Book"></a>ECB - Electronic Codebook Book</h3><p>将消息分为独立的加密模块，分组长度为64bit，每块单独使用DES。</p><p>适合少量的数据加密，但是对于相同的明文来说，产生的密文也相同（不安全）。</p><p>如果需要安全传递DES密钥，ECB是最合适的模式。</p><script type="math/tex; mode=display">C_i = E_K(P_i) \\P_i = D_K(C_i)</script><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201228161945839.png" alt="image-20201228161945839" style="zoom:67%;"></p><h3 id="CBC-Cipher-Block-Chaining"><a href="#CBC-Cipher-Block-Chaining" class="headerlink" title="CBC - Cipher Block Chaining"></a>CBC - Cipher Block Chaining</h3><p>密码分组链接模式构造一个初始向量，将密文与明文联结。</p><p>为了提高安全性，应该保护初始向量，可使用ECB加密模式发送。</p><p>CBC对于加密长于64bit的消息非常合适，除了能够获得保密性，还可以实现认证（因为初始向量的保密性）。</p><p>值得一提的是，如果攻击者能修改IV，则会发生错误传播。</p><script type="math/tex; mode=display">C_i = E_K(C_{i-1}\oplus X_i) \\X_i = C_{i-1} \oplus D_K(C_i)</script><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201228162226305.png" alt="image-20201228162226305" style="zoom:67%;"><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201228162308253.png" alt="image-20201228162308253"></p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201228162327881.png" alt="image-20201228162327881" style="zoom:67%;"></p><h3 id="CFB-Cipher-FeedBack"><a href="#CFB-Cipher-FeedBack" class="headerlink" title="CFB - Cipher FeedBack"></a>CFB - Cipher FeedBack</h3><p>DES是分组长为64bit的分组密码，利用CFB模式或OFB模式可以将其转换为流密码。</p><p>对于密码反馈模式，加密算法的输入是64bit移位寄存器，初值为一个初始向量。</p><p>和CBC模式一样，CFB也可以实现保密与认证，也会发生错误传播。</p><script type="math/tex; mode=display">C_i = P_i \oplus DES_K(C_{i-1}) \\C_{-1} = IV</script><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201228163342807.png" alt="image-20201228163342807" style="zoom:67%;"></p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201228163350510.png" alt="image-20201228163350510" style="zoom:67%;"></p><h3 id="OFB-Output-FeedBack"><a href="#OFB-Output-FeedBack" class="headerlink" title="OFB - Output FeedBack"></a>OFB - Output FeedBack</h3><p>输出反馈方式的结构类似于CFB，不过OFB将加密算法的输出反馈到移位寄存器，而CFB将密文单元反馈到移位寄存器。</p><p>OFB的优点是避免了错误传播，如果第一段密文中出错，解密结果中只有第一段明文受影响。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201228164324675.png" alt="image-20201228164324675" style="zoom:67%;"></p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201228164338403.png" alt="image-20201228164338403" style="zoom:67%;"></p><h3 id="CTR-Counter"><a href="#CTR-Counter" class="headerlink" title="CTR - Counter"></a>CTR - Counter</h3><p>计算器模式可以并行加密，并且实现了加密数据块的随机访问。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201228164700793.png" alt="image-20201228164700793" style="zoom:67%;"></p><h2 id="密码分析攻击"><a href="#密码分析攻击" class="headerlink" title="密码分析攻击"></a>密码分析攻击</h2><ul><li>唯密文攻击</li><li>已知明文攻击</li><li>选择明文攻击</li><li>自适应选择明文攻击</li><li>选择密文攻击</li><li>自适应选择密文攻击</li></ul><p>DES可能会受到差分分析攻击（分析明文对的差值对密文对的影响）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍分组密码，包括Feistel Cipher、DES和IDEA等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="现代密码学" scheme="https://entropy2333.github.io/categories/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
      <category term="分组密码" scheme="https://entropy2333.github.io/tags/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>现代密码学（二）古典密码</title>
    <link href="https://entropy2333.github.io/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/"/>
    <id>https://entropy2333.github.io/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/</id>
    <published>2020-12-27T09:08:17.000Z</published>
    <updated>2020-12-27T10:15:18.993Z</updated>
    
    <content type="html"><![CDATA[<p>介绍古典代换密码和古典置换密码。</p><a id="more"></a><h2 id="古典密码"><a href="#古典密码" class="headerlink" title="古典密码"></a>古典密码</h2><p>古典密码只要有两种加密方式，替换和置换（substitution and transposition）。</p><p>替换是用新的字符代替原字符，置换是不改变原文字母集，打乱字符顺序。</p><h2 id="古典代换密码"><a href="#古典代换密码" class="headerlink" title="古典代换密码"></a>古典代换密码</h2><h3 id="Caesar-Cipher-恺撒密码"><a href="#Caesar-Cipher-恺撒密码" class="headerlink" title="Caesar Cipher-恺撒密码"></a>Caesar Cipher-恺撒密码</h3><p>恺撒密码的替换方法是，每个字母用其后的第三个字母替换。</p><script type="math/tex; mode=display">\alpha\leftarrow\alpha+3</script><p>恺撒密码可以表示为</p><ul><li>Plain: ABCDEFGHIJKLMNOPQRSTUVWXYZ</li><li>Cipher: DEFGHIJKLMNOPQRSTUVWXYZABC</li></ul><p>如密文L FDPH L VDZ L FRQTXHUHG，对应的明文即为移位三位，I CAME I SAW CONQUERED。</p><p>当然，恺撒密码也可以将移位的长度改成1-25的任一个，换言之，共有25种可能的密码算法（移位0不可用）。</p><h3 id="混合单表替换密码"><a href="#混合单表替换密码" class="headerlink" title="混合单表替换密码"></a>混合单表替换密码</h3><p>单字母替换密码用一个字母代替另外一个字母，相当于构造了字母表到字母表的双射，密钥长度是26个字母。</p><h3 id="Vigenere-Cipher"><a href="#Vigenere-Cipher" class="headerlink" title="Vigenère Cipher"></a>Vigenère Cipher</h3><p>发明了多字母替换密码，一个字母可以被多个字母替换，通过密钥选择对每个字母使用哪个字母表。</p><p>密钥的第i个字母表示使用第i个字母表。</p><p>如下例，密钥为CIPHER，分别定义了六张字母表（六个双射）。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/image-20201227175332395.png" alt="image-20201227175332395"></p><p>对于明文，用密钥选择字母用哪个字母表，这里的效果相当于明文与密钥相加减一。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/image-20201227175322132.png" alt="image-20201227175322132"></p><h3 id="Ciphers-Machines"><a href="#Ciphers-Machines" class="headerlink" title="Ciphers Machines"></a>Ciphers Machines</h3><ul><li>Jefferson Cylinder</li><li>Wheatstone disc</li><li>the German Enigma</li><li>the Swedish Hagelin</li><li>the Janpanese Purple</li></ul><h2 id="古典置换密码"><a href="#古典置换密码" class="headerlink" title="古典置换密码"></a>古典置换密码</h2><p>置换密码的核心思想是，按一定规则写出明文，按另一规则读出密文。</p><p>密钥就是用于读密文和写明文的方法。</p><h3 id="Scytale密码"><a href="#Scytale密码" class="headerlink" title="Scytale密码"></a>Scytale密码</h3><p>消息沿着圆柱横写，密钥是纸条和圆柱的宽度。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/image-20201227180058573.png" alt="image-20201227180058573"></p><h3 id="Rail-Fence-Cipher-轨道栅栏密码"><a href="#Rail-Fence-Cipher-轨道栅栏密码" class="headerlink" title="Rail Fence Cipher-轨道栅栏密码"></a>Rail Fence Cipher-轨道栅栏密码</h3><p>在不同行写下消息字母，按行读取消息。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/image-20201227180208972.png" alt="image-20201227180208972"></p><h3 id="几何图形密码"><a href="#几何图形密码" class="headerlink" title="几何图形密码"></a>几何图形密码</h3><p>以一种形式写，用另一种形式读。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/image-20201227180223935.png" alt="image-20201227180223935"></p><h3 id="行变换密码"><a href="#行变换密码" class="headerlink" title="行变换密码"></a>行变换密码</h3><p>按行写出字母，以密钥给出的顺序按行读出密文。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/image-20201227180454135.png" alt="image-20201227180454135"></p><p>对上图的解释：</p><ul><li>给定明文，分组长度为5，按25413的顺序对字母重新编排，如THESI变成STIEH。</li><li>给定密文，分组长度为5，按41532的顺序读取信息，如STIEH变成THESI。</li></ul><p>其实相当于定义了置换</p><script type="math/tex; mode=display">\sigma = \begin{pmatrix} 1 & 2 & 3 & 4 & 5 \\ 2 & 5 & 4 & 1 & 3 \end{pmatrix}</script><p>对应的逆置换即为</p><script type="math/tex; mode=display">\sigma^{-1} = \begin{pmatrix} 2 & 5 & 4 & 1 & 3 \\ 1 & 2 & 3 & 4 & 5 \end{pmatrix} = \begin{pmatrix} 1 & 2 & 3 & 4 & 5 \\ 4 & 1 & 5 & 3 & 2 \end{pmatrix}</script><h4 id="密码分析"><a href="#密码分析" class="headerlink" title="密码分析"></a>密码分析</h4><p>我们希望猜测密钥周期，再对可能的行列变换进行猜测。</p><p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/image-20201227181407687.png" alt="image-20201227181407687"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍古典代换密码和古典置换密码。&lt;/p&gt;
    
    </summary>
    
    
      <category term="现代密码学" scheme="https://entropy2333.github.io/categories/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
      <category term="古典密码" scheme="https://entropy2333.github.io/tags/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>现代密码学（一）绪论</title>
    <link href="https://entropy2333.github.io/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%80%EF%BC%89%E7%BB%AA%E8%AE%BA/"/>
    <id>https://entropy2333.github.io/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%80%EF%BC%89%E7%BB%AA%E8%AE%BA/</id>
    <published>2020-12-27T09:07:53.000Z</published>
    <updated>2020-12-27T09:27:40.070Z</updated>
    
    <content type="html"><![CDATA[<p>介绍密码学的基本概念。</p><a id="more"></a><h2 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h2><p>密码学是一门研究秘密信息隐写技术的学科。</p><ul><li>可以使消息的内容对所有人（除了发送者和接收者）保密</li><li>可以使接收者验证消息的正确性</li></ul><p>常用的术语如下</p><ul><li>明文 plaintext</li><li>密文 ciphertext</li><li>密码算法 cipher</li><li>密钥 key</li><li>编码 encipher/encode</li><li>译码 decipher/decode</li><li>密码分析 cryptanalysis/codebreaking</li><li>密码学 cryptology</li></ul><h3 id="符号记法"><a href="#符号记法" class="headerlink" title="符号记法"></a>符号记法</h3><p>加密 Encryption</p><script type="math/tex; mode=display">C = EK(P)</script><p>解密 Decryption</p><script type="math/tex; mode=display">P = EK_{-1}(C)</script><p>可以把密码系统理解为明文空间到密文空间的变换，其中密钥取自密钥空间。</p><script type="math/tex; mode=display">P\xrightarrow{EK}C \\C\xrightarrow{EK_{-1}}P</script><h2 id="算法分类"><a href="#算法分类" class="headerlink" title="算法分类"></a>算法分类</h2><ul><li>私钥加密算法<ul><li>分组密码</li><li>流密码（序列密码）</li></ul></li><li>公钥加密算法</li><li>数字签名算法</li><li>哈希函数</li></ul><h2 id="密码分析"><a href="#密码分析" class="headerlink" title="密码分析"></a>密码分析</h2><p>密码分析学是指在没有加密密钥的情况下，攻击密文的过程。</p><ul><li>唯密文攻击<ul><li>只知道算法与一些密文</li><li>利用统计方法</li><li>需要能够识别明文</li></ul></li><li>已知明文攻击<ul><li>知道一些明文/密文对</li><li>利用已知的明文/密文对进行攻击</li></ul></li><li>选择明文攻击<ul><li>能够选择明文并得到相应的密文</li><li>利用算法的结构进行攻击</li></ul></li><li>选择密文攻击<ul><li>能够选择密文并得到相应的明文</li><li>利用对算法结构的知识进行攻击</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍密码学的基本概念。&lt;/p&gt;
    
    </summary>
    
    
      <category term="现代密码学" scheme="https://entropy2333.github.io/categories/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
      <category term="密码学" scheme="https://entropy2333.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>《C++ Primer》 Chapter 3 字符串、向量和数组</title>
    <link href="https://entropy2333.github.io/2020/11/23/%E3%80%8AC++%20Primer%E3%80%8B%20Chapter%203%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/"/>
    <id>https://entropy2333.github.io/2020/11/23/%E3%80%8AC++%20Primer%E3%80%8B%20Chapter%203%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/</id>
    <published>2020-11-23T08:48:44.000Z</published>
    <updated>2020-11-30T07:03:57.402Z</updated>
    
    <content type="html"><![CDATA[<p>介绍标准库string和vector，以及迭代器和数组的使用。</p><a id="more"></a><h3 id="命名空间的using声明"><a href="#命名空间的using声明" class="headerlink" title="命名空间的using声明"></a>命名空间的using声明</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>::name;</span><br></pre></td></tr></table></figure><p>头文件不应该包含using声明。</p><h2 id="标准库类型string"><a href="#标准库类型string" class="headerlink" title="标准库类型string"></a>标准库类型string</h2><p>string定义在命名空间std中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std::string;</span><br></pre></td></tr></table></figure><h3 id="定义和初始化"><a href="#定义和初始化" class="headerlink" title="定义和初始化"></a>定义和初始化</h3><p>如果使用等号，实际上执行的是拷贝初始化。反之，执行的是直接初始化。</p><p><img src="/2020/11/23/%E3%80%8AC++%20Primer%E3%80%8B%20Chapter%203%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/image-20201130133107639.png" alt="image-20201130133107639"></p><h3 id="string对象上的操作"><a href="#string对象上的操作" class="headerlink" title="string对象上的操作"></a>string对象上的操作</h3><p><img src="/2020/11/23/%E3%80%8AC++%20Primer%E3%80%8B%20Chapter%203%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/image-20201130125844111.png" alt="image-20201130125844111"></p><h4 id="读写"><a href="#读写" class="headerlink" title="读写"></a>读写</h4><p>执行读取操作时，会自动忽略开头的空白字符，直至遇到下一处空白。</p><p>输入”    Hello World!    “，输出则为”Hello”。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以用getline读取一整行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">line</span>;</span><br><span class="line">    <span class="keyword">while</span> (getline(<span class="built_in">cin</span>, <span class="built_in">line</span>))</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">line</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="empty-amp-size"><a href="#empty-amp-size" class="headerlink" title="empty&amp;size"></a>empty&amp;size</h4><p>empty判断string对象是否为空，返回bool。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (getline(<span class="built_in">cin</span>, <span class="built_in">line</span>))</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">line</span>.empty())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">line</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>size返回string对象的长度，类型为string::size_type。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (getline(<span class="built_in">cin</span>, <span class="built_in">line</span>))</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">line</span>.empty())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">line</span>.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><blockquote><p>此时，空字符也会计数。</p></blockquote><p>当使用size_type进行比较时，注意不要与int混用，因为负值的带符号数会转化为大整数的无符号数。</p><h4 id="比较-amp-加法"><a href="#比较-amp-加法" class="headerlink" title="比较&amp;加法"></a>比较&amp;加法</h4><p>string对象逐字符比较，按字典序比较。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> s2 = <span class="string">&quot;abc def&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> s3 = <span class="string">&quot;abdef&quot;</span>;</span><br><span class="line"><span class="comment">// res: s1 &lt; s2 &lt; s3</span></span><br></pre></td></tr></table></figure><p>两个string对象可以相加，字面值也可以和string对象相加。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1 = <span class="string">&quot;hello&quot;</span>, s2 = <span class="string">&quot;world&quot;</span>。</span><br><span class="line"><span class="built_in">string</span> s3 = s1 + s2。</span><br><span class="line"><span class="built_in">string</span> s4 = s1 + <span class="string">&quot; &quot;</span> + s2 + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> s5 = <span class="string">&quot;hello&quot;</span> + <span class="string">&quot; &quot;</span> + s2; <span class="comment">// error</span></span><br></pre></td></tr></table></figure><blockquote><p>运算时，应保证+两侧的运算对象至少有一个是string。</p></blockquote><h3 id="处理string中的字符"><a href="#处理string中的字符" class="headerlink" title="处理string中的字符"></a>处理string中的字符</h3><p>下表给出了一些关于字符属性的函数。</p><p><img src="/2020/11/23/%E3%80%8AC++%20Primer%E3%80%8B%20Chapter%203%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/image-20201130125720977.png" alt="image-20201130125720977"></p><blockquote><p>C++标准库为了兼容C，将C的头文件如name.h，命名为cname。</p><p>C++程序应该使用cname形式的头文件，以区分从C继承的头文件。</p></blockquote><p>为了遍历string对象，可以使用下标，也可以使用范围for语句（推荐）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> c : s)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>如果想要改变字符，需要把循环变量定义为引用类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : s)</span><br><span class="line">    c = <span class="built_in">toupper</span>(c);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s;</span><br></pre></td></tr></table></figure><p>有时候只需要处理部分字符，可以使用下标，也可以使用迭代器（后续介绍）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现单词首字母大写</span></span><br><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">decltype</span>(s.<span class="built_in">size</span>()) index = <span class="number">0</span>;</span><br><span class="line">     index != s.<span class="built_in">size</span>(); ++index) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span> &amp;&amp; <span class="built_in">isalpha</span>(s[index])) &#123;</span><br><span class="line">        s[index] = <span class="built_in">toupper</span>(s[index]);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isalpha</span>(s[index]) &amp;&amp; !<span class="built_in">isalpha</span>(s[index<span class="number">-1</span>]))</span><br><span class="line">        s[index] = <span class="built_in">toupper</span>(s[index]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s; <span class="comment">// output: &quot;Hello world&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>使用下标时，切忌下标越界，应该时刻检查下标的合法性。</p></blockquote><h2 id="标准库类型vector"><a href="#标准库类型vector" class="headerlink" title="标准库类型vector"></a>标准库类型vector</h2><p>vector表示相同类型对象的集合，每个对象都有一个索引用于访问对象。因此vector也被称为容器，vector同时也是一个类模板（距离还比较遥远）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br></pre></td></tr></table></figure><p>模板实例化时，需要提供对象类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec;                <span class="comment">// 元素是int</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; file;    <span class="comment">// 元素是存放string的vector</span></span><br></pre></td></tr></table></figure><p>vector作为类模板，不是类型。</p><p>引用不是对象，不存在包含引用的vector。</p><h3 id="定义和初始化vector对象"><a href="#定义和初始化vector对象" class="headerlink" title="定义和初始化vector对象"></a>定义和初始化vector对象</h3><p><img src="/2020/11/23/%E3%80%8AC++%20Primer%E3%80%8B%20Chapter%203%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/image-20201130133133358.png" alt="image-20201130133133358"></p><p>注意区分列表初始化和元素数量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1&#123;<span class="number">10</span>&#125;; <span class="comment">// 列表初始化，v1有1个元素，值为10。</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// v2有10个元素，值为0。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v3&#123;<span class="number">10</span>, <span class="number">1</span>&#125;; <span class="comment">// 列表初始化，v3有2个元素，值为10和1。</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v4</span><span class="params">(<span class="number">10</span>, <span class="number">1</span>)</span></span>; <span class="comment">// v4有10个元素，值为1。</span></span><br></pre></td></tr></table></figure><h3 id="向vector对象添加元素"><a href="#向vector对象添加元素" class="headerlink" title="向vector对象添加元素"></a>向vector对象添加元素</h3><p>可以用vector的成员函数push_back添加元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">    v.push_back(i);</span><br></pre></td></tr></table></figure><blockquote><p>与C不同，C++推荐先定义一个空的vector对象，运行时向其中添加具体值。</p></blockquote><h3 id="其他vector操作"><a href="#其他vector操作" class="headerlink" title="其他vector操作"></a>其他vector操作</h3><p><img src="/2020/11/23/%E3%80%8AC++%20Primer%E3%80%8B%20Chapter%203%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/image-20201130133935086.png" alt="image-20201130133935086"></p><p>vector同样支持范围for语句。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : v)    <span class="comment">// 使用引用对vector的元素赋值</span></span><br><span class="line">    i *= <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : v)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure><p>与string类似，vector的size函数返回类型为vector<T>::size_type。</T></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 统计各分数段内的人数</span></span><br><span class="line"><span class="comment">// input: 42 65 95 100 39 67 95 76 88 76 83 92 76 93 101</span></span><br><span class="line"><span class="comment">// output: 0 0 0 1 1 0 2 3 2 4 1</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span>&gt; <span class="title">scores</span><span class="params">(<span class="number">11</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">unsigned</span> grade = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; grade) &#123;</span><br><span class="line">    <span class="keyword">if</span> (grade &lt;= <span class="number">100</span>)</span><br><span class="line">        ++scores[grade/<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : scores)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="迭代器介绍"><a href="#迭代器介绍" class="headerlink" title="迭代器介绍"></a>迭代器介绍</h2><h3 id="使用迭代器"><a href="#使用迭代器" class="headerlink" title="使用迭代器"></a>使用迭代器</h3><p>有迭代器的类型拥有名为begin和end的成员。</p><p>begin成员返回指向第一个元素的迭代器，end成员返回指向容器“尾后”元素的迭代器，通常被称作尾后迭代器。</p><p>如果容器为空，begin和end返回的是同一个迭代器，都是尾后迭代器。</p><p><img src="/2020/11/23/%E3%80%8AC++%20Primer%E3%80%8B%20Chapter%203%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/image-20201130135012221.png" alt="image-20201130135012221"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isalpha</span>(*it))</span><br><span class="line">        *it = <span class="built_in">toupper</span>(*it);</span><br></pre></td></tr></table></figure><blockquote><p>C++习惯在for循环中使用!=进行判断，因为大多数迭代器都没有定义&lt;运算符。</p></blockquote><p>迭代器也有const类型，能读取但不能修改vector。</p><p>为了便捷，C++11引入了两个新函数cbegin和cend。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line"><span class="keyword">auto</span> it1 = v1.<span class="built_in">begin</span>();    <span class="comment">// type: vector&lt;int&gt;::iterator</span></span><br><span class="line"><span class="keyword">auto</span> it2 = v2.<span class="built_in">begin</span>();  <span class="comment">// type: vector&lt;int&gt;::const_iterator</span></span><br><span class="line"><span class="keyword">auto</span> it3 = v1.cbegin(); <span class="comment">// type: vector&lt;int&gt;::const_iterator</span></span><br></pre></td></tr></table></figure><p>为了简化解引用和成员访问操作一起使用，C++定义了箭头运算符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*it.empty;   <span class="comment">// error</span></span><br><span class="line">(*it).empty;</span><br><span class="line">it-&gt;empty;</span><br></pre></td></tr></table></figure><h3 id="迭代器运算"><a href="#迭代器运算" class="headerlink" title="迭代器运算"></a>迭代器运算</h3><p><img src="/2020/11/23/%E3%80%8AC++%20Primer%E3%80%8B%20Chapter%203%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/image-20201130135031052.png" alt="image-20201130135031052"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到最接近中间元素的迭代器</span></span><br><span class="line"><span class="keyword">auto</span> mid = v.<span class="built_in">begin</span>() + v.<span class="built_in">size</span>() / <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>C++定义了迭代器的差值，类型为difference_type。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分搜索</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="built_in">text</span>;</span><br><span class="line"><span class="built_in">string</span> sought;</span><br><span class="line"><span class="keyword">auto</span> beg = <span class="built_in">text</span>.<span class="built_in">begin</span>(), <span class="built_in">end</span> = <span class="built_in">text</span>.<span class="built_in">end</span>();</span><br><span class="line"><span class="keyword">auto</span> mid = <span class="built_in">text</span>.<span class="built_in">begin</span>() + (<span class="built_in">end</span> - beg) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (mid != <span class="built_in">end</span> &amp;&amp; *mid != sought) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sought &lt; *mid) <span class="comment">// 在前半部分则忽略后半部分</span></span><br><span class="line">        <span class="built_in">end</span> = mid;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        beg = mid + <span class="number">1</span>; <span class="comment">// 否则忽略前半部分</span></span><br><span class="line">    mid = beg + (<span class="built_in">end</span> - beg) /<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>与vector不同，数组的大小确定不变，不能随意增加元素。</p><h3 id="定义和初始化-1"><a href="#定义和初始化-1" class="headerlink" title="定义和初始化"></a>定义和初始化</h3><p>数组的长度在编译时必须已知，所以维度必须是常量表达式。</p><p>定义数组时，必须指定类型，不能使用auto。和vector一样，不存在引用的数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> cnt = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">unsigned</span> sz = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> *parr[sz];     <span class="comment">// 包含42个整型指针的数组</span></span><br><span class="line"><span class="built_in">string</span> bad[cnt]; <span class="comment">// error</span></span><br></pre></td></tr></table></figure><p>数组也支持列表初始化，此时可以不指明长度，编译器会自动计算。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> sz = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> ial[sz] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a2[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a3[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;    <span class="comment">// a3[] = &#123;0, 1, 2, 0, 0&#125;</span></span><br></pre></td></tr></table></figure><p>值得注意的是，在使用字符数组时，会在结尾添加一个空字符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a1[] = &#123;<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;+&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> a2[] = &#123;<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;    <span class="comment">// 显式添加空字符</span></span><br><span class="line"><span class="keyword">char</span> a3[] = <span class="string">&quot;C++&quot;</span>;    <span class="comment">// 自动添加空字符</span></span><br><span class="line"><span class="keyword">char</span> a4[<span class="number">6</span>] = <span class="string">&quot;Daniel&quot;</span>; <span class="comment">// error</span></span><br></pre></td></tr></table></figure><p>上述表达式中，a1长度为3，a2和a3的长度都是4，a4长度应改为7。</p><p>数组不允许拷贝和赋值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a2[] = a; <span class="comment">// error</span></span><br><span class="line">a2 = a; <span class="comment">// error</span></span><br></pre></td></tr></table></figure><p>为了理解复杂的数组声明，可以从内向外阅读。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptrs[<span class="number">10</span>]; <span class="comment">// 含有10个整型指针的数组</span></span><br><span class="line"><span class="keyword">int</span> &amp;refs[<span class="number">10</span>]; <span class="comment">// 不存在引用的数组</span></span><br><span class="line"><span class="keyword">int</span> (*Parray)[<span class="number">10</span>] = &amp;arr; <span class="comment">// Parray指向一个含有10个整数的数组</span></span><br><span class="line"><span class="keyword">int</span> (&amp;arrRef)[<span class="number">10</span>] = arr;  <span class="comment">// arrRef引用一个含有10个整数的数组</span></span><br><span class="line"><span class="keyword">int</span> *(&amp;arry)[<span class="number">10</span>] = ptrs;  <span class="comment">// arry是数组的引用，该数组含有10个指针</span></span><br></pre></td></tr></table></figure><h3 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h3><p>数组也可以用范围for语句或下标运算符访问。</p><p>数组下标被定义为size_t类型，定义在cstddef头文件中。</p><h3 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h3><p>使用数组的时候，编译器一般会把它转换成指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> nums[] = &#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">string</span> *p1 = &amp;nums[<span class="number">0</span>]; <span class="comment">// p1指向nums的第一个元素</span></span><br><span class="line"><span class="built_in">string</span> *p2 = &amp;nums;       <span class="comment">// p2和p1等价</span></span><br></pre></td></tr></table></figure><p>尽管能计算得到数组的尾后指针，但容易出错。C++11引入两个函数begin和end，与容器的同名成员功能类似。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *beg = <span class="built_in">begin</span>(ia);</span><br><span class="line"><span class="keyword">int</span> *last = <span class="built_in">end</span>(ia);</span><br></pre></td></tr></table></figure><p>与容器相似，指针相减的类型名为ptrdiff_t，也定义在cstddef中。</p><h4 id="C风格字符串"><a href="#C风格字符串" class="headerlink" title="C风格字符串"></a>C风格字符串</h4><blockquote><p>尽管C++支持，但最好不好使用。</p></blockquote><p><img src="/2020/11/23/%E3%80%8AC++%20Primer%E3%80%8B%20Chapter%203%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/image-20201130144349734.png" alt="image-20201130144349734"></p><h4 id="与旧代码的接口"><a href="#与旧代码的接口" class="headerlink" title="与旧代码的接口"></a>与旧代码的接口</h4><p>允许使用字符串字面值初始化string对象，反过来则不行，需要使用c_str函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">&quot;hello world&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">char</span> *str = s; <span class="comment">// error</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *str = s.c_str();</span><br></pre></td></tr></table></figure><p>可以使用数组初始化vector对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> int_arr[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ivec</span><span class="params">(<span class="built_in">begin</span>(int_arr), <span class="built_in">end</span>(int_arr))</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>C++应当尽量使用vector和迭代器，而非内置数组和指针；应当尽量使用string，而非C风格字符串。</p></blockquote><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>多维数组实际上就是数组的数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia1[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;,</span><br><span class="line">    &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> ia2[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> ia3[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123; <span class="number">0</span> &#125;, &#123; <span class="number">1</span> &#125;, &#123; <span class="number">2</span> &#125;&#125;; <span class="comment">// 初始化每行的第一个元素</span></span><br><span class="line"><span class="keyword">int</span> ia4[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>&#125;; <span class="comment">// 初始化第一行</span></span><br></pre></td></tr></table></figure><p>可以通过下标运算符访问多维数组的元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">size_t</span> rowCnt = <span class="number">3</span>, colCnt = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> ia[rowCnt][colCnt];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != rowCnt; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j != colCnt; ++j) &#123;</span><br><span class="line">        ia[i][j] = i * colCnt + j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以用范围for语句访问，实现同样的效果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;row : ia) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;col : row) &#123;</span><br><span class="line">        col = cnt;</span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为循环中要赋值，所以选用引用类型。其实除了内层循环，其他所有循环的控制变量都应该是引用类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> row : ia)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> col : row)</span><br></pre></td></tr></table></figure><p>上面这段语句将无法通过编译，因为row不是引用类型，所以row的类型是int*。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ip[<span class="number">4</span>];   <span class="comment">// 整形指针的数组</span></span><br><span class="line"><span class="keyword">int</span> (*ip)[<span class="number">4</span>]; <span class="comment">// 指向含有4个整数的数组</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍标准库string和vector，以及迭代器和数组的使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="《C++ Primer》" scheme="https://entropy2333.github.io/categories/%E3%80%8AC-Primer%E3%80%8B/"/>
    
    
      <category term="C++" scheme="https://entropy2333.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>《C++ Primer》 Chapter 2 变量和基本类型</title>
    <link href="https://entropy2333.github.io/2020/11/23/%E3%80%8AC++%20Primer%E3%80%8B%20Chapter%202%20%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"/>
    <id>https://entropy2333.github.io/2020/11/23/%E3%80%8AC++%20Primer%E3%80%8B%20Chapter%202%20%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-11-23T07:01:27.000Z</published>
    <updated>2020-11-23T08:46:26.994Z</updated>
    
    <content type="html"><![CDATA[<p>介绍C++的基本内置类型和复合类型，包括引用和指针的声明，以及const限定符的使用方法。</p><a id="more"></a><h2 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h2><p>下表列出了各内置类型的最小尺寸。</p><p><img src="/2020/11/23/%E3%80%8AC++%20Primer%E3%80%8B%20Chapter%202%20%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/image-20201123150453260.png" alt="image-20201123150453260"></p><blockquote><p>2^31 - 1= 2147483647是个常见的数字。</p></blockquote><h3 id="带符号类型和无符号类型"><a href="#带符号类型和无符号类型" class="headerlink" title="带符号类型和无符号类型"></a>带符号类型和无符号类型</h3><p>无符号类型只能表示大于等于0的值，带符号类型可以表示正负数和0。</p><p>8bit的unsigned char可以表示0~255之间的值，signed char则为-128~127。</p><blockquote><p>执行浮点数运算时选用double</p></blockquote><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul><li>当把非bool的算术值赋给bool时，初始值为0结果为false，否则为true。</li><li>把bool值赋给非bool时，初始值为false则结果为0，true则结果为1。</li><li>赋给无符号类型一个超出表示范围的值，结果是取模后的余数。<ul><li>赋-1给unsigned char，结果是255。</li><li><strong>切勿混用带符号类型和无符号类型！</strong></li><li>因为无符号数非负，所以下面这段代码为死循环。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">10</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h3 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h3><p>C++规定的转义序列如下</p><p><img src="/2020/11/23/%E3%80%8AC++%20Primer%E3%80%8B%20Chapter%202%20%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/image-20201123153641722.png" alt="image-20201123153641722"></p><p>C++还可以对常量添加前缀和后缀，改变默认类型。</p><ul><li>比如L’a’定义了宽字符型字面值，类型是wchar_t。</li></ul><p><img src="/2020/11/23/%E3%80%8AC++%20Primer%E3%80%8B%20Chapter%202%20%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/image-20201123153731472.png" alt="image-20201123153731472"></p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><p>以下四条语句都可以定义一个int变量并初始化为0。</p><p>在C++11，可以用花括号来初始化变量，称为列表初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> cnt = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cnt</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> cnt&#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>初始化：创建变量时，赋予其一个初始值。</p><p>赋值：把对象的当前值擦除，用一个新值代替。</p></blockquote><p>定义在函数体内部的内置类型变量将不被初始化，此时值是未定义的。</p><h3 id="变量定义-amp-声明"><a href="#变量定义-amp-声明" class="headerlink" title="变量定义&amp;声明"></a>变量定义&amp;声明</h3><ul><li>变量声明：规定了变量的类型和名字</li><li>变量定义：还申请存储空间，也可能会为变量赋一个初始值。</li><li>如果想声明一个变量而非定义，要添加关键字extern。</li><li>变量的定义只出现在一个文件中，其他使用该变量的文件对其声明，但不能重复定义。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i; <span class="comment">// 声明变量</span></span><br><span class="line"><span class="keyword">int</span> j;          <span class="comment">// 声明并定义</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>; <span class="comment">// 定义</span></span><br></pre></td></tr></table></figure><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><ul><li>标识符以字母或数字开头，大小写敏感。</li><li>变量名一般小写，类名一般以大写字母开头。</li><li>标识符由多个单词组成，应有区分，如student_loan或studentLoan。</li></ul><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ul><li>如果函数要用到全局变量，则不宜再定义一个同名的局部变量。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">// 用::cnt显式访问全局变量</span></span><br><span class="line">    <span class="comment">// result: 10 20</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ::cnt &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h2><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li>引用为对象起另外一个名字</li><li>无法令引用重新绑定到另外一个对象，所以引用必须初始化。</li><li>引用只能绑定在对象上，引用自身不是对象。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;refVal = val;</span><br><span class="line"><span class="keyword">int</span> refVal;        <span class="comment">// 报错：引用必须初始化</span></span><br></pre></td></tr></table></figure><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><ul><li>指针存放某个对象的地址，使用取地址符&amp;获取地址。</li><li>使用解引用符*访问指针指向的对象。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;val;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p &lt;&lt; *p; <span class="comment">// result: 008FF9F8 1024</span></span><br></pre></td></tr></table></figure><p>空指针不指向任何对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="number">0</span>; <span class="comment">// 指针不能指向字面值常量，0表示空指针。</span></span><br><span class="line"><span class="keyword">int</span> *p3 = <span class="literal">NULL</span>; <span class="comment">// include &lt;cstdlib&gt;</span></span><br></pre></td></tr></table></figure><p>void*是一种特殊的指针，可以指向任意非常量，不能执行解引用操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> pi = <span class="number">3.14</span>, *pd = &amp; pi;</span><br><span class="line"><span class="keyword">void</span> *pv = &amp;pi;</span><br><span class="line">pv = pd;</span><br></pre></td></tr></table></figure><h3 id="理解复合类型的声明"><a href="#理解复合类型的声明" class="headerlink" title="理解复合类型的声明"></a>理解复合类型的声明</h3><p>定义指针和引用时，最好将*和&amp;与变量名连在一起，以免引起误导。</p><p>指针可以指向指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> *pi = &amp;val;</span><br><span class="line"><span class="keyword">int</span> **ppi = &amp;pi;</span><br></pre></td></tr></table></figure><p>引用不是对象，所以不存在指向引用的指针。</p><p>但指针是对象，所以引用可以绑定指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;i;</span><br><span class="line"><span class="keyword">int</span> *&amp;r = p;    <span class="comment">// r是一个对指针p的引用</span></span><br><span class="line"></span><br><span class="line">r = &amp;i;</span><br><span class="line">*r = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h2><h3 id="const的引用"><a href="#const的引用" class="headerlink" title="const的引用"></a>const的引用</h3><p>使用const定义变量时，变量的值不能被改变，const对象必须初始化。</p><blockquote><p>一般const对象仅在文件内有效，多个文件中出现同名的const变量，等同于在不同文件中分别定义了独立的变量。</p><p>如果想共享const变量，需要用extern修饰。</p></blockquote><p>可以把引用绑定到const对象上，称为对常量的引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> val = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;refVal = val;</span><br><span class="line">refVal = <span class="number">10</span>;        <span class="comment">// 错误：对常量的引用不能修改绑定的对象</span></span><br><span class="line"><span class="keyword">int</span> &amp;refVal2 = val; <span class="comment">// 错误：非常量引用不能绑定常量对象</span></span><br></pre></td></tr></table></figure><p>允许为一个常量引用绑定非常量的对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = i * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r4 = r1 * <span class="number">2</span>;    <span class="comment">// 错误：r1是常量引用，r4是非常量引用。</span></span><br></pre></td></tr></table></figure><p>常量引用绑定非常量对象时，不能通过常量引用改变值，但可以通过其他途径改变绑定对象的值。</p><h3 id="const与指针"><a href="#const与指针" class="headerlink" title="const与指针"></a>const与指针</h3><p>指向常量指针不能改变所指对象的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *p = &amp;pi;</span><br><span class="line">*p = <span class="number">10</span>;        <span class="comment">// error</span></span><br></pre></td></tr></table></figure><p>const指针不能改变指针本身的值，而非指向的那个值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> pi = <span class="number">3.14</span>, i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">double</span> *<span class="keyword">const</span> p = &amp;pi;</span><br><span class="line">p = &amp;i;            <span class="comment">// error</span></span><br></pre></td></tr></table></figure><h3 id="顶层const"><a href="#顶层const" class="headerlink" title="顶层const"></a>顶层const</h3><p><strong>顶层const表示指针本身是常量，底层const表示指针指向的对象是一个常量。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> ci = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p1 = &amp;i;        <span class="comment">// top-level</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p2 = &amp;ci;    <span class="comment">// low-level</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p3 = p2; <span class="comment">// low-level &amp; top-level</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r = ci;        <span class="comment">// low-level</span></span><br></pre></td></tr></table></figure><h3 id="constexpr和常量表达式"><a href="#constexpr和常量表达式" class="headerlink" title="constexpr和常量表达式"></a>constexpr和常量表达式</h3><p>常量表达式是指值不会改变并且在编译过程中就能得到计算结果的表达式。</p><h2 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h2><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>有两种方法可以定义类型别名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> wages;</span><br><span class="line"><span class="keyword">using</span> wages = <span class="keyword">double</span>;</span><br></pre></td></tr></table></figure><h3 id="auto-amp-decltype"><a href="#auto-amp-decltype" class="headerlink" title="auto &amp; decltype"></a>auto &amp; decltype</h3><p>auto让编译器去分析表达式所属的类型，auto定义的变量必须有初始值。</p><p>decltype可以返回操作数的数据类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(f()) sum = x;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>, *p = &amp;i;</span><br><span class="line"><span class="keyword">decltype</span>(*p) c; <span class="comment">// 错误：c是int&amp;，必须初始化。</span></span><br></pre></td></tr></table></figure><h2 id="自定义数据结构"><a href="#自定义数据结构" class="headerlink" title="自定义数据结构"></a>自定义数据结构</h2><h3 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SALES_DATA_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SALES_DATA_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍C++的基本内置类型和复合类型，包括引用和指针的声明，以及const限定符的使用方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="《C++ Primer》" scheme="https://entropy2333.github.io/categories/%E3%80%8AC-Primer%E3%80%8B/"/>
    
    
      <category term="C++" scheme="https://entropy2333.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>《C++ Primer》 Chapter 1 开始</title>
    <link href="https://entropy2333.github.io/2020/11/23/%E3%80%8AC++%20Primer%E3%80%8B%20Chapter%201%20%E5%BC%80%E5%A7%8B%20/"/>
    <id>https://entropy2333.github.io/2020/11/23/%E3%80%8AC++%20Primer%E3%80%8B%20Chapter%201%20%E5%BC%80%E5%A7%8B%20/</id>
    <published>2020-11-23T06:29:28.000Z</published>
    <updated>2020-11-23T07:00:11.346Z</updated>
    
    <content type="html"><![CDATA[<p>初识C++。</p><a id="more"></a><h2 id="编写一个简单的C-程序"><a href="#编写一个简单的C-程序" class="headerlink" title="编写一个简单的C++程序"></a>编写一个简单的C++程序</h2><p>每个C++程序都包含若干个函数，其中一个必须命名为main，操作系统通过调用main运行C++程序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编译、运行程序"><a href="#编译、运行程序" class="headerlink" title="编译、运行程序"></a>编译、运行程序</h3><p>程序运行后，可以通过echo命令访问main的返回值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> $? // UNIX</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$ERRORLEVEL</span>% // Windows</span><br></pre></td></tr></table></figure><h2 id="初识输入输出"><a href="#初识输入输出" class="headerlink" title="初识输入输出"></a>初识输入输出</h2><div class="table-container"><table><thead><tr><th>对象</th><th>用途</th></tr></thead><tbody><tr><td>cin</td><td>标准输入</td></tr><tr><td>cout</td><td>标准输出</td></tr><tr><td>cerr</td><td>标准错误</td></tr><tr><td>clog</td><td>程序运行时的一般性信息</td></tr></tbody></table></div><h3 id="注释简介"><a href="#注释简介" class="headerlink" title="注释简介"></a>注释简介</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单行注释</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    多行注释</span></span><br><span class="line"><span class="comment">    不能嵌套</span></span><br><span class="line"><span class="comment">/*</span></span><br></pre></td></tr></table></figure><h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><p>while &amp; for &amp; if</p><h3 id="读取数量不定的输入数据"><a href="#读取数量不定的输入数据" class="headerlink" title="读取数量不定的输入数据"></a>读取数量不定的输入数据</h3><p>当遇到文件结束符（EOF）或遇到一个无效输入时，istream对象的状态会变成无效，条件为假。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; value)</span><br><span class="line">        sum += value;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Sum is &quot;</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Windows系统中，输入EOF的方式是Ctrl + Z；UNIX中，方法是Ctrl + D。</p></blockquote><h3 id="统计输入的词频"><a href="#统计输入的词频" class="headerlink" title="统计输入的词频"></a>统计输入的词频</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> currVal = <span class="number">0</span>, val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; currVal) &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; val)</span><br><span class="line">            <span class="keyword">if</span> (val == currVal)</span><br><span class="line">                ++cnt;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; currVal &lt;&lt; <span class="string">&quot; occurs &quot;</span></span><br><span class="line">                          &lt;&lt; cnt &lt;&lt; <span class="string">&quot; times &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                currVal = val;</span><br><span class="line">                cnt = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; currVal &lt;&lt; <span class="string">&quot; occurs &quot;</span></span><br><span class="line">                  &lt;&lt; cnt &lt;&lt; <span class="string">&quot; times &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类简介"><a href="#类简介" class="headerlink" title="类简介"></a>类简介</h2><blockquote><p>包含来自标准库的头文件，使用&lt;&gt;包含头文件名；不属于标准库的头文件，使用””包围。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;初识C++。&lt;/p&gt;
    
    </summary>
    
    
      <category term="《C++ Primer》" scheme="https://entropy2333.github.io/categories/%E3%80%8AC-Primer%E3%80%8B/"/>
    
    
      <category term="C++" scheme="https://entropy2333.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Internet安全协议与分析（八）课程复习</title>
    <link href="https://entropy2333.github.io/2020/10/31/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AB%EF%BC%89%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/"/>
    <id>https://entropy2333.github.io/2020/10/31/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AB%EF%BC%89%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/</id>
    <published>2020-10-31T06:19:48.000Z</published>
    <updated>2020-10-31T11:01:15.894Z</updated>
    
    <content type="html"><![CDATA[<p>复习所学知识，应付考试orz。</p><a id="more"></a><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><h3 id="挑战-应答"><a href="#挑战-应答" class="headerlink" title="挑战-应答"></a>挑战-应答</h3><ul><li>客户端向服务器发出请求，请求身份认证。</li><li>服务器查询用户是否合法，合法则进行下一步。</li><li>服务器产生随机数，作为“挑战”发给客户端。</li><li>客户端将ID和随机数Hash，发送给服务器。</li><li>服务器比较结果，相同则通过认证，并通知客户端。</li></ul><h3 id="数字信封"><a href="#数字信封" class="headerlink" title="数字信封"></a>数字信封</h3><ul><li>将对称密钥通过非对称加密的方式分发。</li><li>发送方用对称密钥加密明文，并用接收方公钥加密对称密钥，将消息发给接收方。</li><li>接收方用私钥解密获得对称密钥，随后解密得到明文。</li></ul><h3 id="公钥环-amp-私钥环"><a href="#公钥环-amp-私钥环" class="headerlink" title="公钥环&amp;私钥环"></a>公钥环&amp;私钥环</h3><ul><li>公钥环保存该结点拥有的其他用户的公钥</li><li>私钥环保存该节点拥有的公私钥对（加密）</li></ul><h3 id="隧道模式"><a href="#隧道模式" class="headerlink" title="隧道模式"></a>隧道模式</h3><ul><li><p>AH</p><p><img src="/2020/10/31/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AB%EF%BC%89%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/image-20201031143043915.png" alt="image-20201031143043915"></p></li><li><p>ESP</p><p><img src="/2020/10/31/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AB%EF%BC%89%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/image-20201031143105550.png" alt="image-20201031143105550"></p></li></ul><h2 id="简答"><a href="#简答" class="headerlink" title="简答"></a>简答</h2><h3 id="BAN分析Otway-Rees"><a href="#BAN分析Otway-Rees" class="headerlink" title="BAN分析Otway-Rees"></a>BAN分析Otway-Rees</h3><ul><li>密钥有效性</li></ul><script type="math/tex; mode=display">bel(A, goodkey(S, K_{as}, S)) \\bel(B, goodkey(S, K_{bs}, S))</script><ul><li>S的权威性</li></ul><script type="math/tex; mode=display">bel(A, cont(S, skey(A, K_{ab}, B))) \\ bel(B, cont(S, skey(A, K_{ab}, B))) \\bel(A, cont(S, fresh(skey(A, K_{ab}, B)))</script><ul><li>随机数的新鲜性</li></ul><script type="math/tex; mode=display">bel(A, fresh(N_a)) \\bel(B, fresh(N_b))</script><h3 id="Kerberos协议中Ticket-v和认证头的结构和作用"><a href="#Kerberos协议中Ticket-v和认证头的结构和作用" class="headerlink" title="Kerberos协议中Ticket_v和认证头的结构和作用"></a>Kerberos协议中<script type="math/tex">Ticket_v</script>和认证头的结构和作用</h3><ul><li><script type="math/tex">Ticket_v</script>表示该用户已被AS认证</li><li>验证头用于验证ticket有效</li></ul><h3 id="安全协议中Nonce和时戳的作用和区别"><a href="#安全协议中Nonce和时戳的作用和区别" class="headerlink" title="安全协议中Nonce和时戳的作用和区别"></a>安全协议中Nonce和时戳的作用和区别</h3><ul><li>随机数是为了提供消息的新鲜性<ul><li>可以用于挑战应答，只使用一次，防止重放攻击。</li></ul></li><li>时戳依赖于时钟的同步。</li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="PGP"><a href="#PGP" class="headerlink" title="PGP"></a>PGP</h3><ul><li>发送方<ul><li>签名消息<ul><li>使用用户ID作为索引获取发送者的私钥</li><li>提示用户输入口令解密私钥</li><li>创建签名</li></ul></li><li>加密消息<ul><li>生成会话密钥，加密消息。</li><li>使用用户ID作为索引获取接收方公钥</li><li>创建会话消息</li></ul></li></ul></li><li>接收方<ul><li>解密消息<ul><li>使用消息内ID字段作为索引获取私钥</li><li>提示用户输入密钥解密私钥</li><li>恢复会话密钥，解密消息。</li></ul></li><li>认证消息<ul><li>使用签名密钥ID作为索引获取公钥</li><li>恢复消息摘要</li><li>计算消息摘要并和传输版本比较认证</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;复习所学知识，应付考试orz。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Internet安全协议与分析" scheme="https://entropy2333.github.io/categories/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>Internet安全协议与分析（零）安全协议基础</title>
    <link href="https://entropy2333.github.io/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/"/>
    <id>https://entropy2333.github.io/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/</id>
    <published>2020-10-27T06:31:21.000Z</published>
    <updated>2020-10-27T07:54:50.530Z</updated>
    
    <content type="html"><![CDATA[<p>介绍密码学的基础知识，包括公钥体制、数字签名、密钥分配等。</p><a id="more"></a><h2 id="信息安全"><a href="#信息安全" class="headerlink" title="信息安全"></a>信息安全</h2><h3 id="信息安全的范围"><a href="#信息安全的范围" class="headerlink" title="信息安全的范围"></a>信息安全的范围</h3><ul><li>物理安全</li><li>计算机安全</li><li>网络安全</li></ul><h3 id="信息安全的目标"><a href="#信息安全的目标" class="headerlink" title="信息安全的目标"></a>信息安全的目标</h3><ul><li>保密性</li><li>完整性</li><li>可用性</li></ul><h3 id="计算机网络面临的安全性威胁"><a href="#计算机网络面临的安全性威胁" class="headerlink" title="计算机网络面临的安全性威胁"></a>计算机网络面临的安全性威胁</h3><p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027143622649.png" alt="image-20201027143622649"></p><h2 id="密码学回顾"><a href="#密码学回顾" class="headerlink" title="密码学回顾"></a>密码学回顾</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>明文、密文、加密（算法）、解密（算法）</p><p>加密系统可以用五元组描述（P, C, K, E, D）</p><ul><li>P表示明文空间</li><li>C表示密文空间</li><li>K表示密钥空间</li><li>E表示加密算法</li><li>D表示解密算法</li></ul><p>数据加密系统可以用下图表示</p><p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027143901553.png" alt="image-20201027143901553"></p><h3 id="密码体制"><a href="#密码体制" class="headerlink" title="密码体制"></a>密码体制</h3><h4 id="对称密钥"><a href="#对称密钥" class="headerlink" title="对称密钥"></a>对称密钥</h4><ul><li>加密密钥和解密密钥相同</li><li>DES是一种分组密码<ul><li>加密前对明文分组，组长64位。</li><li>密钥为64位（8位用于奇偶校验）</li></ul></li></ul><h4 id="公钥体制"><a href="#公钥体制" class="headerlink" title="公钥体制"></a>公钥体制</h4><ul><li><p>使用不同的加密密钥和解密密钥</p></li><li><p>可以解决密钥分配问题，也用于数字签名。</p></li><li><p>公钥不能用于解密</p><script type="math/tex; mode=display">D_{PK_B}(E_{PK_B}(X))\neq X</script></li><li><p>加密和解密可以对调</p><script type="math/tex; mode=display">D_{PK_B}(E_{SK_B}(X)) = D_{SK_B}(E_{PK_B}(X)) = X</script></li></ul><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><ul><li>签名者事后不能否认自己的签名。</li><li>接收者可以验证签名，但其他人不能伪造签名。</li><li>双方关于签名真伪发生争执时，第三方可以解决争执。</li></ul><h4 id="鉴别"><a href="#鉴别" class="headerlink" title="鉴别"></a>鉴别</h4><ul><li>发送方用自己的私钥加密摘要，附到明文之后。</li><li>提供完整性鉴别，但不提供保密性。</li><li>为了满足保密性，需要结合加密。</li></ul><p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027144539975.png" alt="image-20201027144539975"></p><h4 id="数字信封"><a href="#数字信封" class="headerlink" title="数字信封"></a>数字信封</h4><ul><li>发送方用对称密钥加密明文，并用接收方的公钥加密对称密钥，附到密文之后。</li></ul><p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027144803675.png" alt="image-20201027144803675"></p><h4 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h4><ul><li>用户提交公钥等信息P，CA机构用私钥签名摘要产生S，P和S一起被称为数字证书。</li><li>用户可以用CA的公钥解密获取证书里的公钥，结合数字签名，验证证书的完整性。</li><li>下图的解释<ul><li>发送方首先产生摘要，用自己的私钥加密形成数字签名，附到消息之后。</li><li>因为有数字签名，所以接收方需要获得发送方的公钥，发送方需要发送自己的数字证书。</li><li>因为需要传递对称密钥，所以需要数字信封，用接收方的公钥加密对称密钥。</li><li>接收方收到消息后，首先用私钥解密获得对称密钥，随后解密获得明文。用CA公钥验证证书的完整性，由此获得发送方的公钥，用其解密数字签名，确保消息没有被篡改。</li><li>满足了保密性和完整性。</li></ul></li></ul><p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027145220754.png" alt="image-20201027145220754"></p><h2 id="基于Hash的鉴别"><a href="#基于Hash的鉴别" class="headerlink" title="基于Hash的鉴别"></a>基于Hash的鉴别</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ul><li>直接Hash</li></ul><p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027151324589.png" alt="image-20201027151324589"></p><ul><li>与加密结合</li></ul><p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027151338394.png" alt="image-20201027151338394"></p><ul><li>结合公钥体制（数字签名）</li></ul><p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027151349653.png" alt="image-20201027151349653"></p><ul><li>结合对称密钥体制</li></ul><p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027151400579.png" alt="image-20201027151400579"></p><ul><li>加盐</li></ul><p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027151416972.png" alt="image-20201027151416972"></p><ul><li>大杂烩</li></ul><p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027151432750.png" alt="image-20201027151432750"></p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>根据安全水平<ul><li>弱无碰撞</li><li>强无碰撞</li></ul></li><li>根据是否使用密钥<ul><li>带私密密钥，此时称作MAC。</li><li>不带私密密钥，此时称为MDC。</li></ul></li></ul><h2 id="密钥管理与分配"><a href="#密钥管理与分配" class="headerlink" title="密钥管理与分配"></a>密钥管理与分配</h2><h3 id="密钥生命周期"><a href="#密钥生命周期" class="headerlink" title="密钥生命周期"></a>密钥生命周期</h3><ul><li>产生、存储、使用、更新、删除</li></ul><p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027152018368.png" alt="image-20201027152018368"></p><h3 id="对称密钥的分配"><a href="#对称密钥的分配" class="headerlink" title="对称密钥的分配"></a>对称密钥的分配</h3><ul><li>设立密钥分配中心KDC。</li><li>KDC给需要进行秘密通信的用户临时分配一个会话密钥。</li><li>KDC的登记用户在KDC的服务器上安装了自己与KDC进行通信的主密钥，可简称为密钥。</li></ul><p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027152326907.png" alt="image-20201027152326907"></p><h4 id="基于公钥体制的对称密钥分配"><a href="#基于公钥体制的对称密钥分配" class="headerlink" title="基于公钥体制的对称密钥分配"></a>基于公钥体制的对称密钥分配</h4><ul><li>公钥密码体制未必在通讯中直接使用，但却很适合用于对称密钥分配。</li></ul><p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027152457757.png" alt="image-20201027152457757"></p><p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027152509596.png" alt="image-20201027152509596"></p><h3 id="公钥体制的密钥分配"><a href="#公钥体制的密钥分配" class="headerlink" title="公钥体制的密钥分配"></a>公钥体制的密钥分配</h3><h4 id="公开发布"><a href="#公开发布" class="headerlink" title="公开发布"></a>公开发布</h4><p>用户将自己的公钥发给其他用户，一般将公钥附在消息上（PGP）。</p><ul><li>实现简单</li><li>容易假冒</li></ul><h4 id="公用目录表"><a href="#公用目录表" class="headerlink" title="公用目录表"></a>公用目录表</h4><p>建立一个公用的公钥动态目录表，由可信的实体建立、维护和发布。</p><ul><li>有一定的安全性</li><li>目录表容易受到攻击</li></ul><h4 id="公钥授权"><a href="#公钥授权" class="headerlink" title="公钥授权"></a>公钥授权</h4><p>在公钥目录表的基础上，由公钥管理机构为用户建立、维护和发布公钥目录表。</p><p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027155129036.png" alt="image-20201027155129036"></p><h4 id="公钥证书"><a href="#公钥证书" class="headerlink" title="公钥证书"></a>公钥证书</h4><p>用户通过公钥证书相互交换公钥，公钥证书由CA为用户建立。</p><p>公钥证书的数据项包括</p><ul><li>用户的公钥、用户身份标识和时间戳等。</li><li>所有数据项经CA的私钥签名后形成证书。</li></ul><p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027155335650.png" alt="image-20201027155335650"></p><p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027155414152.png" alt="image-20201027155414152"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍密码学的基础知识，包括公钥体制、数字签名、密钥分配等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Internet安全协议与分析" scheme="https://entropy2333.github.io/categories/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="数字签名" scheme="https://entropy2333.github.io/tags/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/"/>
    
      <category term="数字证书" scheme="https://entropy2333.github.io/tags/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/"/>
    
      <category term="公钥体制" scheme="https://entropy2333.github.io/tags/%E5%85%AC%E9%92%A5%E4%BD%93%E5%88%B6/"/>
    
      <category term="Hash鉴别" scheme="https://entropy2333.github.io/tags/Hash%E9%89%B4%E5%88%AB/"/>
    
      <category term="密钥分配" scheme="https://entropy2333.github.io/tags/%E5%AF%86%E9%92%A5%E5%88%86%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>Internet安全协议与分析（七）CSP</title>
    <link href="https://entropy2333.github.io/2020/10/25/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%83%EF%BC%89CSP/"/>
    <id>https://entropy2333.github.io/2020/10/25/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%83%EF%BC%89CSP/</id>
    <published>2020-10-25T06:04:55.000Z</published>
    <updated>2020-10-25T06:19:23.873Z</updated>
    
    <content type="html"><![CDATA[<p>介绍攻击结构性方法。</p><a id="more"></a><h2 id="攻击结构性方法"><a href="#攻击结构性方法" class="headerlink" title="攻击结构性方法"></a>攻击结构性方法</h2><p>从反面寻找协议的漏洞，如果能找到合适的攻击步骤，则说明协议有缺陷。</p><p>如果找不到攻击，不能说明协议是安全的，但安全性可以得到一定程度的保证。</p><ul><li>主体数据的有限性：通常只分析有限个主体实例</li><li>无法解决状态空间爆炸问题</li><li>无法揭示安全协议的内部机理</li></ul><h2 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h2><p>通信顺序进程（Communicating Sequential Processes）</p><ul><li>描述并发系统的消息交互</li><li>将协议的安全问题描述为CSP进行是否满足其CSP规约的问题，并用FDR对协议的性质进行分析与验证。</li></ul><h3 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h3><ul><li><p>事件</p><ul><li>一个典型的CSP事件形式为：c.i.j.m，包括信道c、消息源i、目的地j和消息m。</li></ul></li><li><p>信道</p><ul><li>不同事件类型看成不同信道，并规定它所传递的数据类型。</li></ul></li><li><p>进程</p><ul><li>包括执行状态中的一个动作（事件）以及动作结束后的状态。</li></ul><p><img src="/2020/10/25/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%83%EF%BC%89CSP/image-20201025141246384.png" alt="image-20201025141246384"></p></li><li><p>进程间选择 P▢Q</p><ul><li>表示在两个进程事件间的外部选择</li></ul><p><img src="/2020/10/25/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%83%EF%BC%89CSP/image-20201025141612756.png" alt="image-20201025141612756"></p></li><li><p>并行进程</p><p><img src="/2020/10/25/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%83%EF%BC%89CSP/image-20201025141658434.png" alt="image-20201025141658434"></p></li><li><p>重命名</p><p><img src="/2020/10/25/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%83%EF%BC%89CSP/image-20201025141716208.png" alt="image-20201025141716208"></p></li><li><p>条件结构</p><p><img src="/2020/10/25/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%83%EF%BC%89CSP/image-20201025141742620.png" alt="image-20201025141742620"></p></li><li><p>迹与精炼</p><p><img src="/2020/10/25/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%83%EF%BC%89CSP/image-20201025141807851.png" alt="image-20201025141807851"></p></li></ul><h3 id="协议目标的CSP描述"><a href="#协议目标的CSP描述" class="headerlink" title="协议目标的CSP描述"></a>协议目标的CSP描述</h3><p>看得头大，啥也记不住</p><p>TO BE COMPLETED</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍攻击结构性方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Internet安全协议与分析" scheme="https://entropy2333.github.io/categories/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="CSP" scheme="https://entropy2333.github.io/tags/CSP/"/>
    
  </entry>
  
  <entry>
    <title>Internet安全协议与分析（六）BAN</title>
    <link href="https://entropy2333.github.io/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/"/>
    <id>https://entropy2333.github.io/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/</id>
    <published>2020-10-19T06:33:15.000Z</published>
    <updated>2020-10-25T07:07:14.742Z</updated>
    
    <content type="html"><![CDATA[<p>介绍基于推理结构性方法。</p><a id="more"></a><h2 id="安全协议的形式化分析"><a href="#安全协议的形式化分析" class="headerlink" title="安全协议的形式化分析"></a>安全协议的形式化分析</h2><ul><li>目前的技术主要用于对密钥正确的认证。</li><li>安全协议的形式化有助于减轻协议设计者的工作量<ul><li>界定安全协议的边界，即协议系统与其运行环境的界面。</li><li>更准确地描述安全协议的行为。</li><li>更准确地定义安全协议的特性。</li><li>证明安全协议满足其说明，以及证明安全协议在什么条件下不能满足其说明。</li></ul></li></ul><h3 id="逻辑—推理结构性方法简介"><a href="#逻辑—推理结构性方法简介" class="headerlink" title="逻辑—推理结构性方法简介"></a>逻辑—推理结构性方法简介</h3><ul><li>运用逻辑系统从用户接收和发送的消息出发，通过一系列的推理公理推证协议是否满足其安全说明。</li><li>典型：BAN逻辑、Kailer逻辑、RV逻辑。</li><li>特点<ul><li>简洁直观，易于使用。</li><li>理想化方法。分析协议之前对协议进行形式化处理，依赖经验。</li><li>使用假设和推理规则。<ul><li>假设不正确，不能得到正确的信念。</li><li>公理和推理规则是否合理和完备也影响性能。</li></ul></li></ul></li></ul><h2 id="BAN逻辑系统"><a href="#BAN逻辑系统" class="headerlink" title="BAN逻辑系统"></a>BAN逻辑系统</h2><ul><li>定义：基于主体知识和信念推理的模态逻辑。</li><li>过程：通过推导主体是否能够从接收到的消息中获得信念来判断协议是否能够达到认证目标。</li></ul><h3 id="常用符号"><a href="#常用符号" class="headerlink" title="常用符号"></a>常用符号</h3><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/image-20201019144255278.png" alt="image-20201019144255278"></p><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/image-20201019144302408.png" alt="image-20201019144302408"></p><h3 id="推理规则"><a href="#推理规则" class="headerlink" title="推理规则"></a>推理规则</h3><h4 id="消息意义规则"><a href="#消息意义规则" class="headerlink" title="消息意义规则"></a>消息意义规则</h4><ul><li>从加密消息所使用的密钥以及消息中包含的秘密来推断消息发送者的身份</li></ul><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/image-20201019144714766.png" alt="image-20201019144714766"></p><h4 id="随机数验证规则"><a href="#随机数验证规则" class="headerlink" title="随机数验证规则"></a>随机数验证规则</h4><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/image-20201019144948197.png" alt="image-20201019144948197"></p><h4 id="仲裁规则"><a href="#仲裁规则" class="headerlink" title="仲裁规则"></a>仲裁规则</h4><ul><li>拓展主体的推知能力，使主体可以基于已有信仰上推知新的信仰。</li></ul><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/image-20201019145140729.png" alt="image-20201019145140729"></p><h4 id="信念规则"><a href="#信念规则" class="headerlink" title="信念规则"></a>信念规则</h4><ul><li>反映信念在消息的级联与分割的不同操作中的一致性以及信仰在此类操作中的传递性。</li></ul><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/image-20201019145246885.png" alt="image-20201019145246885"></p><h4 id="接收规则"><a href="#接收规则" class="headerlink" title="接收规则"></a>接收规则</h4><ul><li>定义了主体在协议运行中获取消息</li></ul><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/image-20201019145343321.png" alt="image-20201019145343321"></p><h4 id="新鲜规则"><a href="#新鲜规则" class="headerlink" title="新鲜规则"></a>新鲜规则</h4><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/image-20201019145354518.png" alt="image-20201019145354518"></p><h4 id="传递规则"><a href="#传递规则" class="headerlink" title="传递规则"></a>传递规则</h4><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/image-20201019145402495.png" alt="image-20201019145402495"></p><h3 id="若干假设"><a href="#若干假设" class="headerlink" title="若干假设"></a>若干假设</h3><h4 id="时间假设"><a href="#时间假设" class="headerlink" title="时间假设"></a>时间假设</h4><ul><li>current-time：起始于本次协议运行的开始阶段</li><li>past-time：current-time之前的时间</li><li>如果某一观点在协议开始时是成立的，那么在整个current-time中也是成立的，但是在past-time中成立的观点在current-time中却并不一定成立。</li></ul><h4 id="密钥假设"><a href="#密钥假设" class="headerlink" title="密钥假设"></a>密钥假设</h4><ul><li>密钥不能从密文中推导出来。</li><li>不拥有正确密钥不能解密报文。</li><li>主体能够知道他是否正确地使用了解密密钥。正确的密钥解密得到的明文有意义，错误的密钥解密得到的明文没有意义。</li></ul><h4 id="主体假设"><a href="#主体假设" class="headerlink" title="主体假设"></a>主体假设</h4><ul><li>假设参与协议运行的主体都是诚实的。</li></ul><h4 id="自身消息可识别假设"><a href="#自身消息可识别假设" class="headerlink" title="自身消息可识别假设"></a>自身消息可识别假设</h4><ul><li>假设接收方能分辨接收到的消息是否为自己发送过的消息。使得消息含义规则的成立有合理性。</li></ul><h3 id="应用BAN逻辑"><a href="#应用BAN逻辑" class="headerlink" title="应用BAN逻辑"></a>应用BAN逻辑</h3><ul><li>对协议进行理想化预处理（初始化）</li><li>给出协议初始状态及其所基于的假设。</li><li>形式化说明协议将达成的安全目标。</li><li>运用公理和推理规则以及协议会话事实和假设，从协议的开始进行推证直至验证协议是否满足最终运行目标。</li></ul><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/image-20201019150350421.png" alt="image-20201019150350421"></p><h4 id="实例：NS协议漏洞"><a href="#实例：NS协议漏洞" class="headerlink" title="实例：NS协议漏洞"></a>实例：NS协议漏洞</h4><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/image-20201019150426012.png" alt="image-20201019150426012"></p><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/image-20201019150432923.png" alt="image-20201019150432923"></p><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/image-20201019150438422.png" alt="image-20201019150438422"></p><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/image-20201019150445257.png" alt="image-20201019150445257"></p><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/image-20201019150451862.png" alt="image-20201019150451862"></p><p>goodkey = skey + fresh</p><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/image-20201019150458530.png" alt="image-20201019150458530"></p><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/image-20201019150504901.png" alt="image-20201019150504901"></p><h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><ul><li>省略掉对于推知主体信仰无用部分，如明文。</li><li>协议的理想化过于依赖于分享者的直觉，使得原始协议与理想化协议间存在语义鸿沟。</li><li>协议的理想化是将协议过程语言中对协议主体行为的描述解释为用逻辑语言描述的主体的知识和信仰，并以此来表示协议说明的语义。现有的逻辑形式化分析系统很难解决此问题。</li><li>BAN证明没有问题，并不能保证该协议没有问题。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍基于推理结构性方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Internet安全协议与分析" scheme="https://entropy2333.github.io/categories/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="BAN" scheme="https://entropy2333.github.io/tags/BAN/"/>
    
  </entry>
  
  <entry>
    <title>Internet安全协议与分析（五）Kerberos</title>
    <link href="https://entropy2333.github.io/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89Kerberos/"/>
    <id>https://entropy2333.github.io/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89Kerberos/</id>
    <published>2020-10-19T05:59:00.000Z</published>
    <updated>2020-10-28T08:25:45.205Z</updated>
    
    <content type="html"><![CDATA[<p>介绍Kerberos协议。</p><a id="more"></a><h2 id="密钥管理问题"><a href="#密钥管理问题" class="headerlink" title="密钥管理问题"></a>密钥管理问题</h2><p>所有的密码系统都存在这样的问题：如何安全/可靠地分配密钥。理想的情况是，密钥分配协议应该得到形式化验证。</p><h3 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h3><ul><li>用户只需要登录一次，就可以访问多个系统，不需要记忆多个口令密码。</li><li>优点<ul><li>用户可以快速访问网络，提高工作效率，也能帮助提高系统的安全性。</li><li>有利于进行账户密码管理、用户审计。</li><li>方便进行企业应用部署。</li></ul></li></ul><h2 id="Kerberos认证服务协议"><a href="#Kerberos认证服务协议" class="headerlink" title="Kerberos认证服务协议"></a>Kerberos认证服务协议</h2><ul><li>提供一个在客户端跟服务器端之间或服务器与服务器之间的身份验证机制（并且是相互的身份验证机制）·</li><li>解决的问题<ul><li>在公开的分布式环境中，工作站上的用户希望访问分布在网络中的服务器上的服务。</li><li>服务器希望能够限制授权用户的访问，并对服务请求进行鉴别。</li></ul></li></ul><h3 id="Kerberos的加密体制"><a href="#Kerberos的加密体制" class="headerlink" title="Kerberos的加密体制"></a>Kerberos的加密体制</h3><ul><li>Kerberos提供一个中心认证服务器，提供用户和服务器之间的认证服务。</li><li>采用传统加密算法，<strong>无公钥体制</strong>。</li><li>常用版本：Kerberos Version 4 和 Kerberos Version 5</li></ul><h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><ul><li>在分布式的client/server体系结构中，采用Kerberos服务器提供认证服务。</li><li>总体方案是提供一个可信第三方的认证服务。<ul><li>用tickets验证</li><li>避免本地保存密码和在互联网上传输密码</li><li>包含可信第三方</li><li>使用对称加密</li><li>客户端与服务器之间能够相互验证</li></ul></li></ul><h3 id="Kerberos-Version-4"><a href="#Kerberos-Version-4" class="headerlink" title="Kerberos Version 4"></a>Kerberos Version 4</h3><ul><li>引入可信第三方的认证服务，基于Needham &amp; Schroeder协议。</li><li>采用DES加密算法，提供认证服务。</li></ul><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>Principal<ul><li>安全个体，被认证的个体，有名字和口令。</li></ul></li><li>KDC<ul><li>密钥分发中心，提供票据和临时的会话密钥。</li></ul></li><li>Ticket<ul><li>用户可以用它向服务器表明身份，包含客户标识、会话密钥、时间戳等信息。其中的大多数信息被加密，密钥为服务器的密钥。</li></ul></li><li>Authenticator<ul><li>包含最近产生的信息，需要用到会话密钥。</li></ul></li><li>Credentials<ul><li>票据加上会话密钥</li></ul></li><li>Authentication Server(AS)<ul><li>通过long-term key认证客户</li><li>给予客户ticket granting ticket和short-term key</li><li><strong>认证服务</strong></li></ul></li><li>Ticket Granting Server(TGS)<ul><li>通过short-term key和ticket granting ticket认证客户。</li><li>TGS发放tickets给客户以访问其他服务器。</li><li><strong>授权与访问控制服务</strong></li></ul></li></ul><p>这样做的动机</p><ul><li>将认证与授权在逻辑上分离</li><li>设置不同的生命周期<ul><li>TGT通常10h，ST通常5min。</li><li>方便客户，降低密钥的暴露时间。</li></ul></li></ul><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89Kerberos/image-20201019141737715.png" alt="image-20201019141737715"></p><h4 id="认证服务交换：获得TGT"><a href="#认证服务交换：获得TGT" class="headerlink" title="认证服务交换：获得TGT"></a>认证服务交换：获得TGT</h4><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89Kerberos/image-20201019141857995.png" alt="image-20201019141857995"></p><h4 id="票据许可服务交换：获得ST"><a href="#票据许可服务交换：获得ST" class="headerlink" title="票据许可服务交换：获得ST"></a>票据许可服务交换：获得ST</h4><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89Kerberos/image-20201019141907104.png" alt="image-20201019141907104"></p><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89Kerberos/image-20201019141920821.png" alt="image-20201019141920821"></p><h4 id="客户-服务器认证交换：获得服务"><a href="#客户-服务器认证交换：获得服务" class="headerlink" title="客户/服务器认证交换：获得服务"></a>客户/服务器认证交换：获得服务</h4><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89Kerberos/image-20201019141931124.png" alt="image-20201019141931124"></p><h4 id="Kerberos和多个域"><a href="#Kerberos和多个域" class="headerlink" title="Kerberos和多个域"></a>Kerberos和多个域</h4><ul><li>完整的Kerberos环境包括Kerberos服务器、一组工作站和一组应用服务器<ul><li>所有用户和服务器均在Kerberos服务器上注册。</li><li>Kerberos服务器必须在数据库中拥有所有用户的ID和口令散列表。</li><li>Kerberos服务器必须与每一个服务器之间共享一个保密密钥。</li></ul></li><li>对于不同的域<ul><li>每个辖区的Kerberos服务器与其他辖区的Kerberos服务器之间共享一个保密密钥，两个服务器互相注册。</li></ul></li></ul><h4 id="跨域认证"><a href="#跨域认证" class="headerlink" title="跨域认证"></a>跨域认证</h4><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89Kerberos/image-20201019142401641.png" alt="image-20201019142401641"></p><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89Kerberos/image-20201019142408521.png" alt="image-20201019142408521"></p><h3 id="Kerberos-Version-5"><a href="#Kerberos-Version-5" class="headerlink" title="Kerberos Version 5"></a>Kerberos Version 5</h3><ul><li>标准化为RFC 1510</li><li>改进之处</li></ul><div class="table-container"><table><thead><tr><th></th><th>v4</th><th>v5</th></tr></thead><tbody><tr><td>加密算法</td><td>DES</td><td>扩展</td></tr><tr><td>网络协议地址</td><td>IP</td><td>OSI</td></tr><tr><td>票据生命周期</td><td>最大1280min</td><td>不限制</td></tr><tr><td>认证转发</td><td></td><td>允许服务器在事务中代表客户端访问另一台服务器</td></tr></tbody></table></div><ul><li>双重加密<ul><li>V4中的票据被重复加密</li></ul></li><li>消息重放<ul><li>AS-&gt;Client和TGS-&gt;Client消息在票据生命周期中或可被重放，V5采用新鲜数。</li><li>采用同一票据的多个cs连接使用相同的会话密钥，因而会遭受重放，<strong>V5使用subkey机制</strong>。</li></ul></li></ul><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89Kerberos/image-20201028140902276.png" alt="image-20201028140902276"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>认证方法<ul><li>本地机器录入密码</li><li>经由中央KDC认证</li><li>网上不传输密码</li></ul></li><li>单点登录<ul><li>KDC给予票据TGT</li><li>TGT可以用于获取其他的服务票据</li></ul></li><li>优点<ul><li>密码不容易被窃听</li><li>密码不在网上传输</li><li>密码猜测更困难</li><li>单点登录<ul><li>便捷，不用记忆多个口令。</li></ul></li><li>票据被盗之后难以使用，因为需要配合认证头来使用。</li></ul></li></ul><h2 id="Windows下的Kerberos应用"><a href="#Windows下的Kerberos应用" class="headerlink" title="Windows下的Kerberos应用"></a>Windows下的Kerberos应用</h2><ul><li>Windows 2000中代替了NTLM<ul><li>支持公钥加密来保护client/AS消息</li><li>允许使用基于smart cards的认证</li><li>使用了Kerberos数据授权字段</li><li>传递Win2K访问控制权限</li><li>源于Active Directory，以SIDs的形式。</li><li>消息格式公开，单为微软专有。</li></ul></li></ul><h3 id="Windows下域登录的机理"><a href="#Windows下域登录的机理" class="headerlink" title="Windows下域登录的机理"></a>Windows下域登录的机理</h3><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89Kerberos/image-20201028142153918.png" alt="image-20201028142153918"></p><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89Kerberos/image-20201028142208733.png" alt="image-20201028142208733"></p><h4 id="开始步骤"><a href="#开始步骤" class="headerlink" title="开始步骤"></a>开始步骤</h4><ul><li>CTRL + ALT + DEL</li><li>Winlogon service &amp; GINA (MSGINA.DLL)</li><li>用户输入被转到LSA</li><li>LSA加密缓存并经有Kerberos SSP和KDC交互</li></ul><h4 id="交互过程"><a href="#交互过程" class="headerlink" title="交互过程"></a>交互过程</h4><ul><li>LSA向KDC发送KRB_AS_REQ消息<ul><li>包括主体名称Alice和域名，加密密钥基于Alice口令生成。</li></ul></li><li>KDC返回KRB_AS_REO消息<ul><li>包括会话密钥、TGT、授权数据（SID）。</li></ul></li><li>LSA向KDC发送KRB_TGS_REQ消息<ul><li>包括目标计算机名Bob、目标计算级域名、TGT、认证头。</li></ul></li><li>KDC返回KRB_TGS_REP消息<ul><li>包括会话密钥（被Alice与KDC的会话密钥加密）、会话票据（被Bob和KDC的会话密钥加密）</li><li>会话票据包括Bob和Alice的会话密钥和TGT中的授权数据。</li></ul></li></ul><h4 id="组装本地令牌"><a href="#组装本地令牌" class="headerlink" title="组装本地令牌"></a>组装本地令牌</h4><ul><li>收到Alice的会话票据后，LSA解密并提取出授权数据。</li><li>查询本地SAM数据库，检查Alice是否属于本地安全组及其可能被授予的特权。</li><li>若有，则将所查询得到的SIDs加入授权数据的列表，根据此构造访问令牌，将令牌句柄和Alice会话的ID，确认返回给Winlogon。</li></ul><h4 id="进入系统"><a href="#进入系统" class="headerlink" title="进入系统"></a>进入系统</h4><ul><li>Winlogon创建窗口和桌面对象并且附带令牌，启动Shell。</li><li>Alice的访问令牌被其进程所继承。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍Kerberos协议。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Internet安全协议与分析" scheme="https://entropy2333.github.io/categories/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Kerberos" scheme="https://entropy2333.github.io/tags/Kerberos/"/>
    
  </entry>
  
  <entry>
    <title>Internet安全协议与分析（四）PGP</title>
    <link href="https://entropy2333.github.io/2020/10/17/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89PGP/"/>
    <id>https://entropy2333.github.io/2020/10/17/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89PGP/</id>
    <published>2020-10-17T07:08:41.000Z</published>
    <updated>2020-10-28T02:56:22.270Z</updated>
    
    <content type="html"><![CDATA[<p>介绍PGP协议。</p><a id="more"></a><h2 id="电子邮件概述"><a href="#电子邮件概述" class="headerlink" title="电子邮件概述"></a>电子邮件概述</h2><ul><li>电子邮件不是一种端到端的服务，而是一种<strong>存储转发式</strong>的服务。</li><li>一个完整的电子邮件系统包括三个主要成分<ul><li>客户端用户代理MUA（mail user agent）</li><li>邮件传输代理MTA（mail transfer agent）</li><li>邮件投递代理MDA（mail delivery agent）</li></ul></li><li>电子邮件相关协议<ul><li>SMTP、POP3、IMAP、MIME</li></ul></li></ul><h3 id="电子邮件系统安全问题"><a href="#电子邮件系统安全问题" class="headerlink" title="电子邮件系统安全问题"></a>电子邮件系统安全问题</h3><ul><li>匿名转发<ul><li>发件人隐瞒自己的电子邮箱地址和其他信息</li><li>用户必须使用邮件加密和数字签名技术</li></ul></li><li>电子邮件欺骗<ul><li>假冒一个用户身份给其他用户发送邮件</li><li>通过身份认证避免邮件欺骗</li></ul></li><li>邮件炸弹和垃圾邮件<ul><li>安装过滤器，预先检查发件人资料。</li></ul></li><li>邮件病毒<ul><li>通过预杀毒防止病毒的传播</li></ul></li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>端到端的安全电子邮件技术<ul><li>S/MIME和PGP，<strong>一般只对信体进行加密和签名，而信头必须保证原封不动</strong>。</li></ul></li><li>要求信头在传输过程中也保密，使用传输层技术作为后盾<ul><li>使用SSL SMTP和SSL POP</li><li>使用VPN或其他IP通道技术</li></ul></li><li>邮件服务器本身安全可靠</li></ul><h2 id="PGP"><a href="#PGP" class="headerlink" title="PGP"></a>PGP</h2><ul><li>Pretty Good Privacy</li></ul><p><img src="/2020/10/17/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89PGP/image-20201017152042892.png" alt="image-20201017152042892"></p><h3 id="PGP数字签名与认证"><a href="#PGP数字签名与认证" class="headerlink" title="PGP数字签名与认证"></a>PGP数字签名与认证</h3><ul><li>发送者<ul><li>产生消息M</li><li>使用SHA-1生成160位散列码H</li><li>使用私钥签名，并与M连接。</li></ul></li><li>接收方<ul><li>使用公钥解密，恢复散列码H。</li><li>计算M的散列码，与H比较，两者匹配则报文通过鉴别。</li></ul></li></ul><p><img src="/2020/10/17/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89PGP/image-20201017152232211.png" alt="image-20201017152232211"></p><h3 id="保密性操作"><a href="#保密性操作" class="headerlink" title="保密性操作"></a>保密性操作</h3><ul><li>发送者<ul><li>生成消息M和128位随机数作为会话密钥</li><li>使用CAST-128（或IDEA或3DES）加密报文</li><li>用接收者的公钥加密会话密钥，并与M连接。</li></ul></li><li>接收者<ul><li>使用私钥解密报文，恢复会话密钥。</li><li>用会话密钥解密恢复消息M。</li></ul></li></ul><p><img src="/2020/10/17/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89PGP/image-20201017152649242.png" alt="image-20201017152649242"></p><h3 id="PGP加密认证处理过程"><a href="#PGP加密认证处理过程" class="headerlink" title="PGP加密认证处理过程"></a>PGP加密认证处理过程</h3><p><img src="/2020/10/17/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89PGP/image-20201017153058600.png" alt="image-20201017153058600"></p><h3 id="PGP密钥环"><a href="#PGP密钥环" class="headerlink" title="PGP密钥环"></a>PGP密钥环</h3><ul><li>PGP在每个结点提供一对数据结构<ul><li>私钥环——存储该节点拥有的公开/私有密钥对</li><li>公钥环——存储该节点知道的其他所有用户的公开密钥</li></ul></li></ul><p><img src="/2020/10/17/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89PGP/image-20201017153356367.png" alt="image-20201017153356367"></p><h3 id="信任网"><a href="#信任网" class="headerlink" title="信任网"></a>信任网</h3><ul><li>通过自己的数字签名进行确认</li><li>通过自己完全信任的人的数字签名进行确认</li><li>通过自己有限信任的多个人的数字签名进行确认</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍PGP协议。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Internet安全协议与分析" scheme="https://entropy2333.github.io/categories/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="PGP" scheme="https://entropy2333.github.io/tags/PGP/"/>
    
  </entry>
  
  <entry>
    <title>Internet安全协议与分析（三）SET</title>
    <link href="https://entropy2333.github.io/2020/10/17/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89SET/"/>
    <id>https://entropy2333.github.io/2020/10/17/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89SET/</id>
    <published>2020-10-17T06:01:14.000Z</published>
    <updated>2020-10-27T13:03:32.994Z</updated>
    
    <content type="html"><![CDATA[<p>介绍SET协议。</p><a id="more"></a><h2 id="电子商务安全"><a href="#电子商务安全" class="headerlink" title="电子商务安全"></a>电子商务安全</h2><h3 id="电子交易的主要模式"><a href="#电子交易的主要模式" class="headerlink" title="电子交易的主要模式"></a>电子交易的主要模式</h3><h4 id="支付系统无安全措施"><a href="#支付系统无安全措施" class="headerlink" title="支付系统无安全措施"></a>支付系统无安全措施</h4><p><img src="/2020/10/17/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89SET/image-20201017140449640.png" alt="image-20201017140449640"></p><ul><li>风险由商家承担</li><li>商家完全掌握用户的信用卡信息</li><li>信用卡信息的传递无安全保障</li></ul><h4 id="通过第三方代理人支付"><a href="#通过第三方代理人支付" class="headerlink" title="通过第三方代理人支付"></a>通过第三方代理人支付</h4><p><img src="/2020/10/17/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89SET/image-20201017140544212.png" alt="image-20201017140544212"></p><ul><li>用户账户的开设不通过网络</li><li>信用卡信息不在开放的网络上传送</li><li>通过电子邮件来确认用户身份</li><li>商家自由度大，风险小</li><li>支付是通过双方都信任的第三方(经纪人)完成的</li></ul><h4 id="数字现金支付"><a href="#数字现金支付" class="headerlink" title="数字现金支付"></a>数字现金支付</h4><p><img src="/2020/10/17/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89SET/image-20201017140656864.png" alt="image-20201017140656864"></p><ul><li>银行和商家之间应有协议和授权关系</li><li>用户、商家和数字现金的发行都需要使用数字现金软件</li><li>适用于小额交易</li><li>身份验证是由数字现金本身完成的</li><li>数字现金的发行负责用户和商家之间实际资金的转移</li><li>数字现金与普通现金一样，可以存、取和转让</li></ul><h4 id="简单加密支付"><a href="#简单加密支付" class="headerlink" title="简单加密支付"></a>简单加密支付</h4><p><img src="/2020/10/17/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89SET/image-20201017140746511.png" alt="image-20201017140746511"></p><ul><li>信用卡等关键信息需要加密</li><li>使用对称和非对称加密技术</li><li>可能要启用身份认证系统</li><li>以数字签名确认信息的真实性</li><li>需要业务服务器和服务软件的支持</li></ul><h4 id="安全电子交易SET支付"><a href="#安全电子交易SET支付" class="headerlink" title="安全电子交易SET支付"></a>安全电子交易SET支付</h4><p><img src="/2020/10/17/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89SET/image-20201017140822317.png" alt="image-20201017140822317"></p><ul><li>SET协议的目标<ul><li>信息在互联网上安全传输，不能被窃听或篡改</li><li>用户资料要妥善保护，商家只能看到订货信息，看不到用户的账户信息</li><li>持卡人和商家相互认证，以确定对方身份</li><li>软件遵循相同的协议和消息格式，具有兼容性和互操作性</li></ul></li></ul><h2 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h2><ul><li>Secure Electronic Transaction</li><li>Visa和MasterCard研发的专门用于Internet上安全信用卡交易的协议</li></ul><h3 id="交易中的主体"><a href="#交易中的主体" class="headerlink" title="交易中的主体"></a>交易中的主体</h3><p><img src="/2020/10/17/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89SET/image-20201027203155887.png" alt="image-20201027203155887"></p><h3 id="主体证书"><a href="#主体证书" class="headerlink" title="主体证书"></a>主体证书</h3><ul><li>协议各方持有名字和密钥对</li><li>身份使用X.509 V3证书和密钥关联</li></ul><p><img src="/2020/10/17/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89SET/image-20201017141215885.png" alt="image-20201017141215885"></p><h3 id="SET电子支付的流程"><a href="#SET电子支付的流程" class="headerlink" title="SET电子支付的流程"></a>SET电子支付的流程</h3><ul><li>客户在发卡行开户</li><li>客户持有银行签发的X.509 V3证书</li><li>商家持有两个同类品牌的证书X.509 V3<ul><li>一个用于签名，一个用于密钥交换</li></ul></li><li>客户向商家发订单</li><li>商家发送证书向客户出示自己身份</li></ul><h3 id="SET双重数字签名"><a href="#SET双重数字签名" class="headerlink" title="SET双重数字签名"></a>SET双重数字签名</h3><ul><li>将两个消息连接在一起，这两个消息面对的对象不同。<ul><li>Order Information：客户给商家</li><li>Payment Information：客户给银行</li></ul></li><li>商家不需要卡信息，银行需要订单信息，保护客户隐私。</li></ul><p><img src="/2020/10/17/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89SET/image-20201017141600864.png" alt="image-20201017141600864"></p><ul><li>商家收到OI校验签名</li><li>银行收到PI校验签名</li><li>客户连接OI和PI，证明该关联。</li></ul><p><img src="/2020/10/17/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89SET/image-20201017142528166.png" alt="image-20201017142528166"></p><h3 id="SET电子支付的流程-1"><a href="#SET电子支付的流程-1" class="headerlink" title="SET电子支付的流程"></a>SET电子支付的流程</h3><p><img src="/2020/10/17/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89SET/image-20201017142547541.png" alt="image-20201017142547541"></p><ul><li>客户发送订单和支付信息给商家</li><li>商家向支付网关请求支付授权</li><li>商家确认向客户订单</li><li>商家向客户提供商品或者服务</li><li>商家向支付网关请求支付</li></ul><h3 id="SET消息流"><a href="#SET消息流" class="headerlink" title="SET消息流"></a>SET消息流</h3><p><img src="/2020/10/17/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89SET/image-20201017142656233.png" alt="image-20201017142656233"></p><p><img src="/2020/10/17/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89SET/image-20201017142741943.png" alt="image-20201017142741943"></p><h4 id="支付过程初始化"><a href="#支付过程初始化" class="headerlink" title="支付过程初始化"></a>支付过程初始化</h4><p><img src="/2020/10/17/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89SET/image-20201017142801980.png" alt="image-20201017142801980"></p><ul><li>持卡人向商家发送初始请求，包括<ul><li>持卡人使用的语言，交易ID，交易卡类型</li></ul></li><li>商家接收初始请求，产生初始应答，对初始应答生成消息摘要，并进行数字签名，包括<ul><li>商家证书、网管证书、初始应答、消息摘要的数字签名等。</li></ul></li></ul><h4 id="购物请求"><a href="#购物请求" class="headerlink" title="购物请求"></a>购物请求</h4><p><img src="/2020/10/17/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89SET/image-20201017143046383.png" alt="image-20201017143046383"></p><ul><li>持卡人接收初始应答，检查商家证书和网关证书。用商家公钥解开数字签名，验证数据未被篡改，否则丢弃。</li><li>持卡人发出购物请求，包含了真正的交易行为，包括<ul><li>发往商家的订单信息（OI）</li><li>通过商家转发往网关的支付信息（PI）</li></ul></li><li>通过双重数字签名将OI与PI进行关联。</li><li>PI被加密，商家只能看到OI。</li></ul><p><img src="/2020/10/17/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89SET/image-20201017143327440.png" alt="image-20201017143327440"></p><h4 id="商家验证"><a href="#商家验证" class="headerlink" title="商家验证"></a>商家验证</h4><p><img src="/2020/10/17/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89SET/image-20201017143352764.png" alt="image-20201017143352764"></p><ul><li>商家接受持卡人的购物请求，认证持卡人的证书。验证双重签名，看数据在传输过程中是否被篡改，若数据完整则处理订单信息，产生支付请求。</li><li>将支付请求用HASH生成摘要，并签名，网关收到后用商家公钥解密，并确认支付请求是此商家所发且在途中未被修改。生成对称密钥对支付请求加密，并用网关公钥加密形成数字信封。</li><li>将商家证书、支付请求密文、商家数字签名、数字信封和持卡人通过商家转发的：sign[H(OP)]、OI摘要、PI密文、持卡人数字信封、持卡人证书等发往支付网关。</li></ul><h4 id="支付网关认证过程"><a href="#支付网关认证过程" class="headerlink" title="支付网关认证过程"></a>支付网关认证过程</h4><ul><li>支付网关分别检查确认商家发来的数据和持卡人发来的数据</li><li>用HASH算法作用于支付请求，形成摘要，与商家发来的支付请求<br>摘要（解开数字签名所得）相比较，如果相同则表示数据完整，否<br>则丢弃数据</li><li>网关检查持卡人证书，然后用私钥打开持卡人数字信封，得到他的<br>帐号和对称密钥。用此对称密钥解开PI密文，得到PI，接着验证双<br>重签名，生成PI的摘要，与OI摘要相连接，再次生成摘要，其结果<br>与H (OP)(解双重签名所得)相比较，如果相同则数据完整，如果<br>不同则丢弃。</li><li>网关将信息发送往银行</li></ul><h4 id="收单银行处理"><a href="#收单银行处理" class="headerlink" title="收单银行处理"></a>收单银行处理</h4><ul><li>解密AuthReq</li><li>校验商家签名</li><li>解密来自于持卡人的PI</li><li>校验双重签名</li><li>从PI中抽取卡数据</li></ul><p>TO BE COMPLETED</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍SET协议。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Internet安全协议与分析" scheme="https://entropy2333.github.io/categories/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="SET" scheme="https://entropy2333.github.io/tags/SET/"/>
    
  </entry>
  
  <entry>
    <title>Internet安全协议与分析（二）SSL</title>
    <link href="https://entropy2333.github.io/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89SSL/"/>
    <id>https://entropy2333.github.io/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89SSL/</id>
    <published>2020-10-10T03:24:49.000Z</published>
    <updated>2020-10-27T12:26:56.954Z</updated>
    
    <content type="html"><![CDATA[<p>介绍SSL协议与WTLS协议 。<br><a id="more"></a></p><h2 id="不同协议层的安全"><a href="#不同协议层的安全" class="headerlink" title="不同协议层的安全"></a>不同协议层的安全</h2><p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89SSL/image-20201027193018383.png" alt="image-20201027193018383"></p><h2 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h2><p>1994年，由Netscape公司提出SSL，为HTTP提供安全连接。</p><h3 id="安全机制"><a href="#安全机制" class="headerlink" title="安全机制"></a>安全机制</h3><ul><li>机密性：使用对称密钥算法对传输的数据进行加密。</li><li>身份验证：基于证书利用数字签名对server和client进行身份验证。</li><li>消息完整性验证：使用MAC算法检验消息的完整性。</li></ul><h3 id="SSL版本"><a href="#SSL版本" class="headerlink" title="SSL版本"></a>SSL版本</h3><ul><li>SSL由Netscape公司设计，是用于web的安全传输协议。</li><li>IETF将SSL标准化，称为TLS，TLS1.0与SSL3.0差别非常小。</li><li>wap论坛在TLS基础上做了WTLS协议，以适应无线的特殊环境。</li></ul><h3 id="SSL的分层结构"><a href="#SSL的分层结构" class="headerlink" title="SSL的分层结构"></a>SSL的分层结构</h3><ul><li>上层协议<ul><li>SSL握手协议</li><li>SSL passowrd变化协议</li><li>SSL警告协议</li></ul></li><li>下层协议为SSL记录协议</li></ul><p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89SSL/image-20201027193738047.png" alt="image-20201027193738047"></p><h3 id="SSL基本过程"><a href="#SSL基本过程" class="headerlink" title="SSL基本过程"></a>SSL基本过程</h3><ul><li>建立会话</li><li>传输应用数据</li></ul><h3 id="连接-amp-会话"><a href="#连接-amp-会话" class="headerlink" title="连接&amp;会话"></a>连接&amp;会话</h3><ul><li><p>SSL连接</p><ul><li>点对点</li><li>连接是暂时的，每个连接和一个会话关联。</li></ul></li><li><p>SSL会话</p><ul><li>会话是在server和client之间的一个关联，由握手协议建立，定义了一组密码安全参数。</li><li>避免为每一个连接提供新的安全参数所需昂贵的协商代价。</li></ul></li><li><p>在任意一对通信主体之间，可以有多个安全连接。</p><p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89SSL/image-20201010113915965.png" alt="image-20201010113915965"></p></li></ul><h3 id="握手协议"><a href="#握手协议" class="headerlink" title="握手协议"></a>握手协议</h3><p>握手协议允许服务器和客户端相互验证，协商加密和MAC算法以及保密密钥。</p><p>握手协议的消息都含有以下三个字段</p><p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89SSL/image-20201010114509495.png" alt="image-20201010114509495"></p><h4 id="阶段1：建立安全能力"><a href="#阶段1：建立安全能力" class="headerlink" title="阶段1：建立安全能力"></a>阶段1：建立安全能力</h4><ul><li>SSL握手第一阶段启动逻辑连接，建立这个连接的安全能力。</li><li>client向server发送client hello消息<ul><li>支持的协议版本，比如TLS 1.0。</li><li>客户端生成的随机数，用于生成“对话密钥”。</li><li>支持的加密方法，比如RSA。</li><li>支持的压缩方法。</li></ul></li><li>server向client发送server hello消息<ul><li>确认使用的协议版本，如果版本不一致则关闭加密通信。</li><li>服务器生成的随机数，用于生成“对话密钥”。</li><li>确认使用的加密方法。</li><li>服务器证书。</li></ul></li><li>此阶段后，client、server知道了以下内容<ul><li>SSL版本</li><li>密钥交换、信息验证和加密算法</li><li>压缩方法</li><li>密钥生成的两个随机数</li></ul></li></ul><p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89SSL/image-20201010114955273.png" alt="image-20201010114955273"></p><h4 id="阶段2：服务器鉴别与密钥交换"><a href="#阶段2：服务器鉴别与密钥交换" class="headerlink" title="阶段2：服务器鉴别与密钥交换"></a>阶段2：服务器鉴别与密钥交换</h4><ul><li>server发送证书，包含一个X.509证书，或一条证书链。</li><li>server发送server_key_exchange消息<ul><li>可选，服务器证书没有包含必需数据时发送。</li><li>包含签名，签名内容包括两个随机数以及服务器参数。</li></ul></li><li>server发送certificate_request消息<ul><li>非匿名server可以像client请求一个证书。</li><li>包含证书类型和CAs。</li></ul></li><li>服务器发送server_hello_done，等待应答。</li></ul><p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89SSL/image-20201010115349419.png" alt="image-20201010115349419"></p><h4 id="阶段3：客户机鉴别与密钥交换"><a href="#阶段3：客户机鉴别与密钥交换" class="headerlink" title="阶段3：客户机鉴别与密钥交换"></a>阶段3：客户机鉴别与密钥交换</h4><ul><li>client收到server_done消息后，检查server提供的证书，判断参数是否可以接收，如果没有问题就发送消息。</li><li>如果server请求证书，就发送certificate，若client没有证书，则发送no_certificate警告，然后发送client_key_exchange消息。</li><li>最后，client发送certificate_verify消息，包含一个签名，对第一条消息以来的所有握手消息的MAC值进行签名。</li></ul><p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89SSL/image-20201010115612373.png" alt="image-20201010115612373"></p><h4 id="阶段4：完成"><a href="#阶段4：完成" class="headerlink" title="阶段4：完成"></a>阶段4：完成</h4><ul><li>第四阶段建立起一个安全连接。</li><li>client发送change_cipher_spec消息，将协商得到的CipherSuite拷贝到当前连接的状态之中。</li><li>client用新的算法、密钥参数发送一个finished消息，检查密钥交换和鉴别过程是否已经成功。其中包括一个校验值，对所有以来的消息进行校验。</li><li>服务器同样发送change_cipher_spec和finished消息。</li><li>握手过程完成，client和server可以交换应用层数据。</li></ul><p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89SSL/image-20201010120038944.png" alt="image-20201010120038944"></p><h3 id="ChangeCipherSpec"><a href="#ChangeCipherSpec" class="headerlink" title="ChangeCipherSpec"></a>ChangeCipherSpec</h3><ul><li>在数据包中就是一个字节的数据，用于告知服务端，客户端已经切换到之前协商好的加密套件的状态，准备使用之前协商好的加密套件加密数据并传输。</li></ul><h3 id="记录协议"><a href="#记录协议" class="headerlink" title="记录协议"></a>记录协议</h3><p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89SSL/image-20201010132038339.png" alt="image-20201010132038339"></p><h3 id="警告协议"><a href="#警告协议" class="headerlink" title="警告协议"></a>警告协议</h3><p>当握手过程或者数据加密等操作出错或者发生异常情况时，向对方发出警告或中止当前连接。</p><h3 id="SSL的加密和认证算法"><a href="#SSL的加密和认证算法" class="headerlink" title="SSL的加密和认证算法"></a>SSL的加密和认证算法</h3><p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89SSL/image-20201010132259141.png" alt="image-20201010132259141"></p><p>认证算法采用X.509电子证书标准，通过RSA算法进行数字签名来实现。</p><h3 id="SSL安全性分析"><a href="#SSL安全性分析" class="headerlink" title="SSL安全性分析"></a>SSL安全性分析</h3><ul><li>鉴别机制<ul><li>客户端与服务器交换了证书</li></ul></li><li>加密机制<ul><li>对称加密保护数据传输，非对称加密协商会话密钥。</li></ul></li><li>完整性机制<ul><li>数据分组压缩后，产生MAC。</li></ul></li><li>抗重放攻击<ul><li>使用序列号，传输中被加密。</li></ul></li></ul><h3 id="SSL脆弱性分析"><a href="#SSL脆弱性分析" class="headerlink" title="SSL脆弱性分析"></a>SSL脆弱性分析</h3><ul><li>客户端假冒</li><li>无法提供基于UDP应用的安全保护</li><li>不能对抗通信流量分析</li><li>进程中主密钥泄露</li></ul><h2 id="WTLS"><a href="#WTLS" class="headerlink" title="WTLS"></a>WTLS</h2><ul><li>保证传输层安全，作为WAP协议栈的一个层次向上层提供安全传输服务接口。</li></ul><h3 id="提供的安全服务"><a href="#提供的安全服务" class="headerlink" title="提供的安全服务"></a>提供的安全服务</h3><ul><li>第一类服务：使用交换的公共密钥建立安全传输，使用对称算法加解密数据，检查数据完整性，可以建立安全通信的通道，但没有对通信双方的身份进行鉴别，</li><li>第二类服务：在第一类服务的基础上，可以交换服务器证书，完成对服务器的鉴别。</li><li>第三类服务：在第二类服务的基础上，可以交换客户端证书，对恶意的用户冒充也能抗击。</li></ul><h3 id="协议栈"><a href="#协议栈" class="headerlink" title="协议栈"></a>协议栈</h3><p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89SSL/image-20201027201909276.png" alt="image-20201027201909276"></p><h3 id="握手协议-1"><a href="#握手协议-1" class="headerlink" title="握手协议"></a>握手协议</h3><ul><li>和SSL一致？</li></ul><h3 id="记录协议-1"><a href="#记录协议-1" class="headerlink" title="记录协议"></a>记录协议</h3><p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89SSL/image-20201027202237703.png" alt="image-20201027202237703"></p><h3 id="告警协议"><a href="#告警协议" class="headerlink" title="告警协议"></a>告警协议</h3><ul><li>描述信息错误的严重程度及告警描述</li><li>警告、危急、致命</li></ul><h3 id="密钥交换"><a href="#密钥交换" class="headerlink" title="密钥交换"></a>密钥交换</h3><ul><li>共享密钥方法</li><li>RSA加密传输方法</li><li>DH密钥交换方法</li><li>EC-DH密钥交换方法<ul><li>椭圆曲线版本的DH密钥交换</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍SSL协议与WTLS协议 。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Internet安全协议与分析" scheme="https://entropy2333.github.io/categories/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="SSL" scheme="https://entropy2333.github.io/tags/SSL/"/>
    
      <category term="WTLS" scheme="https://entropy2333.github.io/tags/WTLS/"/>
    
  </entry>
  
  <entry>
    <title>Internet安全协议与分析（一）IPSec</title>
    <link href="https://entropy2333.github.io/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89IPSec/"/>
    <id>https://entropy2333.github.io/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89IPSec/</id>
    <published>2020-10-10T02:57:40.000Z</published>
    <updated>2020-10-27T10:48:53.721Z</updated>
    
    <content type="html"><![CDATA[<p>介绍IPSec协议与IKE协议 。<br><a id="more"></a></p><h2 id="IP安全问题"><a href="#IP安全问题" class="headerlink" title="IP安全问题"></a>IP安全问题</h2><p>IP协议从本质上就是不安全的，仅仅依靠IP头部的校验和字段无法保证IP包的安全。</p><p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89IPSec/image-20201027160509665.png" alt="image-20201027160509665"></p><h2 id="IPSec"><a href="#IPSec" class="headerlink" title="IPSec"></a>IPSec</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>IPSec旨在把安全机制引入IP协议，使用密码学方法支持机密性和认证性服务，确保公网上数据通信的可靠性和完整性。</p><p>IPSec对IPV4可选，对IPV6必须，由三种机制共同保障</p><ul><li>认证</li><li>信息机密性</li><li>密钥管理</li></ul><h3 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h3><p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89IPSec/image-20201027160857942.png" alt="image-20201027160857942"></p><p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89IPSec/image-20201027160944599.png" alt="image-20201027160944599"></p><p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89IPSec/image-20201027160958769.png" alt="image-20201027160958769"></p><p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89IPSec/image-20201027161058344.png" alt="image-20201027161058344"></p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="安全联盟（SA）"><a href="#安全联盟（SA）" class="headerlink" title="安全联盟（SA）"></a>安全联盟（SA）</h4><ul><li>Secure Association</li><li>是两个通信实体之间建立的一个简单单向协定</li><li>由SPI（Security Parameter Index）和目标地址组成</li><li>单个IPSec连接至少需要两个SA</li></ul><h4 id="安全关联数据库（SAD）"><a href="#安全关联数据库（SAD）" class="headerlink" title="安全关联数据库（SAD）"></a>安全关联数据库（SAD）</h4><ul><li>Secure Association Database</li><li>SAD包含了所有活跃的SA的所有参数信息</li><li>流出数据：会有一个SPD数据项包含指向某个SAD数据项的指针，SPD决定了一个给定的数据包究竟使用哪一个SA。</li><li>流入数据：由SAD决定如何对给定数据包做处理。</li></ul><h4 id="安全策略库（SPD）"><a href="#安全策略库（SPD）" class="headerlink" title="安全策略库（SPD）"></a>安全策略库（SPD）</h4><ul><li>Secure Policy Database</li><li>SPD用于为IPSec实现提供安全策略配置，指定哪些数据流必须经过IPSec的处理。</li></ul><h3 id="AH协议"><a href="#AH协议" class="headerlink" title="AH协议"></a>AH协议</h3><ul><li>Authentication Header</li><li>在每一个数据包上添加一个身份验证报头，包含一个带密钥的hash，提供了完整性保护。</li><li>不提供机密性保护。</li></ul><h4 id="传输模式"><a href="#传输模式" class="headerlink" title="传输模式"></a>传输模式</h4><ul><li>如果传送过程中经过NAT网关，源/目的IP将被改变，导致完整性验证失败。AH在传输模式下与NAT冲突。</li></ul><p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89IPSec/image-20201027162241877.png" alt="image-20201027162241877"></p><h4 id="隧道模式"><a href="#隧道模式" class="headerlink" title="隧道模式"></a>隧道模式</h4><ul><li>依旧与NAT冲突。</li></ul><p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89IPSec/image-20201027162746567.png" alt="image-20201027162746567"></p><h3 id="ESP协议"><a href="#ESP协议" class="headerlink" title="ESP协议"></a>ESP协议</h3><ul><li>将需要保护的数据加密后，封装在IP包中。</li></ul><h4 id="传输模式-1"><a href="#传输模式-1" class="headerlink" title="传输模式"></a>传输模式</h4><p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89IPSec/image-20201027162920657.png" alt="image-20201027162920657"></p><h4 id="隧道模式-1"><a href="#隧道模式-1" class="headerlink" title="隧道模式"></a>隧道模式</h4><p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89IPSec/image-20201027162952118.png" alt="image-20201027162952118"></p><h3 id="AH-vs-ESP"><a href="#AH-vs-ESP" class="headerlink" title="AH vs ESP"></a>AH vs ESP</h3><p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89IPSec/image-20201027163130692.png" alt="image-20201027163130692"></p><h2 id="IKE"><a href="#IKE" class="headerlink" title="IKE"></a>IKE</h2><p>​        IKE（Internet Key Exchange）因特网密钥交换协议，是IPSec的信令协议，为IPSec提供了自动协商交换密钥、建立安全联盟的服务，能够简化IPSec的使用和管理，大大简化IPSec的配置和维护工作。</p><h3 id="IKE与IPSec关系"><a href="#IKE与IPSec关系" class="headerlink" title="IKE与IPSec关系"></a>IKE与IPSec关系</h3><ul><li>IKE位于UDP之上，属于应用层协议。</li><li>IKE为IPSec协商建立SA，并将参数与密钥交给IPSec。</li><li>IPSec使用IKE建立的SA对IP报文加密或验证处理。</li><li>AH和ESP的协议号是51和50。</li></ul><p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89IPSec/image-20201010110531559.png" alt="image-20201010110531559" style="zoom:67%;"></p><h3 id="IKE的作用"><a href="#IKE的作用" class="headerlink" title="IKE的作用"></a>IKE的作用</h3><ul><li>降低手工配置的复杂度</li><li>SA和密钥定时更新</li><li>允许IPSec提供反重放服务</li><li>允许在端与端之间动态认证</li></ul><h3 id="IKE的协商过程"><a href="#IKE的协商过程" class="headerlink" title="IKE的协商过程"></a>IKE的协商过程</h3><h4 id="两个阶段"><a href="#两个阶段" class="headerlink" title="两个阶段"></a>两个阶段</h4><ul><li>阶段一：在网络上建立IKE SA，为阶段二提供保护和快速协商。通过协商创建一个通信信道，并对其进行认证，为通信提供机密性、消息完整性以及消息源认证服务。</li><li>阶段二：在IKE SA的保护下完成IPSec的协商。</li></ul><h4 id="交换信息"><a href="#交换信息" class="headerlink" title="交换信息"></a>交换信息</h4><ul><li>SA交换，协商确认有关安全策略的过程。</li><li>密钥交换，交换Diffie-Hellman公共值和辅助数据，产生加密物。</li><li>ID交换和验证数据交换，进行身份验证和对整个SA交换进行验证。</li></ul><h4 id="阶段一协商过程"><a href="#阶段一协商过程" class="headerlink" title="阶段一协商过程"></a>阶段一协商过程</h4><p>双方建立了一个已通过身份验证和安全保护的通道，此阶段建立了一个ISAKMP。</p><p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89IPSec/image-20201010111251530.png" alt="image-20201010111251530" style="zoom: 80%;"></p><ul><li><p>两种协商模式</p><ul><li>主模式协商<ul><li>适合两设备的公网IP固定，实现设备之间点对点的环境。</li></ul></li></ul><p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89IPSec/image-20201010111946997.png" alt="image-20201010111946997"></p><ul><li>野蛮模式协商</li></ul><p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89IPSec/image-20201010111956705.png" alt="image-20201010111956705"></p></li></ul><p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89IPSec/image-20201010112010405.png" alt="image-20201010112010405"></p><h4 id="阶段二协商过程"><a href="#阶段二协商过程" class="headerlink" title="阶段二协商过程"></a>阶段二协商过程</h4><ul><li>使用“快速模式”交换，实现两个主要功能<ul><li>协商安全参数保护数据连接</li><li>周期性地更新密钥信息</li></ul></li><li>协商出IPSec单向SA，保护数据流。</li><li>协商过程受第一阶段ISAKMP/IKE SA保护。</li></ul><p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89IPSec/image-20201010112031723.png" alt="image-20201010112031723" style="zoom:80%;"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍IPSec协议与IKE协议 。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Internet安全协议与分析" scheme="https://entropy2333.github.io/categories/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="IPSec" scheme="https://entropy2333.github.io/tags/IPSec/"/>
    
      <category term="IKE" scheme="https://entropy2333.github.io/tags/IKE/"/>
    
  </entry>
  
</feed>
