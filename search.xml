<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CV入门（一）安装detectron2</title>
    <url>/2020/08/22/CV%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%E5%AE%89%E8%A3%85detectron2/</url>
    <content><![CDATA[<p>在windows 10系统上安装detectron2。</p>
<a id="more"></a>
<h2 id="环境依赖"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖</h2><p>给出自己的环境，低版本未测试。</p>
<ul>
<li>Python 3.7.2</li>
<li>Pytorch 1.6</li>
<li>pycocotools 2.0</li>
<li>CUDA 10.2</li>
<li>VS 2019 Community</li>
</ul>
<h3 id="安装-CUDA"><a href="#安装-CUDA" class="headerlink" title="安装 CUDA"></a>安装 CUDA</h3><p>进入<a href="https://developer.nvidia.com/cuda-downloads">官网</a>，按部就班安装，<a href="https://blog.csdn.net/qq_37296487/article/details/83028394">参考教程</a>。</p>
<p>cmd输入如下命令，测试CUDA是否安装成功。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvcc -V</span><br></pre></td></tr></table></figure>
<h3 id="安装-Pytorch"><a href="#安装-Pytorch" class="headerlink" title="安装 Pytorch"></a>安装 Pytorch</h3><p>python和git这些基本的就不提了，介绍一下pytorch的安装。</p>
<p>进入<a href="https://pytorch.org/">pytorch官网</a>，选择相对应的版本，使用pip直接安装。</p>
<p><img src="/2020/08/22/CV%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%E5%AE%89%E8%A3%85detectron2/1.png" alt></p>
<p>测试Pytorch是否安装成功。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch, torchvision</span><br><span class="line">print(torch.__version__, torch.cuda.is_available())</span><br></pre></td></tr></table></figure>
<h3 id="安装-VS-2019"><a href="#安装-VS-2019" class="headerlink" title="安装 VS 2019"></a>安装 VS 2019</h3><p>进入<a href="https://visualstudio.microsoft.com/zh-hans/downloads/">vs官网</a>，选择community版本进行下载。</p>
<p>下载完成后，先不着急运行安装程序，按<a href="https://www.loongten.com/2019/06/18/vs2019/">博客</a>将安装目录迁移到非系统盘（C盘实在是装不下了）。</p>
<p>完成后，运行安装程序，选择C++组件即可，其他组件看个人需求选择。</p>
<h3 id="安装-pycocotools"><a href="#安装-pycocotools" class="headerlink" title="安装 pycocotools"></a>安装 pycocotools</h3><p><a href="https://github.com/cocodataset/cocoapi">原版</a>的pycocotools不支持windows，需要使用<a href="https://github.com/philferriere/cocoapi">修改版</a>。</p>
<p>可通过如下命令安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/philferriere/cocoapi.git</span><br><span class="line"><span class="built_in">cd</span> PythonAPI</span><br><span class="line">python setup.py build_ext --inplace</span><br><span class="line">python setup.py build_ext install</span><br></pre></td></tr></table></figure>
<p>或者直接</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install git+https://github.com/philferriere/cocoapi.git<span class="comment">#subdirectory=PythonAPI</span></span><br></pre></td></tr></table></figure>
<p>出现Successfully installed pycocotools-2.0即为安装成功。</p>
<h3 id="安装-detectron2"><a href="#安装-detectron2" class="headerlink" title="安装 detectron2"></a>安装 detectron2</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/facebookresearch/detectron2.git</span><br></pre></td></tr></table></figure>
<p>修改文件 setup.py，注释掉</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;pycocotools&gt;=2.0.1&quot;</span>,</span><br></pre></td></tr></table></figure>
<p>开始安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python setup.py build develop</span><br></pre></td></tr></table></figure>
<p>安装过程无报错即可。</p>
<h4 id="目标检测"><a href="#目标检测" class="headerlink" title="目标检测"></a>目标检测</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python demo/demo.py --config-file configs/COCO-Detection/faster_rcnn_R_50_FPN_3x.yaml --input ../TestExample/test.jpg --output ../TestExample/output.jpg --opts MODEL.WEIGHTS ../TestExample/model_final_b275ba.pkl</span><br></pre></td></tr></table></figure>
<h4 id="实例分割"><a href="#实例分割" class="headerlink" title="实例分割"></a>实例分割</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python demo/demo.py --config-file configs/COCO-Detection/faster_rcnn_R_50_FPN_3x.yaml --input ../TestExample/test.jpg --output ../TestExample/output.jpg --opts MODEL.WEIGHTS ../TestExample/model_final_f10217.pkl</span><br></pre></td></tr></table></figure>
<h2 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h2><p><a href="https://github.com/conansherry/detectron2/issues/2">github issue</a></p>
<p>安装时提示缺少什么包，直接pip install即可，出问题可以查stackoverflow。</p>
<h3 id="cl-exe出错"><a href="#cl-exe出错" class="headerlink" title="cl.exe出错"></a>cl.exe出错</h3><p><a href="https://blog.csdn.net/qq_35067322/article/details/105835311">解决方法</a></p>
<p>添加环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\bin\Hostx64\x64</span><br></pre></td></tr></table></figure>
<p>如下即可</p>
<p><img src="/2020/08/22/CV%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%E5%AE%89%E8%A3%85detectron2/2.png" alt></p>
<h3 id="cocoeval出错"><a href="#cocoeval出错" class="headerlink" title="cocoeval出错"></a>cocoeval出错</h3><p>修改文件 detectron2\detectron2\layers\csrc\cocoeval\cocoeval.cpp</p>
<p>添加</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>修改</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">localtime_r(&amp;rawtime, &amp;local_time);</span><br></pre></td></tr></table></figure>
<p>为</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">localtime_s(&amp;local_time, &amp;rawtime);</span><br></pre></td></tr></table></figure>
<h3 id="nvcc-exe出错"><a href="#nvcc-exe出错" class="headerlink" title="nvcc.exe出错"></a>nvcc.exe出错</h3><p>修改文件 detectron2/detectron2/layers/csrc/nms_rotated/nms_rotated_cuda.cu</p>
<p>在11行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WITH_HIP</span></span><br></pre></td></tr></table></figure>
<p>之前添加</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WITH_HIP</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CV入门</category>
      </categories>
      <tags>
        <tag>CV</tag>
        <tag>detectron2</tag>
      </tags>
  </entry>
  <entry>
    <title>Internet安全协议与分析（七）CSP</title>
    <url>/2020/10/25/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%83%EF%BC%89CSP/</url>
    <content><![CDATA[<p>介绍攻击结构性方法。</p>
<a id="more"></a>
<h2 id="攻击结构性方法"><a href="#攻击结构性方法" class="headerlink" title="攻击结构性方法"></a>攻击结构性方法</h2><p>从反面寻找协议的漏洞，如果能找到合适的攻击步骤，则说明协议有缺陷。</p>
<p>如果找不到攻击，不能说明协议是安全的，但安全性可以得到一定程度的保证。</p>
<ul>
<li>主体数据的有限性：通常只分析有限个主体实例</li>
<li>无法解决状态空间爆炸问题</li>
<li>无法揭示安全协议的内部机理</li>
</ul>
<h2 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h2><p>通信顺序进程（Communicating Sequential Processes）</p>
<ul>
<li>描述并发系统的消息交互</li>
<li>将协议的安全问题描述为CSP进行是否满足其CSP规约的问题，并用FDR对协议的性质进行分析与验证。</li>
</ul>
<h3 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h3><ul>
<li><p>事件</p>
<ul>
<li>一个典型的CSP事件形式为：c.i.j.m，包括信道c、消息源i、目的地j和消息m。</li>
</ul>
</li>
<li><p>信道</p>
<ul>
<li>不同事件类型看成不同信道，并规定它所传递的数据类型。</li>
</ul>
</li>
<li><p>进程</p>
<ul>
<li>包括执行状态中的一个动作（事件）以及动作结束后的状态。</li>
</ul>
<p><img src="/2020/10/25/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%83%EF%BC%89CSP/image-20201025141246384.png" alt="image-20201025141246384"></p>
</li>
<li><p>进程间选择 P▢Q</p>
<ul>
<li>表示在两个进程事件间的外部选择</li>
</ul>
<p><img src="/2020/10/25/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%83%EF%BC%89CSP/image-20201025141612756.png" alt="image-20201025141612756"></p>
</li>
<li><p>并行进程</p>
<p><img src="/2020/10/25/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%83%EF%BC%89CSP/image-20201025141658434.png" alt="image-20201025141658434"></p>
</li>
<li><p>重命名</p>
<p><img src="/2020/10/25/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%83%EF%BC%89CSP/image-20201025141716208.png" alt="image-20201025141716208"></p>
</li>
<li><p>条件结构</p>
<p><img src="/2020/10/25/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%83%EF%BC%89CSP/image-20201025141742620.png" alt="image-20201025141742620"></p>
</li>
<li><p>迹与精炼</p>
<p><img src="/2020/10/25/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%83%EF%BC%89CSP/image-20201025141807851.png" alt="image-20201025141807851"></p>
</li>
</ul>
<h3 id="协议目标的CSP描述"><a href="#协议目标的CSP描述" class="headerlink" title="协议目标的CSP描述"></a>协议目标的CSP描述</h3><p>看得头大，啥也记不住</p>
<p>TO BE COMPLETED</p>
]]></content>
      <categories>
        <category>Internet安全协议与分析</category>
      </categories>
      <tags>
        <tag>CSP</tag>
      </tags>
  </entry>
  <entry>
    <title>Internet安全协议与分析（一）IPSec</title>
    <url>/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89IPSec/</url>
    <content><![CDATA[<p>介绍IPSec协议与IKE协议 。<br><a id="more"></a></p>
<h2 id="IP安全问题"><a href="#IP安全问题" class="headerlink" title="IP安全问题"></a>IP安全问题</h2><p>IP协议从本质上就是不安全的，仅仅依靠IP头部的校验和字段无法保证IP包的安全。</p>
<p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89IPSec/image-20201027160509665.png" alt="image-20201027160509665"></p>
<h2 id="IPSec"><a href="#IPSec" class="headerlink" title="IPSec"></a>IPSec</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>IPSec旨在把安全机制引入IP协议，使用密码学方法支持机密性和认证性服务，确保公网上数据通信的可靠性和完整性。</p>
<p>IPSec对IPV4可选，对IPV6必须，由三种机制共同保障</p>
<ul>
<li>认证</li>
<li>信息机密性</li>
<li>密钥管理</li>
</ul>
<h3 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h3><p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89IPSec/image-20201027160857942.png" alt="image-20201027160857942"></p>
<p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89IPSec/image-20201027160944599.png" alt="image-20201027160944599"></p>
<p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89IPSec/image-20201027160958769.png" alt="image-20201027160958769"></p>
<p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89IPSec/image-20201027161058344.png" alt="image-20201027161058344"></p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="安全联盟（SA）"><a href="#安全联盟（SA）" class="headerlink" title="安全联盟（SA）"></a>安全联盟（SA）</h4><ul>
<li>Secure Association</li>
<li>是两个通信实体之间建立的一个简单单向协定</li>
<li>由SPI（Security Parameter Index）和目标地址组成</li>
<li>单个IPSec连接至少需要两个SA</li>
</ul>
<h4 id="安全关联数据库（SAD）"><a href="#安全关联数据库（SAD）" class="headerlink" title="安全关联数据库（SAD）"></a>安全关联数据库（SAD）</h4><ul>
<li>Secure Association Database</li>
<li>SAD包含了所有活跃的SA的所有参数信息</li>
<li>流出数据：会有一个SPD数据项包含指向某个SAD数据项的指针，SPD决定了一个给定的数据包究竟使用哪一个SA。</li>
<li>流入数据：由SAD决定如何对给定数据包做处理。</li>
</ul>
<h4 id="安全策略库（SPD）"><a href="#安全策略库（SPD）" class="headerlink" title="安全策略库（SPD）"></a>安全策略库（SPD）</h4><ul>
<li>Secure Policy Database</li>
<li>SPD用于为IPSec实现提供安全策略配置，指定哪些数据流必须经过IPSec的处理。</li>
</ul>
<h3 id="AH协议"><a href="#AH协议" class="headerlink" title="AH协议"></a>AH协议</h3><ul>
<li>Authentication Header</li>
<li>在每一个数据包上添加一个身份验证报头，包含一个带密钥的hash，提供了完整性保护。</li>
<li>不提供机密性保护。</li>
</ul>
<h4 id="传输模式"><a href="#传输模式" class="headerlink" title="传输模式"></a>传输模式</h4><ul>
<li>如果传送过程中经过NAT网关，源/目的IP将被改变，导致完整性验证失败。AH在传输模式下与NAT冲突。</li>
</ul>
<p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89IPSec/image-20201027162241877.png" alt="image-20201027162241877"></p>
<h4 id="隧道模式"><a href="#隧道模式" class="headerlink" title="隧道模式"></a>隧道模式</h4><ul>
<li>依旧与NAT冲突。</li>
</ul>
<p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89IPSec/image-20201027162746567.png" alt="image-20201027162746567"></p>
<h3 id="ESP协议"><a href="#ESP协议" class="headerlink" title="ESP协议"></a>ESP协议</h3><ul>
<li>将需要保护的数据加密后，封装在IP包中。</li>
</ul>
<h4 id="传输模式-1"><a href="#传输模式-1" class="headerlink" title="传输模式"></a>传输模式</h4><p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89IPSec/image-20201027162920657.png" alt="image-20201027162920657"></p>
<h4 id="隧道模式-1"><a href="#隧道模式-1" class="headerlink" title="隧道模式"></a>隧道模式</h4><p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89IPSec/image-20201027162952118.png" alt="image-20201027162952118"></p>
<h3 id="AH-vs-ESP"><a href="#AH-vs-ESP" class="headerlink" title="AH vs ESP"></a>AH vs ESP</h3><p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89IPSec/image-20201027163130692.png" alt="image-20201027163130692"></p>
<h2 id="IKE"><a href="#IKE" class="headerlink" title="IKE"></a>IKE</h2><p>​        IKE（Internet Key Exchange）因特网密钥交换协议，是IPSec的信令协议，为IPSec提供了自动协商交换密钥、建立安全联盟的服务，能够简化IPSec的使用和管理，大大简化IPSec的配置和维护工作。</p>
<h3 id="IKE与IPSec关系"><a href="#IKE与IPSec关系" class="headerlink" title="IKE与IPSec关系"></a>IKE与IPSec关系</h3><ul>
<li>IKE位于UDP之上，属于应用层协议。</li>
<li>IKE为IPSec协商建立SA，并将参数与密钥交给IPSec。</li>
<li>IPSec使用IKE建立的SA对IP报文加密或验证处理。</li>
<li>AH和ESP的协议号是51和50。</li>
</ul>
<p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89IPSec/image-20201010110531559.png" alt="image-20201010110531559" style="zoom:67%;"></p>
<h3 id="IKE的作用"><a href="#IKE的作用" class="headerlink" title="IKE的作用"></a>IKE的作用</h3><ul>
<li>降低手工配置的复杂度</li>
<li>SA和密钥定时更新</li>
<li>允许IPSec提供反重放服务</li>
<li>允许在端与端之间动态认证</li>
</ul>
<h3 id="IKE的协商过程"><a href="#IKE的协商过程" class="headerlink" title="IKE的协商过程"></a>IKE的协商过程</h3><h4 id="两个阶段"><a href="#两个阶段" class="headerlink" title="两个阶段"></a>两个阶段</h4><ul>
<li>阶段一：在网络上建立IKE SA，为阶段二提供保护和快速协商。通过协商创建一个通信信道，并对其进行认证，为通信提供机密性、消息完整性以及消息源认证服务。</li>
<li>阶段二：在IKE SA的保护下完成IPSec的协商。</li>
</ul>
<h4 id="交换信息"><a href="#交换信息" class="headerlink" title="交换信息"></a>交换信息</h4><ul>
<li>SA交换，协商确认有关安全策略的过程。</li>
<li>密钥交换，交换Diffie-Hellman公共值和辅助数据，产生加密物。</li>
<li>ID交换和验证数据交换，进行身份验证和对整个SA交换进行验证。</li>
</ul>
<h4 id="阶段一协商过程"><a href="#阶段一协商过程" class="headerlink" title="阶段一协商过程"></a>阶段一协商过程</h4><p>双方建立了一个已通过身份验证和安全保护的通道，此阶段建立了一个ISAKMP。</p>
<p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89IPSec/image-20201010111251530.png" alt="image-20201010111251530" style="zoom: 80%;"></p>
<ul>
<li><p>两种协商模式</p>
<ul>
<li>主模式协商<ul>
<li>适合两设备的公网IP固定，实现设备之间点对点的环境。</li>
</ul>
</li>
</ul>
<p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89IPSec/image-20201010111946997.png" alt="image-20201010111946997"></p>
<ul>
<li>野蛮模式协商</li>
</ul>
<p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89IPSec/image-20201010111956705.png" alt="image-20201010111956705"></p>
</li>
</ul>
<p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89IPSec/image-20201010112010405.png" alt="image-20201010112010405"></p>
<h4 id="阶段二协商过程"><a href="#阶段二协商过程" class="headerlink" title="阶段二协商过程"></a>阶段二协商过程</h4><ul>
<li>使用“快速模式”交换，实现两个主要功能<ul>
<li>协商安全参数保护数据连接</li>
<li>周期性地更新密钥信息</li>
</ul>
</li>
<li>协商出IPSec单向SA，保护数据流。</li>
<li>协商过程受第一阶段ISAKMP/IKE SA保护。</li>
</ul>
<p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89IPSec/image-20201010112031723.png" alt="image-20201010112031723" style="zoom:80%;"></p>
]]></content>
      <categories>
        <category>Internet安全协议与分析</category>
      </categories>
      <tags>
        <tag>IPSec</tag>
        <tag>IKE</tag>
      </tags>
  </entry>
  <entry>
    <title>Internet安全协议与分析（三）SET</title>
    <url>/2020/10/17/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89SET/</url>
    <content><![CDATA[<p>介绍SET协议。</p>
<a id="more"></a>
<h2 id="电子商务安全"><a href="#电子商务安全" class="headerlink" title="电子商务安全"></a>电子商务安全</h2><h3 id="电子交易的主要模式"><a href="#电子交易的主要模式" class="headerlink" title="电子交易的主要模式"></a>电子交易的主要模式</h3><h4 id="支付系统无安全措施"><a href="#支付系统无安全措施" class="headerlink" title="支付系统无安全措施"></a>支付系统无安全措施</h4><p><img src="/2020/10/17/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89SET/image-20201017140449640.png" alt="image-20201017140449640"></p>
<ul>
<li>风险由商家承担</li>
<li>商家完全掌握用户的信用卡信息</li>
<li>信用卡信息的传递无安全保障</li>
</ul>
<h4 id="通过第三方代理人支付"><a href="#通过第三方代理人支付" class="headerlink" title="通过第三方代理人支付"></a>通过第三方代理人支付</h4><p><img src="/2020/10/17/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89SET/image-20201017140544212.png" alt="image-20201017140544212"></p>
<ul>
<li>用户账户的开设不通过网络</li>
<li>信用卡信息不在开放的网络上传送</li>
<li>通过电子邮件来确认用户身份</li>
<li>商家自由度大，风险小</li>
<li>支付是通过双方都信任的第三方(经纪人)完成的</li>
</ul>
<h4 id="数字现金支付"><a href="#数字现金支付" class="headerlink" title="数字现金支付"></a>数字现金支付</h4><p><img src="/2020/10/17/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89SET/image-20201017140656864.png" alt="image-20201017140656864"></p>
<ul>
<li>银行和商家之间应有协议和授权关系</li>
<li>用户、商家和数字现金的发行都需要使用数字现金软件</li>
<li>适用于小额交易</li>
<li>身份验证是由数字现金本身完成的</li>
<li>数字现金的发行负责用户和商家之间实际资金的转移</li>
<li>数字现金与普通现金一样，可以存、取和转让</li>
</ul>
<h4 id="简单加密支付"><a href="#简单加密支付" class="headerlink" title="简单加密支付"></a>简单加密支付</h4><p><img src="/2020/10/17/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89SET/image-20201017140746511.png" alt="image-20201017140746511"></p>
<ul>
<li>信用卡等关键信息需要加密</li>
<li>使用对称和非对称加密技术</li>
<li>可能要启用身份认证系统</li>
<li>以数字签名确认信息的真实性</li>
<li>需要业务服务器和服务软件的支持</li>
</ul>
<h4 id="安全电子交易SET支付"><a href="#安全电子交易SET支付" class="headerlink" title="安全电子交易SET支付"></a>安全电子交易SET支付</h4><p><img src="/2020/10/17/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89SET/image-20201017140822317.png" alt="image-20201017140822317"></p>
<ul>
<li>SET协议的目标<ul>
<li>信息在互联网上安全传输，不能被窃听或篡改</li>
<li>用户资料要妥善保护，商家只能看到订货信息，看不到用户的账户信息</li>
<li>持卡人和商家相互认证，以确定对方身份</li>
<li>软件遵循相同的协议和消息格式，具有兼容性和互操作性</li>
</ul>
</li>
</ul>
<h2 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h2><ul>
<li>Secure Electronic Transaction</li>
<li>Visa和MasterCard研发的专门用于Internet上安全信用卡交易的协议</li>
</ul>
<h3 id="交易中的主体"><a href="#交易中的主体" class="headerlink" title="交易中的主体"></a>交易中的主体</h3><p><img src="/2020/10/17/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89SET/image-20201027203155887.png" alt="image-20201027203155887"></p>
<h3 id="主体证书"><a href="#主体证书" class="headerlink" title="主体证书"></a>主体证书</h3><ul>
<li>协议各方持有名字和密钥对</li>
<li>身份使用X.509 V3证书和密钥关联</li>
</ul>
<p><img src="/2020/10/17/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89SET/image-20201017141215885.png" alt="image-20201017141215885"></p>
<h3 id="SET电子支付的流程"><a href="#SET电子支付的流程" class="headerlink" title="SET电子支付的流程"></a>SET电子支付的流程</h3><ul>
<li>客户在发卡行开户</li>
<li>客户持有银行签发的X.509 V3证书</li>
<li>商家持有两个同类品牌的证书X.509 V3<ul>
<li>一个用于签名，一个用于密钥交换</li>
</ul>
</li>
<li>客户向商家发订单</li>
<li>商家发送证书向客户出示自己身份</li>
</ul>
<h3 id="SET双重数字签名"><a href="#SET双重数字签名" class="headerlink" title="SET双重数字签名"></a>SET双重数字签名</h3><ul>
<li>将两个消息连接在一起，这两个消息面对的对象不同。<ul>
<li>Order Information：客户给商家</li>
<li>Payment Information：客户给银行</li>
</ul>
</li>
<li>商家不需要卡信息，银行需要订单信息，保护客户隐私。</li>
</ul>
<p><img src="/2020/10/17/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89SET/image-20201017141600864.png" alt="image-20201017141600864"></p>
<ul>
<li>商家收到OI校验签名</li>
<li>银行收到PI校验签名</li>
<li>客户连接OI和PI，证明该关联。</li>
</ul>
<p><img src="/2020/10/17/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89SET/image-20201017142528166.png" alt="image-20201017142528166"></p>
<h3 id="SET电子支付的流程-1"><a href="#SET电子支付的流程-1" class="headerlink" title="SET电子支付的流程"></a>SET电子支付的流程</h3><p><img src="/2020/10/17/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89SET/image-20201017142547541.png" alt="image-20201017142547541"></p>
<ul>
<li>客户发送订单和支付信息给商家</li>
<li>商家向支付网关请求支付授权</li>
<li>商家确认向客户订单</li>
<li>商家向客户提供商品或者服务</li>
<li>商家向支付网关请求支付</li>
</ul>
<h3 id="SET消息流"><a href="#SET消息流" class="headerlink" title="SET消息流"></a>SET消息流</h3><p><img src="/2020/10/17/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89SET/image-20201017142656233.png" alt="image-20201017142656233"></p>
<p><img src="/2020/10/17/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89SET/image-20201017142741943.png" alt="image-20201017142741943"></p>
<h4 id="支付过程初始化"><a href="#支付过程初始化" class="headerlink" title="支付过程初始化"></a>支付过程初始化</h4><p><img src="/2020/10/17/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89SET/image-20201017142801980.png" alt="image-20201017142801980"></p>
<ul>
<li>持卡人向商家发送初始请求，包括<ul>
<li>持卡人使用的语言，交易ID，交易卡类型</li>
</ul>
</li>
<li>商家接收初始请求，产生初始应答，对初始应答生成消息摘要，并进行数字签名，包括<ul>
<li>商家证书、网管证书、初始应答、消息摘要的数字签名等。</li>
</ul>
</li>
</ul>
<h4 id="购物请求"><a href="#购物请求" class="headerlink" title="购物请求"></a>购物请求</h4><p><img src="/2020/10/17/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89SET/image-20201017143046383.png" alt="image-20201017143046383"></p>
<ul>
<li>持卡人接收初始应答，检查商家证书和网关证书。用商家公钥解开数字签名，验证数据未被篡改，否则丢弃。</li>
<li>持卡人发出购物请求，包含了真正的交易行为，包括<ul>
<li>发往商家的订单信息（OI）</li>
<li>通过商家转发往网关的支付信息（PI）</li>
</ul>
</li>
<li>通过双重数字签名将OI与PI进行关联。</li>
<li>PI被加密，商家只能看到OI。</li>
</ul>
<p><img src="/2020/10/17/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89SET/image-20201017143327440.png" alt="image-20201017143327440"></p>
<h4 id="商家验证"><a href="#商家验证" class="headerlink" title="商家验证"></a>商家验证</h4><p><img src="/2020/10/17/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89SET/image-20201017143352764.png" alt="image-20201017143352764"></p>
<ul>
<li>商家接受持卡人的购物请求，认证持卡人的证书。验证双重签名，看数据在传输过程中是否被篡改，若数据完整则处理订单信息，产生支付请求。</li>
<li>将支付请求用HASH生成摘要，并签名，网关收到后用商家公钥解密，并确认支付请求是此商家所发且在途中未被修改。生成对称密钥对支付请求加密，并用网关公钥加密形成数字信封。</li>
<li>将商家证书、支付请求密文、商家数字签名、数字信封和持卡人通过商家转发的：sign[H(OP)]、OI摘要、PI密文、持卡人数字信封、持卡人证书等发往支付网关。</li>
</ul>
<h4 id="支付网关认证过程"><a href="#支付网关认证过程" class="headerlink" title="支付网关认证过程"></a>支付网关认证过程</h4><ul>
<li>支付网关分别检查确认商家发来的数据和持卡人发来的数据</li>
<li>用HASH算法作用于支付请求，形成摘要，与商家发来的支付请求<br>摘要（解开数字签名所得）相比较，如果相同则表示数据完整，否<br>则丢弃数据</li>
<li>网关检查持卡人证书，然后用私钥打开持卡人数字信封，得到他的<br>帐号和对称密钥。用此对称密钥解开PI密文，得到PI，接着验证双<br>重签名，生成PI的摘要，与OI摘要相连接，再次生成摘要，其结果<br>与H (OP)(解双重签名所得)相比较，如果相同则数据完整，如果<br>不同则丢弃。</li>
<li>网关将信息发送往银行</li>
</ul>
<h4 id="收单银行处理"><a href="#收单银行处理" class="headerlink" title="收单银行处理"></a>收单银行处理</h4><ul>
<li>解密AuthReq</li>
<li>校验商家签名</li>
<li>解密来自于持卡人的PI</li>
<li>校验双重签名</li>
<li>从PI中抽取卡数据</li>
</ul>
<p>TO BE COMPLETED</p>
]]></content>
      <categories>
        <category>Internet安全协议与分析</category>
      </categories>
      <tags>
        <tag>SET</tag>
      </tags>
  </entry>
  <entry>
    <title>Internet安全协议与分析（二）SSL</title>
    <url>/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89SSL/</url>
    <content><![CDATA[<p>介绍SSL协议与WTLS协议 。<br><a id="more"></a></p>
<h2 id="不同协议层的安全"><a href="#不同协议层的安全" class="headerlink" title="不同协议层的安全"></a>不同协议层的安全</h2><p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89SSL/image-20201027193018383.png" alt="image-20201027193018383"></p>
<h2 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h2><p>1994年，由Netscape公司提出SSL，为HTTP提供安全连接。</p>
<h3 id="安全机制"><a href="#安全机制" class="headerlink" title="安全机制"></a>安全机制</h3><ul>
<li>机密性：使用对称密钥算法对传输的数据进行加密。</li>
<li>身份验证：基于证书利用数字签名对server和client进行身份验证。</li>
<li>消息完整性验证：使用MAC算法检验消息的完整性。</li>
</ul>
<h3 id="SSL版本"><a href="#SSL版本" class="headerlink" title="SSL版本"></a>SSL版本</h3><ul>
<li>SSL由Netscape公司设计，是用于web的安全传输协议。</li>
<li>IETF将SSL标准化，称为TLS，TLS1.0与SSL3.0差别非常小。</li>
<li>wap论坛在TLS基础上做了WTLS协议，以适应无线的特殊环境。</li>
</ul>
<h3 id="SSL的分层结构"><a href="#SSL的分层结构" class="headerlink" title="SSL的分层结构"></a>SSL的分层结构</h3><ul>
<li>上层协议<ul>
<li>SSL握手协议</li>
<li>SSL passowrd变化协议</li>
<li>SSL警告协议</li>
</ul>
</li>
<li>下层协议为SSL记录协议</li>
</ul>
<p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89SSL/image-20201027193738047.png" alt="image-20201027193738047"></p>
<h3 id="SSL基本过程"><a href="#SSL基本过程" class="headerlink" title="SSL基本过程"></a>SSL基本过程</h3><ul>
<li>建立会话</li>
<li>传输应用数据</li>
</ul>
<h3 id="连接-amp-会话"><a href="#连接-amp-会话" class="headerlink" title="连接&amp;会话"></a>连接&amp;会话</h3><ul>
<li><p>SSL连接</p>
<ul>
<li>点对点</li>
<li>连接是暂时的，每个连接和一个会话关联。</li>
</ul>
</li>
<li><p>SSL会话</p>
<ul>
<li>会话是在server和client之间的一个关联，由握手协议建立，定义了一组密码安全参数。</li>
<li>避免为每一个连接提供新的安全参数所需昂贵的协商代价。</li>
</ul>
</li>
<li><p>在任意一对通信主体之间，可以有多个安全连接。</p>
<p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89SSL/image-20201010113915965.png" alt="image-20201010113915965"></p>
</li>
</ul>
<h3 id="握手协议"><a href="#握手协议" class="headerlink" title="握手协议"></a>握手协议</h3><p>握手协议允许服务器和客户端相互验证，协商加密和MAC算法以及保密密钥。</p>
<p>握手协议的消息都含有以下三个字段</p>
<p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89SSL/image-20201010114509495.png" alt="image-20201010114509495"></p>
<h4 id="阶段1：建立安全能力"><a href="#阶段1：建立安全能力" class="headerlink" title="阶段1：建立安全能力"></a>阶段1：建立安全能力</h4><ul>
<li>SSL握手第一阶段启动逻辑连接，建立这个连接的安全能力。</li>
<li>client向server发送client hello消息<ul>
<li>支持的协议版本，比如TLS 1.0。</li>
<li>客户端生成的随机数，用于生成“对话密钥”。</li>
<li>支持的加密方法，比如RSA。</li>
<li>支持的压缩方法。</li>
</ul>
</li>
<li>server向client发送server hello消息<ul>
<li>确认使用的协议版本，如果版本不一致则关闭加密通信。</li>
<li>服务器生成的随机数，用于生成“对话密钥”。</li>
<li>确认使用的加密方法。</li>
<li>服务器证书。</li>
</ul>
</li>
<li>此阶段后，client、server知道了以下内容<ul>
<li>SSL版本</li>
<li>密钥交换、信息验证和加密算法</li>
<li>压缩方法</li>
<li>密钥生成的两个随机数</li>
</ul>
</li>
</ul>
<p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89SSL/image-20201010114955273.png" alt="image-20201010114955273"></p>
<h4 id="阶段2：服务器鉴别与密钥交换"><a href="#阶段2：服务器鉴别与密钥交换" class="headerlink" title="阶段2：服务器鉴别与密钥交换"></a>阶段2：服务器鉴别与密钥交换</h4><ul>
<li>server发送证书，包含一个X.509证书，或一条证书链。</li>
<li>server发送server_key_exchange消息<ul>
<li>可选，服务器证书没有包含必需数据时发送。</li>
<li>包含签名，签名内容包括两个随机数以及服务器参数。</li>
</ul>
</li>
<li>server发送certificate_request消息<ul>
<li>非匿名server可以像client请求一个证书。</li>
<li>包含证书类型和CAs。</li>
</ul>
</li>
<li>服务器发送server_hello_done，等待应答。</li>
</ul>
<p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89SSL/image-20201010115349419.png" alt="image-20201010115349419"></p>
<h4 id="阶段3：客户机鉴别与密钥交换"><a href="#阶段3：客户机鉴别与密钥交换" class="headerlink" title="阶段3：客户机鉴别与密钥交换"></a>阶段3：客户机鉴别与密钥交换</h4><ul>
<li>client收到server_done消息后，检查server提供的证书，判断参数是否可以接收，如果没有问题就发送消息。</li>
<li>如果server请求证书，就发送certificate，若client没有证书，则发送no_certificate警告，然后发送client_key_exchange消息。</li>
<li>最后，client发送certificate_verify消息，包含一个签名，对第一条消息以来的所有握手消息的MAC值进行签名。</li>
</ul>
<p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89SSL/image-20201010115612373.png" alt="image-20201010115612373"></p>
<h4 id="阶段4：完成"><a href="#阶段4：完成" class="headerlink" title="阶段4：完成"></a>阶段4：完成</h4><ul>
<li>第四阶段建立起一个安全连接。</li>
<li>client发送change_cipher_spec消息，将协商得到的CipherSuite拷贝到当前连接的状态之中。</li>
<li>client用新的算法、密钥参数发送一个finished消息，检查密钥交换和鉴别过程是否已经成功。其中包括一个校验值，对所有以来的消息进行校验。</li>
<li>服务器同样发送change_cipher_spec和finished消息。</li>
<li>握手过程完成，client和server可以交换应用层数据。</li>
</ul>
<p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89SSL/image-20201010120038944.png" alt="image-20201010120038944"></p>
<h3 id="ChangeCipherSpec"><a href="#ChangeCipherSpec" class="headerlink" title="ChangeCipherSpec"></a>ChangeCipherSpec</h3><ul>
<li>在数据包中就是一个字节的数据，用于告知服务端，客户端已经切换到之前协商好的加密套件的状态，准备使用之前协商好的加密套件加密数据并传输。</li>
</ul>
<h3 id="记录协议"><a href="#记录协议" class="headerlink" title="记录协议"></a>记录协议</h3><p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89SSL/image-20201010132038339.png" alt="image-20201010132038339"></p>
<h3 id="警告协议"><a href="#警告协议" class="headerlink" title="警告协议"></a>警告协议</h3><p>当握手过程或者数据加密等操作出错或者发生异常情况时，向对方发出警告或中止当前连接。</p>
<h3 id="SSL的加密和认证算法"><a href="#SSL的加密和认证算法" class="headerlink" title="SSL的加密和认证算法"></a>SSL的加密和认证算法</h3><p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89SSL/image-20201010132259141.png" alt="image-20201010132259141"></p>
<p>认证算法采用X.509电子证书标准，通过RSA算法进行数字签名来实现。</p>
<h3 id="SSL安全性分析"><a href="#SSL安全性分析" class="headerlink" title="SSL安全性分析"></a>SSL安全性分析</h3><ul>
<li>鉴别机制<ul>
<li>客户端与服务器交换了证书</li>
</ul>
</li>
<li>加密机制<ul>
<li>对称加密保护数据传输，非对称加密协商会话密钥。</li>
</ul>
</li>
<li>完整性机制<ul>
<li>数据分组压缩后，产生MAC。</li>
</ul>
</li>
<li>抗重放攻击<ul>
<li>使用序列号，传输中被加密。</li>
</ul>
</li>
</ul>
<h3 id="SSL脆弱性分析"><a href="#SSL脆弱性分析" class="headerlink" title="SSL脆弱性分析"></a>SSL脆弱性分析</h3><ul>
<li>客户端假冒</li>
<li>无法提供基于UDP应用的安全保护</li>
<li>不能对抗通信流量分析</li>
<li>进程中主密钥泄露</li>
</ul>
<h2 id="WTLS"><a href="#WTLS" class="headerlink" title="WTLS"></a>WTLS</h2><ul>
<li>保证传输层安全，作为WAP协议栈的一个层次向上层提供安全传输服务接口。</li>
</ul>
<h3 id="提供的安全服务"><a href="#提供的安全服务" class="headerlink" title="提供的安全服务"></a>提供的安全服务</h3><ul>
<li>第一类服务：使用交换的公共密钥建立安全传输，使用对称算法加解密数据，检查数据完整性，可以建立安全通信的通道，但没有对通信双方的身份进行鉴别，</li>
<li>第二类服务：在第一类服务的基础上，可以交换服务器证书，完成对服务器的鉴别。</li>
<li>第三类服务：在第二类服务的基础上，可以交换客户端证书，对恶意的用户冒充也能抗击。</li>
</ul>
<h3 id="协议栈"><a href="#协议栈" class="headerlink" title="协议栈"></a>协议栈</h3><p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89SSL/image-20201027201909276.png" alt="image-20201027201909276"></p>
<h3 id="握手协议-1"><a href="#握手协议-1" class="headerlink" title="握手协议"></a>握手协议</h3><ul>
<li>和SSL一致？</li>
</ul>
<h3 id="记录协议-1"><a href="#记录协议-1" class="headerlink" title="记录协议"></a>记录协议</h3><p><img src="/2020/10/10/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89SSL/image-20201027202237703.png" alt="image-20201027202237703"></p>
<h3 id="告警协议"><a href="#告警协议" class="headerlink" title="告警协议"></a>告警协议</h3><ul>
<li>描述信息错误的严重程度及告警描述</li>
<li>警告、危急、致命</li>
</ul>
<h3 id="密钥交换"><a href="#密钥交换" class="headerlink" title="密钥交换"></a>密钥交换</h3><ul>
<li>共享密钥方法</li>
<li>RSA加密传输方法</li>
<li>DH密钥交换方法</li>
<li>EC-DH密钥交换方法<ul>
<li>椭圆曲线版本的DH密钥交换</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Internet安全协议与分析</category>
      </categories>
      <tags>
        <tag>SSL</tag>
        <tag>WTLS</tag>
      </tags>
  </entry>
  <entry>
    <title>Internet安全协议与分析（五）Kerberos</title>
    <url>/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89Kerberos/</url>
    <content><![CDATA[<p>介绍Kerberos协议。</p>
<a id="more"></a>
<h2 id="密钥管理问题"><a href="#密钥管理问题" class="headerlink" title="密钥管理问题"></a>密钥管理问题</h2><p>所有的密码系统都存在这样的问题：如何安全/可靠地分配密钥。理想的情况是，密钥分配协议应该得到形式化验证。</p>
<h3 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h3><ul>
<li>用户只需要登录一次，就可以访问多个系统，不需要记忆多个口令密码。</li>
<li>优点<ul>
<li>用户可以快速访问网络，提高工作效率，也能帮助提高系统的安全性。</li>
<li>有利于进行账户密码管理、用户审计。</li>
<li>方便进行企业应用部署。</li>
</ul>
</li>
</ul>
<h2 id="Kerberos认证服务协议"><a href="#Kerberos认证服务协议" class="headerlink" title="Kerberos认证服务协议"></a>Kerberos认证服务协议</h2><ul>
<li>提供一个在客户端跟服务器端之间或服务器与服务器之间的身份验证机制（并且是相互的身份验证机制）·</li>
<li>解决的问题<ul>
<li>在公开的分布式环境中，工作站上的用户希望访问分布在网络中的服务器上的服务。</li>
<li>服务器希望能够限制授权用户的访问，并对服务请求进行鉴别。</li>
</ul>
</li>
</ul>
<h3 id="Kerberos的加密体制"><a href="#Kerberos的加密体制" class="headerlink" title="Kerberos的加密体制"></a>Kerberos的加密体制</h3><ul>
<li>Kerberos提供一个中心认证服务器，提供用户和服务器之间的认证服务。</li>
<li>采用传统加密算法，<strong>无公钥体制</strong>。</li>
<li>常用版本：Kerberos Version 4 和 Kerberos Version 5</li>
</ul>
<h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><ul>
<li>在分布式的client/server体系结构中，采用Kerberos服务器提供认证服务。</li>
<li>总体方案是提供一个可信第三方的认证服务。<ul>
<li>用tickets验证</li>
<li>避免本地保存密码和在互联网上传输密码</li>
<li>包含可信第三方</li>
<li>使用对称加密</li>
<li>客户端与服务器之间能够相互验证</li>
</ul>
</li>
</ul>
<h3 id="Kerberos-Version-4"><a href="#Kerberos-Version-4" class="headerlink" title="Kerberos Version 4"></a>Kerberos Version 4</h3><ul>
<li>引入可信第三方的认证服务，基于Needham &amp; Schroeder协议。</li>
<li>采用DES加密算法，提供认证服务。</li>
</ul>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li>Principal<ul>
<li>安全个体，被认证的个体，有名字和口令。</li>
</ul>
</li>
<li>KDC<ul>
<li>密钥分发中心，提供票据和临时的会话密钥。</li>
</ul>
</li>
<li>Ticket<ul>
<li>用户可以用它向服务器表明身份，包含客户标识、会话密钥、时间戳等信息。其中的大多数信息被加密，密钥为服务器的密钥。</li>
</ul>
</li>
<li>Authenticator<ul>
<li>包含最近产生的信息，需要用到会话密钥。</li>
</ul>
</li>
<li>Credentials<ul>
<li>票据加上会话密钥</li>
</ul>
</li>
<li>Authentication Server(AS)<ul>
<li>通过long-term key认证客户</li>
<li>给予客户ticket granting ticket和short-term key</li>
<li><strong>认证服务</strong></li>
</ul>
</li>
<li>Ticket Granting Server(TGS)<ul>
<li>通过short-term key和ticket granting ticket认证客户。</li>
<li>TGS发放tickets给客户以访问其他服务器。</li>
<li><strong>授权与访问控制服务</strong></li>
</ul>
</li>
</ul>
<p>这样做的动机</p>
<ul>
<li>将认证与授权在逻辑上分离</li>
<li>设置不同的生命周期<ul>
<li>TGT通常10h，ST通常5min。</li>
<li>方便客户，降低密钥的暴露时间。</li>
</ul>
</li>
</ul>
<p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89Kerberos/image-20201019141737715.png" alt="image-20201019141737715"></p>
<h4 id="认证服务交换：获得TGT"><a href="#认证服务交换：获得TGT" class="headerlink" title="认证服务交换：获得TGT"></a>认证服务交换：获得TGT</h4><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89Kerberos/image-20201019141857995.png" alt="image-20201019141857995"></p>
<h4 id="票据许可服务交换：获得ST"><a href="#票据许可服务交换：获得ST" class="headerlink" title="票据许可服务交换：获得ST"></a>票据许可服务交换：获得ST</h4><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89Kerberos/image-20201019141907104.png" alt="image-20201019141907104"></p>
<p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89Kerberos/image-20201019141920821.png" alt="image-20201019141920821"></p>
<h4 id="客户-服务器认证交换：获得服务"><a href="#客户-服务器认证交换：获得服务" class="headerlink" title="客户/服务器认证交换：获得服务"></a>客户/服务器认证交换：获得服务</h4><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89Kerberos/image-20201019141931124.png" alt="image-20201019141931124"></p>
<h4 id="Kerberos和多个域"><a href="#Kerberos和多个域" class="headerlink" title="Kerberos和多个域"></a>Kerberos和多个域</h4><ul>
<li>完整的Kerberos环境包括Kerberos服务器、一组工作站和一组应用服务器<ul>
<li>所有用户和服务器均在Kerberos服务器上注册。</li>
<li>Kerberos服务器必须在数据库中拥有所有用户的ID和口令散列表。</li>
<li>Kerberos服务器必须与每一个服务器之间共享一个保密密钥。</li>
</ul>
</li>
<li>对于不同的域<ul>
<li>每个辖区的Kerberos服务器与其他辖区的Kerberos服务器之间共享一个保密密钥，两个服务器互相注册。</li>
</ul>
</li>
</ul>
<h4 id="跨域认证"><a href="#跨域认证" class="headerlink" title="跨域认证"></a>跨域认证</h4><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89Kerberos/image-20201019142401641.png" alt="image-20201019142401641"></p>
<p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89Kerberos/image-20201019142408521.png" alt="image-20201019142408521"></p>
<h3 id="Kerberos-Version-5"><a href="#Kerberos-Version-5" class="headerlink" title="Kerberos Version 5"></a>Kerberos Version 5</h3><ul>
<li>标准化为RFC 1510</li>
<li>改进之处</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>v4</th>
<th>v5</th>
</tr>
</thead>
<tbody>
<tr>
<td>加密算法</td>
<td>DES</td>
<td>扩展</td>
</tr>
<tr>
<td>网络协议地址</td>
<td>IP</td>
<td>OSI</td>
</tr>
<tr>
<td>票据生命周期</td>
<td>最大1280min</td>
<td>不限制</td>
</tr>
<tr>
<td>认证转发</td>
<td></td>
<td>允许服务器在事务中代表客户端访问另一台服务器</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>双重加密<ul>
<li>V4中的票据被重复加密</li>
</ul>
</li>
<li>消息重放<ul>
<li>AS-&gt;Client和TGS-&gt;Client消息在票据生命周期中或可被重放，V5采用新鲜数。</li>
<li>采用同一票据的多个cs连接使用相同的会话密钥，因而会遭受重放，<strong>V5使用subkey机制</strong>。</li>
</ul>
</li>
</ul>
<p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89Kerberos/image-20201028140902276.png" alt="image-20201028140902276"></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>认证方法<ul>
<li>本地机器录入密码</li>
<li>经由中央KDC认证</li>
<li>网上不传输密码</li>
</ul>
</li>
<li>单点登录<ul>
<li>KDC给予票据TGT</li>
<li>TGT可以用于获取其他的服务票据</li>
</ul>
</li>
<li>优点<ul>
<li>密码不容易被窃听</li>
<li>密码不在网上传输</li>
<li>密码猜测更困难</li>
<li>单点登录<ul>
<li>便捷，不用记忆多个口令。</li>
</ul>
</li>
<li>票据被盗之后难以使用，因为需要配合认证头来使用。</li>
</ul>
</li>
</ul>
<h2 id="Windows下的Kerberos应用"><a href="#Windows下的Kerberos应用" class="headerlink" title="Windows下的Kerberos应用"></a>Windows下的Kerberos应用</h2><ul>
<li>Windows 2000中代替了NTLM<ul>
<li>支持公钥加密来保护client/AS消息</li>
<li>允许使用基于smart cards的认证</li>
<li>使用了Kerberos数据授权字段</li>
<li>传递Win2K访问控制权限</li>
<li>源于Active Directory，以SIDs的形式。</li>
<li>消息格式公开，单为微软专有。</li>
</ul>
</li>
</ul>
<h3 id="Windows下域登录的机理"><a href="#Windows下域登录的机理" class="headerlink" title="Windows下域登录的机理"></a>Windows下域登录的机理</h3><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89Kerberos/image-20201028142153918.png" alt="image-20201028142153918"></p>
<p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89Kerberos/image-20201028142208733.png" alt="image-20201028142208733"></p>
<h4 id="开始步骤"><a href="#开始步骤" class="headerlink" title="开始步骤"></a>开始步骤</h4><ul>
<li>CTRL + ALT + DEL</li>
<li>Winlogon service &amp; GINA (MSGINA.DLL)</li>
<li>用户输入被转到LSA</li>
<li>LSA加密缓存并经有Kerberos SSP和KDC交互</li>
</ul>
<h4 id="交互过程"><a href="#交互过程" class="headerlink" title="交互过程"></a>交互过程</h4><ul>
<li>LSA向KDC发送KRB_AS_REQ消息<ul>
<li>包括主体名称Alice和域名，加密密钥基于Alice口令生成。</li>
</ul>
</li>
<li>KDC返回KRB_AS_REO消息<ul>
<li>包括会话密钥、TGT、授权数据（SID）。</li>
</ul>
</li>
<li>LSA向KDC发送KRB_TGS_REQ消息<ul>
<li>包括目标计算机名Bob、目标计算级域名、TGT、认证头。</li>
</ul>
</li>
<li>KDC返回KRB_TGS_REP消息<ul>
<li>包括会话密钥（被Alice与KDC的会话密钥加密）、会话票据（被Bob和KDC的会话密钥加密）</li>
<li>会话票据包括Bob和Alice的会话密钥和TGT中的授权数据。</li>
</ul>
</li>
</ul>
<h4 id="组装本地令牌"><a href="#组装本地令牌" class="headerlink" title="组装本地令牌"></a>组装本地令牌</h4><ul>
<li>收到Alice的会话票据后，LSA解密并提取出授权数据。</li>
<li>查询本地SAM数据库，检查Alice是否属于本地安全组及其可能被授予的特权。</li>
<li>若有，则将所查询得到的SIDs加入授权数据的列表，根据此构造访问令牌，将令牌句柄和Alice会话的ID，确认返回给Winlogon。</li>
</ul>
<h4 id="进入系统"><a href="#进入系统" class="headerlink" title="进入系统"></a>进入系统</h4><ul>
<li>Winlogon创建窗口和桌面对象并且附带令牌，启动Shell。</li>
<li>Alice的访问令牌被其进程所继承。</li>
</ul>
]]></content>
      <categories>
        <category>Internet安全协议与分析</category>
      </categories>
      <tags>
        <tag>Kerberos</tag>
      </tags>
  </entry>
  <entry>
    <title>Internet安全协议与分析（八）课程复习</title>
    <url>/2020/10/31/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AB%EF%BC%89%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<p>复习所学知识，应付考试orz。</p>
<a id="more"></a>
<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><h3 id="挑战-应答"><a href="#挑战-应答" class="headerlink" title="挑战-应答"></a>挑战-应答</h3><ul>
<li>客户端向服务器发出请求，请求身份认证。</li>
<li>服务器查询用户是否合法，合法则进行下一步。</li>
<li>服务器产生随机数，作为“挑战”发给客户端。</li>
<li>客户端将ID和随机数Hash，发送给服务器。</li>
<li>服务器比较结果，相同则通过认证，并通知客户端。</li>
</ul>
<h3 id="数字信封"><a href="#数字信封" class="headerlink" title="数字信封"></a>数字信封</h3><ul>
<li>将对称密钥通过非对称加密的方式分发。</li>
<li>发送方用对称密钥加密明文，并用接收方公钥加密对称密钥，将消息发给接收方。</li>
<li>接收方用私钥解密获得对称密钥，随后解密得到明文。</li>
</ul>
<h3 id="公钥环-amp-私钥环"><a href="#公钥环-amp-私钥环" class="headerlink" title="公钥环&amp;私钥环"></a>公钥环&amp;私钥环</h3><ul>
<li>公钥环保存该结点拥有的其他用户的公钥</li>
<li>私钥环保存该节点拥有的公私钥对（加密）</li>
</ul>
<h3 id="隧道模式"><a href="#隧道模式" class="headerlink" title="隧道模式"></a>隧道模式</h3><ul>
<li><p>AH</p>
<p><img src="/2020/10/31/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AB%EF%BC%89%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/image-20201031143043915.png" alt="image-20201031143043915"></p>
</li>
<li><p>ESP</p>
<p><img src="/2020/10/31/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AB%EF%BC%89%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/image-20201031143105550.png" alt="image-20201031143105550"></p>
</li>
</ul>
<h2 id="简答"><a href="#简答" class="headerlink" title="简答"></a>简答</h2><h3 id="BAN分析Otway-Rees"><a href="#BAN分析Otway-Rees" class="headerlink" title="BAN分析Otway-Rees"></a>BAN分析Otway-Rees</h3><ul>
<li>密钥有效性</li>
</ul>
<script type="math/tex; mode=display">
bel(A, goodkey(S, K_{as}, S)) \\
bel(B, goodkey(S, K_{bs}, S))</script><ul>
<li>S的权威性</li>
</ul>
<script type="math/tex; mode=display">
bel(A, cont(S, skey(A, K_{ab}, B))) \\ 
bel(B, cont(S, skey(A, K_{ab}, B))) \\
bel(A, cont(S, fresh(skey(A, K_{ab}, B)))</script><ul>
<li>随机数的新鲜性</li>
</ul>
<script type="math/tex; mode=display">
bel(A, fresh(N_a)) \\
bel(B, fresh(N_b))</script><h3 id="Kerberos协议中Ticket-v和认证头的结构和作用"><a href="#Kerberos协议中Ticket-v和认证头的结构和作用" class="headerlink" title="Kerberos协议中Ticket_v和认证头的结构和作用"></a>Kerberos协议中<script type="math/tex">Ticket_v</script>和认证头的结构和作用</h3><ul>
<li><script type="math/tex">Ticket_v</script>表示该用户已被AS认证</li>
<li>验证头用于验证ticket有效</li>
</ul>
<h3 id="安全协议中Nonce和时戳的作用和区别"><a href="#安全协议中Nonce和时戳的作用和区别" class="headerlink" title="安全协议中Nonce和时戳的作用和区别"></a>安全协议中Nonce和时戳的作用和区别</h3><ul>
<li>随机数是为了提供消息的新鲜性<ul>
<li>可以用于挑战应答，只使用一次，防止重放攻击。</li>
</ul>
</li>
<li>时戳依赖于时钟的同步。</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="PGP"><a href="#PGP" class="headerlink" title="PGP"></a>PGP</h3><ul>
<li>发送方<ul>
<li>签名消息<ul>
<li>使用用户ID作为索引获取发送者的私钥</li>
<li>提示用户输入口令解密私钥</li>
<li>创建签名</li>
</ul>
</li>
<li>加密消息<ul>
<li>生成会话密钥，加密消息。</li>
<li>使用用户ID作为索引获取接收方公钥</li>
<li>创建会话消息</li>
</ul>
</li>
</ul>
</li>
<li>接收方<ul>
<li>解密消息<ul>
<li>使用消息内ID字段作为索引获取私钥</li>
<li>提示用户输入密钥解密私钥</li>
<li>恢复会话密钥，解密消息。</li>
</ul>
</li>
<li>认证消息<ul>
<li>使用签名密钥ID作为索引获取公钥</li>
<li>恢复消息摘要</li>
<li>计算消息摘要并和传输版本比较认证</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Internet安全协议与分析</category>
      </categories>
  </entry>
  <entry>
    <title>Internet安全协议与分析（六）BAN</title>
    <url>/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/</url>
    <content><![CDATA[<p>介绍基于推理结构性方法。</p>
<a id="more"></a>
<h2 id="安全协议的形式化分析"><a href="#安全协议的形式化分析" class="headerlink" title="安全协议的形式化分析"></a>安全协议的形式化分析</h2><ul>
<li>目前的技术主要用于对密钥正确的认证。</li>
<li>安全协议的形式化有助于减轻协议设计者的工作量<ul>
<li>界定安全协议的边界，即协议系统与其运行环境的界面。</li>
<li>更准确地描述安全协议的行为。</li>
<li>更准确地定义安全协议的特性。</li>
<li>证明安全协议满足其说明，以及证明安全协议在什么条件下不能满足其说明。</li>
</ul>
</li>
</ul>
<h3 id="逻辑—推理结构性方法简介"><a href="#逻辑—推理结构性方法简介" class="headerlink" title="逻辑—推理结构性方法简介"></a>逻辑—推理结构性方法简介</h3><ul>
<li>运用逻辑系统从用户接收和发送的消息出发，通过一系列的推理公理推证协议是否满足其安全说明。</li>
<li>典型：BAN逻辑、Kailer逻辑、RV逻辑。</li>
<li>特点<ul>
<li>简洁直观，易于使用。</li>
<li>理想化方法。分析协议之前对协议进行形式化处理，依赖经验。</li>
<li>使用假设和推理规则。<ul>
<li>假设不正确，不能得到正确的信念。</li>
<li>公理和推理规则是否合理和完备也影响性能。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="BAN逻辑系统"><a href="#BAN逻辑系统" class="headerlink" title="BAN逻辑系统"></a>BAN逻辑系统</h2><ul>
<li>定义：基于主体知识和信念推理的模态逻辑。</li>
<li>过程：通过推导主体是否能够从接收到的消息中获得信念来判断协议是否能够达到认证目标。</li>
</ul>
<h3 id="常用符号"><a href="#常用符号" class="headerlink" title="常用符号"></a>常用符号</h3><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/image-20201019144255278.png" alt="image-20201019144255278"></p>
<p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/image-20201019144302408.png" alt="image-20201019144302408"></p>
<h3 id="推理规则"><a href="#推理规则" class="headerlink" title="推理规则"></a>推理规则</h3><h4 id="消息意义规则"><a href="#消息意义规则" class="headerlink" title="消息意义规则"></a>消息意义规则</h4><ul>
<li>从加密消息所使用的密钥以及消息中包含的秘密来推断消息发送者的身份</li>
</ul>
<p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/image-20201019144714766.png" alt="image-20201019144714766"></p>
<h4 id="随机数验证规则"><a href="#随机数验证规则" class="headerlink" title="随机数验证规则"></a>随机数验证规则</h4><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/image-20201019144948197.png" alt="image-20201019144948197"></p>
<h4 id="仲裁规则"><a href="#仲裁规则" class="headerlink" title="仲裁规则"></a>仲裁规则</h4><ul>
<li>拓展主体的推知能力，使主体可以基于已有信仰上推知新的信仰。</li>
</ul>
<p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/image-20201019145140729.png" alt="image-20201019145140729"></p>
<h4 id="信念规则"><a href="#信念规则" class="headerlink" title="信念规则"></a>信念规则</h4><ul>
<li>反映信念在消息的级联与分割的不同操作中的一致性以及信仰在此类操作中的传递性。</li>
</ul>
<p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/image-20201019145246885.png" alt="image-20201019145246885"></p>
<h4 id="接收规则"><a href="#接收规则" class="headerlink" title="接收规则"></a>接收规则</h4><ul>
<li>定义了主体在协议运行中获取消息</li>
</ul>
<p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/image-20201019145343321.png" alt="image-20201019145343321"></p>
<h4 id="新鲜规则"><a href="#新鲜规则" class="headerlink" title="新鲜规则"></a>新鲜规则</h4><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/image-20201019145354518.png" alt="image-20201019145354518"></p>
<h4 id="传递规则"><a href="#传递规则" class="headerlink" title="传递规则"></a>传递规则</h4><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/image-20201019145402495.png" alt="image-20201019145402495"></p>
<h3 id="若干假设"><a href="#若干假设" class="headerlink" title="若干假设"></a>若干假设</h3><h4 id="时间假设"><a href="#时间假设" class="headerlink" title="时间假设"></a>时间假设</h4><ul>
<li>current-time：起始于本次协议运行的开始阶段</li>
<li>past-time：current-time之前的时间</li>
<li>如果某一观点在协议开始时是成立的，那么在整个current-time中也是成立的，但是在past-time中成立的观点在current-time中却并不一定成立。</li>
</ul>
<h4 id="密钥假设"><a href="#密钥假设" class="headerlink" title="密钥假设"></a>密钥假设</h4><ul>
<li>密钥不能从密文中推导出来。</li>
<li>不拥有正确密钥不能解密报文。</li>
<li>主体能够知道他是否正确地使用了解密密钥。正确的密钥解密得到的明文有意义，错误的密钥解密得到的明文没有意义。</li>
</ul>
<h4 id="主体假设"><a href="#主体假设" class="headerlink" title="主体假设"></a>主体假设</h4><ul>
<li>假设参与协议运行的主体都是诚实的。</li>
</ul>
<h4 id="自身消息可识别假设"><a href="#自身消息可识别假设" class="headerlink" title="自身消息可识别假设"></a>自身消息可识别假设</h4><ul>
<li>假设接收方能分辨接收到的消息是否为自己发送过的消息。使得消息含义规则的成立有合理性。</li>
</ul>
<h3 id="应用BAN逻辑"><a href="#应用BAN逻辑" class="headerlink" title="应用BAN逻辑"></a>应用BAN逻辑</h3><ul>
<li>对协议进行理想化预处理（初始化）</li>
<li>给出协议初始状态及其所基于的假设。</li>
<li>形式化说明协议将达成的安全目标。</li>
<li>运用公理和推理规则以及协议会话事实和假设，从协议的开始进行推证直至验证协议是否满足最终运行目标。</li>
</ul>
<p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/image-20201019150350421.png" alt="image-20201019150350421"></p>
<h4 id="实例：NS协议漏洞"><a href="#实例：NS协议漏洞" class="headerlink" title="实例：NS协议漏洞"></a>实例：NS协议漏洞</h4><p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/image-20201019150426012.png" alt="image-20201019150426012"></p>
<p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/image-20201019150432923.png" alt="image-20201019150432923"></p>
<p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/image-20201019150438422.png" alt="image-20201019150438422"></p>
<p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/image-20201019150445257.png" alt="image-20201019150445257"></p>
<p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/image-20201019150451862.png" alt="image-20201019150451862"></p>
<p>goodkey = skey + fresh</p>
<p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/image-20201019150458530.png" alt="image-20201019150458530"></p>
<p><img src="/2020/10/19/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89BAN/image-20201019150504901.png" alt="image-20201019150504901"></p>
<h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><ul>
<li>省略掉对于推知主体信仰无用部分，如明文。</li>
<li>协议的理想化过于依赖于分享者的直觉，使得原始协议与理想化协议间存在语义鸿沟。</li>
<li>协议的理想化是将协议过程语言中对协议主体行为的描述解释为用逻辑语言描述的主体的知识和信仰，并以此来表示协议说明的语义。现有的逻辑形式化分析系统很难解决此问题。</li>
<li>BAN证明没有问题，并不能保证该协议没有问题。</li>
</ul>
]]></content>
      <categories>
        <category>Internet安全协议与分析</category>
      </categories>
      <tags>
        <tag>BAN</tag>
      </tags>
  </entry>
  <entry>
    <title>Internet安全协议与分析（四）PGP</title>
    <url>/2020/10/17/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89PGP/</url>
    <content><![CDATA[<p>介绍PGP协议。</p>
<a id="more"></a>
<h2 id="电子邮件概述"><a href="#电子邮件概述" class="headerlink" title="电子邮件概述"></a>电子邮件概述</h2><ul>
<li>电子邮件不是一种端到端的服务，而是一种<strong>存储转发式</strong>的服务。</li>
<li>一个完整的电子邮件系统包括三个主要成分<ul>
<li>客户端用户代理MUA（mail user agent）</li>
<li>邮件传输代理MTA（mail transfer agent）</li>
<li>邮件投递代理MDA（mail delivery agent）</li>
</ul>
</li>
<li>电子邮件相关协议<ul>
<li>SMTP、POP3、IMAP、MIME</li>
</ul>
</li>
</ul>
<h3 id="电子邮件系统安全问题"><a href="#电子邮件系统安全问题" class="headerlink" title="电子邮件系统安全问题"></a>电子邮件系统安全问题</h3><ul>
<li>匿名转发<ul>
<li>发件人隐瞒自己的电子邮箱地址和其他信息</li>
<li>用户必须使用邮件加密和数字签名技术</li>
</ul>
</li>
<li>电子邮件欺骗<ul>
<li>假冒一个用户身份给其他用户发送邮件</li>
<li>通过身份认证避免邮件欺骗</li>
</ul>
</li>
<li>邮件炸弹和垃圾邮件<ul>
<li>安装过滤器，预先检查发件人资料。</li>
</ul>
</li>
<li>邮件病毒<ul>
<li>通过预杀毒防止病毒的传播</li>
</ul>
</li>
</ul>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul>
<li>端到端的安全电子邮件技术<ul>
<li>S/MIME和PGP，<strong>一般只对信体进行加密和签名，而信头必须保证原封不动</strong>。</li>
</ul>
</li>
<li>要求信头在传输过程中也保密，使用传输层技术作为后盾<ul>
<li>使用SSL SMTP和SSL POP</li>
<li>使用VPN或其他IP通道技术</li>
</ul>
</li>
<li>邮件服务器本身安全可靠</li>
</ul>
<h2 id="PGP"><a href="#PGP" class="headerlink" title="PGP"></a>PGP</h2><ul>
<li>Pretty Good Privacy</li>
</ul>
<p><img src="/2020/10/17/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89PGP/image-20201017152042892.png" alt="image-20201017152042892"></p>
<h3 id="PGP数字签名与认证"><a href="#PGP数字签名与认证" class="headerlink" title="PGP数字签名与认证"></a>PGP数字签名与认证</h3><ul>
<li>发送者<ul>
<li>产生消息M</li>
<li>使用SHA-1生成160位散列码H</li>
<li>使用私钥签名，并与M连接。</li>
</ul>
</li>
<li>接收方<ul>
<li>使用公钥解密，恢复散列码H。</li>
<li>计算M的散列码，与H比较，两者匹配则报文通过鉴别。</li>
</ul>
</li>
</ul>
<p><img src="/2020/10/17/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89PGP/image-20201017152232211.png" alt="image-20201017152232211"></p>
<h3 id="保密性操作"><a href="#保密性操作" class="headerlink" title="保密性操作"></a>保密性操作</h3><ul>
<li>发送者<ul>
<li>生成消息M和128位随机数作为会话密钥</li>
<li>使用CAST-128（或IDEA或3DES）加密报文</li>
<li>用接收者的公钥加密会话密钥，并与M连接。</li>
</ul>
</li>
<li>接收者<ul>
<li>使用私钥解密报文，恢复会话密钥。</li>
<li>用会话密钥解密恢复消息M。</li>
</ul>
</li>
</ul>
<p><img src="/2020/10/17/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89PGP/image-20201017152649242.png" alt="image-20201017152649242"></p>
<h3 id="PGP加密认证处理过程"><a href="#PGP加密认证处理过程" class="headerlink" title="PGP加密认证处理过程"></a>PGP加密认证处理过程</h3><p><img src="/2020/10/17/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89PGP/image-20201017153058600.png" alt="image-20201017153058600"></p>
<h3 id="PGP密钥环"><a href="#PGP密钥环" class="headerlink" title="PGP密钥环"></a>PGP密钥环</h3><ul>
<li>PGP在每个结点提供一对数据结构<ul>
<li>私钥环——存储该节点拥有的公开/私有密钥对</li>
<li>公钥环——存储该节点知道的其他所有用户的公开密钥</li>
</ul>
</li>
</ul>
<p><img src="/2020/10/17/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89PGP/image-20201017153356367.png" alt="image-20201017153356367"></p>
<h3 id="信任网"><a href="#信任网" class="headerlink" title="信任网"></a>信任网</h3><ul>
<li>通过自己的数字签名进行确认</li>
<li>通过自己完全信任的人的数字签名进行确认</li>
<li>通过自己有限信任的多个人的数字签名进行确认</li>
</ul>
]]></content>
      <categories>
        <category>Internet安全协议与分析</category>
      </categories>
      <tags>
        <tag>PGP</tag>
      </tags>
  </entry>
  <entry>
    <title>Internet安全协议与分析（零）安全协议基础</title>
    <url>/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>介绍密码学的基础知识，包括公钥体制、数字签名、密钥分配等。</p>
<a id="more"></a>
<h2 id="信息安全"><a href="#信息安全" class="headerlink" title="信息安全"></a>信息安全</h2><h3 id="信息安全的范围"><a href="#信息安全的范围" class="headerlink" title="信息安全的范围"></a>信息安全的范围</h3><ul>
<li>物理安全</li>
<li>计算机安全</li>
<li>网络安全</li>
</ul>
<h3 id="信息安全的目标"><a href="#信息安全的目标" class="headerlink" title="信息安全的目标"></a>信息安全的目标</h3><ul>
<li>保密性</li>
<li>完整性</li>
<li>可用性</li>
</ul>
<h3 id="计算机网络面临的安全性威胁"><a href="#计算机网络面临的安全性威胁" class="headerlink" title="计算机网络面临的安全性威胁"></a>计算机网络面临的安全性威胁</h3><p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027143622649.png" alt="image-20201027143622649"></p>
<h2 id="密码学回顾"><a href="#密码学回顾" class="headerlink" title="密码学回顾"></a>密码学回顾</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>明文、密文、加密（算法）、解密（算法）</p>
<p>加密系统可以用五元组描述（P, C, K, E, D）</p>
<ul>
<li>P表示明文空间</li>
<li>C表示密文空间</li>
<li>K表示密钥空间</li>
<li>E表示加密算法</li>
<li>D表示解密算法</li>
</ul>
<p>数据加密系统可以用下图表示</p>
<p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027143901553.png" alt="image-20201027143901553"></p>
<h3 id="密码体制"><a href="#密码体制" class="headerlink" title="密码体制"></a>密码体制</h3><h4 id="对称密钥"><a href="#对称密钥" class="headerlink" title="对称密钥"></a>对称密钥</h4><ul>
<li>加密密钥和解密密钥相同</li>
<li>DES是一种分组密码<ul>
<li>加密前对明文分组，组长64位。</li>
<li>密钥为64位（8位用于奇偶校验）</li>
</ul>
</li>
</ul>
<h4 id="公钥体制"><a href="#公钥体制" class="headerlink" title="公钥体制"></a>公钥体制</h4><ul>
<li><p>使用不同的加密密钥和解密密钥</p>
</li>
<li><p>可以解决密钥分配问题，也用于数字签名。</p>
</li>
<li><p>公钥不能用于解密</p>
<script type="math/tex; mode=display">
D_{PK_B}(E_{PK_B}(X))\neq X</script></li>
<li><p>加密和解密可以对调</p>
<script type="math/tex; mode=display">
D_{PK_B}(E_{SK_B}(X)) = D_{SK_B}(E_{PK_B}(X)) = X</script></li>
</ul>
<h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><ul>
<li>签名者事后不能否认自己的签名。</li>
<li>接收者可以验证签名，但其他人不能伪造签名。</li>
<li>双方关于签名真伪发生争执时，第三方可以解决争执。</li>
</ul>
<h4 id="鉴别"><a href="#鉴别" class="headerlink" title="鉴别"></a>鉴别</h4><ul>
<li>发送方用自己的私钥加密摘要，附到明文之后。</li>
<li>提供完整性鉴别，但不提供保密性。</li>
<li>为了满足保密性，需要结合加密。</li>
</ul>
<p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027144539975.png" alt="image-20201027144539975"></p>
<h4 id="数字信封"><a href="#数字信封" class="headerlink" title="数字信封"></a>数字信封</h4><ul>
<li>发送方用对称密钥加密明文，并用接收方的公钥加密对称密钥，附到密文之后。</li>
</ul>
<p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027144803675.png" alt="image-20201027144803675"></p>
<h4 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h4><ul>
<li>用户提交公钥等信息P，CA机构用私钥签名摘要产生S，P和S一起被称为数字证书。</li>
<li>用户可以用CA的公钥解密获取证书里的公钥，结合数字签名，验证证书的完整性。</li>
<li>下图的解释<ul>
<li>发送方首先产生摘要，用自己的私钥加密形成数字签名，附到消息之后。</li>
<li>因为有数字签名，所以接收方需要获得发送方的公钥，发送方需要发送自己的数字证书。</li>
<li>因为需要传递对称密钥，所以需要数字信封，用接收方的公钥加密对称密钥。</li>
<li>接收方收到消息后，首先用私钥解密获得对称密钥，随后解密获得明文。用CA公钥验证证书的完整性，由此获得发送方的公钥，用其解密数字签名，确保消息没有被篡改。</li>
<li>满足了保密性和完整性。</li>
</ul>
</li>
</ul>
<p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027145220754.png" alt="image-20201027145220754"></p>
<h2 id="基于Hash的鉴别"><a href="#基于Hash的鉴别" class="headerlink" title="基于Hash的鉴别"></a>基于Hash的鉴别</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ul>
<li>直接Hash</li>
</ul>
<p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027151324589.png" alt="image-20201027151324589"></p>
<ul>
<li>与加密结合</li>
</ul>
<p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027151338394.png" alt="image-20201027151338394"></p>
<ul>
<li>结合公钥体制（数字签名）</li>
</ul>
<p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027151349653.png" alt="image-20201027151349653"></p>
<ul>
<li>结合对称密钥体制</li>
</ul>
<p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027151400579.png" alt="image-20201027151400579"></p>
<ul>
<li>加盐</li>
</ul>
<p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027151416972.png" alt="image-20201027151416972"></p>
<ul>
<li>大杂烩</li>
</ul>
<p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027151432750.png" alt="image-20201027151432750"></p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li>根据安全水平<ul>
<li>弱无碰撞</li>
<li>强无碰撞</li>
</ul>
</li>
<li>根据是否使用密钥<ul>
<li>带私密密钥，此时称作MAC。</li>
<li>不带私密密钥，此时称为MDC。</li>
</ul>
</li>
</ul>
<h2 id="密钥管理与分配"><a href="#密钥管理与分配" class="headerlink" title="密钥管理与分配"></a>密钥管理与分配</h2><h3 id="密钥生命周期"><a href="#密钥生命周期" class="headerlink" title="密钥生命周期"></a>密钥生命周期</h3><ul>
<li>产生、存储、使用、更新、删除</li>
</ul>
<p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027152018368.png" alt="image-20201027152018368"></p>
<h3 id="对称密钥的分配"><a href="#对称密钥的分配" class="headerlink" title="对称密钥的分配"></a>对称密钥的分配</h3><ul>
<li>设立密钥分配中心KDC。</li>
<li>KDC给需要进行秘密通信的用户临时分配一个会话密钥。</li>
<li>KDC的登记用户在KDC的服务器上安装了自己与KDC进行通信的主密钥，可简称为密钥。</li>
</ul>
<p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027152326907.png" alt="image-20201027152326907"></p>
<h4 id="基于公钥体制的对称密钥分配"><a href="#基于公钥体制的对称密钥分配" class="headerlink" title="基于公钥体制的对称密钥分配"></a>基于公钥体制的对称密钥分配</h4><ul>
<li>公钥密码体制未必在通讯中直接使用，但却很适合用于对称密钥分配。</li>
</ul>
<p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027152457757.png" alt="image-20201027152457757"></p>
<p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027152509596.png" alt="image-20201027152509596"></p>
<h3 id="公钥体制的密钥分配"><a href="#公钥体制的密钥分配" class="headerlink" title="公钥体制的密钥分配"></a>公钥体制的密钥分配</h3><h4 id="公开发布"><a href="#公开发布" class="headerlink" title="公开发布"></a>公开发布</h4><p>用户将自己的公钥发给其他用户，一般将公钥附在消息上（PGP）。</p>
<ul>
<li>实现简单</li>
<li>容易假冒</li>
</ul>
<h4 id="公用目录表"><a href="#公用目录表" class="headerlink" title="公用目录表"></a>公用目录表</h4><p>建立一个公用的公钥动态目录表，由可信的实体建立、维护和发布。</p>
<ul>
<li>有一定的安全性</li>
<li>目录表容易受到攻击</li>
</ul>
<h4 id="公钥授权"><a href="#公钥授权" class="headerlink" title="公钥授权"></a>公钥授权</h4><p>在公钥目录表的基础上，由公钥管理机构为用户建立、维护和发布公钥目录表。</p>
<p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027155129036.png" alt="image-20201027155129036"></p>
<h4 id="公钥证书"><a href="#公钥证书" class="headerlink" title="公钥证书"></a>公钥证书</h4><p>用户通过公钥证书相互交换公钥，公钥证书由CA为用户建立。</p>
<p>公钥证书的数据项包括</p>
<ul>
<li>用户的公钥、用户身份标识和时间戳等。</li>
<li>所有数据项经CA的私钥签名后形成证书。</li>
</ul>
<p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027155335650.png" alt="image-20201027155335650"></p>
<p><img src="/2020/10/27/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E9%9B%B6%EF%BC%89%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/image-20201027155414152.png" alt="image-20201027155414152"></p>
]]></content>
      <categories>
        <category>Internet安全协议与分析</category>
      </categories>
      <tags>
        <tag>数字签名</tag>
        <tag>数字证书</tag>
        <tag>公钥体制</tag>
        <tag>Hash鉴别</tag>
        <tag>密钥分配</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/08/06/hello-world/</url>
    <content><![CDATA[<p>Hello, world!<br><a id="more"></a></p>
<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>搭建个人博客</title>
    <url>/2020/08/06/%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>采用Hexo+Next搭建个人博客，并通过Github Pages部署。</p>
<a id="more"></a>
<h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><ul>
<li>安装Node.js</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure>
<ul>
<li>安装Git</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure>
<ul>
<li>修改npm源</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取npm源</span></span><br><span class="line">npm get registry</span><br><span class="line"><span class="comment"># 修改为淘宝源</span></span><br><span class="line">npm config <span class="built_in">set</span> registry http://registry.npm.taobao.org/</span><br><span class="line"><span class="comment"># 重置</span></span><br><span class="line"><span class="comment"># npm config set registry https://registry.npmjs.org/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>安装Hexo</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<h2 id="部署网站"><a href="#部署网站" class="headerlink" title="部署网站"></a>部署网站</h2><ul>
<li>初始化文件夹</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line"><span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
<ul>
<li>至此网站已经初步搭建完成，通过如下命令本地查看。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># generate and start</span></span><br><span class="line">hexo g &amp;&amp; hexo s</span><br><span class="line"><span class="comment"># open http://localhost:4000</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>部署到Github</p>
<ul>
<li>首先申请一个Github账号，并上传SSH Key，可百度或参考<a href="https://www.cnblogs.com/itmyhome/p/4131245.html">教程</a>。</li>
<li>新建仓库，名为username.github.io。</li>
<li>安装插件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-developer-git --save</span><br></pre></td></tr></table></figure>
<ul>
<li>修改配置文件_config.yml</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:entropy2333/entropy2333.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>
<ul>
<li>部署网站</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><ul>
<li>修改基本信息</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># blog/_config.yml</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">entropy2333</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">entropy2333</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>修改主题</p>
<ul>
<li>下载主题</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next.git themes/next</span><br></pre></td></tr></table></figure>
<ul>
<li>修改配置文件</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># blog/_config.yml</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭广告</p>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># blog/themes/next/_config.yaml</span></span><br><span class="line"><span class="attr">powered:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>修改菜单栏</p>
<ul>
<li>添加菜单</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># blog/themes/next/_config.yaml</span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="comment">#categories: /categories/ || fa fa-th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || fa fa-calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || fa fa-sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || fa fa-heartbeat</span></span><br></pre></td></tr></table></figure>
<ul>
<li>生成文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成的文件位于hexo/source下</span></span><br><span class="line">hexo new page <span class="string">&quot;about&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改Next风格</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># blog/themes/next/_config.yaml</span></span><br><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Pisces</span></span><br><span class="line"><span class="comment">#scheme: Gemini</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改头像</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># blog/themes/next/_config.yaml</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="comment"># Replace the default image and set the url here.</span></span><br><span class="line">  <span class="comment"># url: #/images/avatar.gif</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">/images/myavatar.jpg</span></span><br><span class="line">  <span class="comment"># If true, the avatar will be dispalyed in circle.</span></span><br><span class="line">  <span class="attr">rounded:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># If true, the avatar will be rotated with the cursor.</span></span><br><span class="line">  <span class="attr">rotated:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>更多的个性化设置基本都是基于修改配置文件，修改完用hexo g &amp;&amp; hexo s本地查看是否生效，可查看参考文章或百度。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.bestzuo.cn/posts/blog-establish.html">Hexo博客+Next主题深度优化与定制</a></p>
<p><a href="https://www.jianshu.com/p/9f63b925b322">Hexo+NexT搭建个人博客</a></p>
<p><a href="https://blog.csdn.net/qq_33840251/article/details/103899972">Cannot read property ‘enable_sync’ of undefined</a></p>
]]></content>
  </entry>
  <entry>
    <title>统计学习方法（一）概论</title>
    <url>/2020/08/11/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%E6%A6%82%E8%AE%BA/</url>
    <content><![CDATA[<p>开始学习李航老师的《统计学习方法》。</p>
<a id="more"></a>
<h2 id="1-1-统计学习"><a href="#1-1-统计学习" class="headerlink" title="1.1 统计学习"></a>1.1 统计学习</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>统计学习也称为统计机器学习，计算机系统通过运用数据及统计方法提高系统性能的机器学习。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li>从给定的、有限的、用于学习的<strong>训练数据</strong>集合出发</li>
<li>假设数据独立同分布，要学习的模型属于某个函数的集合（<strong>假设空间</strong>）</li>
<li>应用某个<strong>评价准则</strong>，从假设空间中选取一个最优模型，使其对训练数据与<strong>测试数据</strong>有最优的预测</li>
<li>最优模型的选取由算法实现</li>
</ul>
<h3 id="三要素"><a href="#三要素" class="headerlink" title="三要素"></a>三要素</h3><ul>
<li>模型 model</li>
<li>策略 strategy</li>
<li>算法 algorithm</li>
</ul>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul>
<li>得到一个有限的训练数据集合</li>
<li>确定所有可能模型的假设空间，即学习模型的集合</li>
<li>确定模型选择的准则，即学习的策略</li>
<li>实现求解最优模型的算法，即学习的算法</li>
<li>通过学习方法选择最优模型</li>
<li>利用学习的最优模型对新数据进行预测或分析</li>
</ul>
<h2 id="1-2-监督学习"><a href="#1-2-监督学习" class="headerlink" title="1.2 监督学习"></a>1.2 监督学习</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>输入空间&amp;输出空间：输入与输出所有可能取值的集合</li>
<li>特征空间：所有特征向量存在的空间<ul>
<li>每个具体的输入是一个实例，通常由特征向量表示。</li>
<li>特征控件的每一维对应于每一个特征。</li>
</ul>
</li>
<li>样本：输入与输出对<script type="math/tex; mode=display">
T = \{(x_1, y_1), (x_2, y_2), ..., (x_N, y_N)\}</script></li>
<li>回归问题：X与Y均为连续变量</li>
<li>分类问题：Y为有限个离散变量</li>
<li>标注问题：X与Y均为变量序列</li>
</ul>
<h3 id="1-3-统计学习三要素"><a href="#1-3-统计学习三要素" class="headerlink" title="1.3 统计学习三要素"></a>1.3 统计学习三要素</h3><script type="math/tex; mode=display">
方法 = 模型+策略+算法</script><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>X和Y是定义在输入空间与输出空间上的变量，F通常是由一个参数向量决定的函数组，此时为非概率模型。</p>
<script type="math/tex; mode=display">
{\cal F} = \{f|Y = f_\theta(X), \theta\in R^n\}</script><p>假设空间也可以定义为条件概率的集合，此时表示的模型为概率模型。</p>
<script type="math/tex; mode=display">
{\cal F} = \{P|P_\theta(Y|X), \theta\in R^n\}</script><h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><h4 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h4><p>损失函数（loss function）或代价函数（cost function），度量预测错误的程度，是f(X)和Y的非负实值函数，记作L(Y, f(X))。</p>
<p>常用的损失函数：</p>
<script type="math/tex; mode=display">
\begin{align}
0-1: L(Y, f(X)) &=& \begin{cases} 1, Y\neq f(X) \\ 0, Y= f(X) \end{cases} \\
quadratic: L(Y, f(X)) &=& {(Y - f(X))}^2 \\
absolute: L(Y, f(X)) &=& |Y - f(X)| \\
logarithmic: L(Y, f(X)) &=& -logP(Y|X) \\
\end{align}</script><h4 id="风险函数"><a href="#风险函数" class="headerlink" title="风险函数"></a>风险函数</h4><p>风险函数，表示理论上模型关于联合分布平均意义下的损失。</p>
<script type="math/tex; mode=display">
R_{exp}(f) = E_p[L(Y, f(X))] = \int _{x\times y} L(y, f(x))P(x, y)dxdy</script><p>学习的目标是选择期望风险最小的模型，实际上P(X, Y)未知，所以才需要学习。</p>
<p>经验风险（empirical risk）定义为模型关于训练数据集的平均损失。</p>
<script type="math/tex; mode=display">
R_{emp}(f) = \frac 1 N \sum _{i=1} ^N L(y_i, f(x_i))</script><p>现实中训练样本数目有限，用经验风险估计并不理想，所以需要制定策略。</p>
<h4 id="风险最小化"><a href="#风险最小化" class="headerlink" title="风险最小化"></a>风险最小化</h4><ul>
<li>经验风险最小化（ERM）<ul>
<li>极大似然估计</li>
<li>容易产生过拟合</li>
</ul>
</li>
<li>结构风险最小化（SRM）<ul>
<li>等价于正则化，在经验风险上加上正则化项或罚项</li>
<li>最大后验概率估计</li>
</ul>
</li>
</ul>
<h2 id="1-4-模型评估与模型选择"><a href="#1-4-模型评估与模型选择" class="headerlink" title="1.4 模型评估与模型选择"></a>1.4 模型评估与模型选择</h2><h3 id="训练误差-amp-测试误差"><a href="#训练误差-amp-测试误差" class="headerlink" title="训练误差&amp;测试误差"></a>训练误差&amp;测试误差</h3><p>训练误差是模型关于训练集的平均损失</p>
<script type="math/tex; mode=display">
R_{emp}(f) = \frac 1 N \sum _{i=1} ^N L(y_i, f(x_i))</script><p>测试误差是模型关于测试集的平均损失</p>
<script type="math/tex; mode=display">
R_{test}(f) = \frac 1 N \sum _{i=1} ^N L(y_i, f(x_i))</script><h2 id="1-5-正则化与交叉验证"><a href="#1-5-正则化与交叉验证" class="headerlink" title="1.5 正则化与交叉验证"></a>1.5 正则化与交叉验证</h2><h3 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h3><p>正则化是结构风险最小化策略的实现，在经验风险上加一个正则化项或罚项。</p>
<p>正则化项一般是模型复杂度的单调递增函数，模型越复杂，正则化值越大。</p>
<script type="math/tex; mode=display">
\min _{f\in {\cal F}} \frac 1 N \sum _{i=1} ^N L(y_i, f(x_i)) + \lambda J(f)， \lambda \geq 0</script><script type="math/tex; mode=display">
L1: L(w) = \frac 1 N \sum _{i=1} ^N (f(x_i;w)-y_i)+ \frac \lambda 2 \Vert w\Vert ^2 \\
L2: L(w) = \frac 1 N \sum _{i=1} ^N (f(x_i;w)-y_i)+ \lambda \Vert w\Vert</script><blockquote>
<p>奥卡姆剃刀：在所有可能选择的模型中，能够很好解释已知数据并十分简单才是最好的模型。</p>
</blockquote>
<h3 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h3><ul>
<li>简单交叉验证<ul>
<li>将数据分为训练集与测试集</li>
</ul>
</li>
<li>S折交叉验证<ul>
<li>首先随机切分数据，分为S个大小相同的不相交子集。</li>
<li>用S-1个子集的数据训练模型，用余下的测试。</li>
<li>对S种选择重复进行，选出平均测试误差最小的模型。</li>
</ul>
</li>
<li>留一交叉验证</li>
</ul>
<h2 id="1-6-泛化能力"><a href="#1-6-泛化能力" class="headerlink" title="1.6 泛化能力"></a>1.6 泛化能力</h2><p>泛化能力，是指该方法学习到的模型对未知数据的预测能力。</p>
<script type="math/tex; mode=display">
泛化误差 \ \ R_{exp}(\hat f) = E_P[L(Y, \hat f(X))] = \int _{x\times y} L(y, \hat f(x))P(x,y)dxdy</script><h2 id="1-7-生成模型与判别模型"><a href="#1-7-生成模型与判别模型" class="headerlink" title="1.7 生成模型与判别模型"></a>1.7 生成模型与判别模型</h2><h2 id="1-8-分类问题"><a href="#1-8-分类问题" class="headerlink" title="1.8 分类问题"></a>1.8 分类问题</h2><h2 id="1-9-标注问题"><a href="#1-9-标注问题" class="headerlink" title="1.9 标注问题"></a>1.9 标注问题</h2><h2 id="1-10-回归问题"><a href="#1-10-回归问题" class="headerlink" title="1.10 回归问题"></a>1.10 回归问题</h2>]]></content>
      <categories>
        <category>统计学习方法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>统计学习方法（七）支持向量机</title>
    <url>/2020/08/19/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/</url>
    <content><![CDATA[<p>SVM是一种二分类模型，其基本模型是定义在特征空间上的间隔最大的线性分类器，间隔最大使其区别于感知机。</p>
<p>SVM包括Kernel trick，使其成为实质上的非线性分类器，SVM的学习策略是间隔最大化，学习算法是求解凸二次规划的最优化算法。</p>
<p>SVM包括三种模型：线性可分SVM、线性SVM、非线性SVM。</p>
<a id="more"></a>
<h2 id="7-1-线性可分SVM与硬间隔最大化"><a href="#7-1-线性可分SVM与硬间隔最大化" class="headerlink" title="7.1 线性可分SVM与硬间隔最大化"></a>7.1 线性可分SVM与硬间隔最大化</h2><h3 id="线性可分SVM"><a href="#线性可分SVM" class="headerlink" title="线性可分SVM"></a>线性可分SVM</h3><p>对于二分类问题，线性可分SVM假设输入空间与特征空间的元素一一对应。</p>
<p>给定训练集</p>
<script type="math/tex; mode=display">
T = \{(x_1,y_1),(x_2,y_2),\cdots,(x_N,y_N)\} \\
x_i\in{\cal X} = \mathbb{R}^n,\quad y_i\in{\cal Y}=\{-1,+1\}</script><p>假设训练数据集是<strong>线性可分</strong>的（见2.2）</p>
<p>通过间隔最大化或等价地求解相应的凸二次规划问题学习得到的分离超平面为</p>
<script type="math/tex; mode=display">
w^*\cdot x+b^*=0</script><p>相应的分类决策函数</p>
<script type="math/tex; mode=display">
f(x) = sign(w^*\cdot x+b^*)</script><p>称为线性可分SVM。</p>
<p><img src="/2020/08/19/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/1.png" alt></p>
<h3 id="函数间隔和几何间隔"><a href="#函数间隔和几何间隔" class="headerlink" title="函数间隔和几何间隔"></a>函数间隔和几何间隔</h3><p>对于给定的训练集T和超平面<script type="math/tex">(w,b)</script>，定义超平面关于样本点的函数间隔为</p>
<script type="math/tex; mode=display">
\hat\gamma_i = y_i(w\cdot x_i+b)</script><p>定义超平面关于训练集T的函数间隔为</p>
<script type="math/tex; mode=display">
\hat\gamma = \min_{i=1,\cdots,N}\hat\gamma_i</script><p>函数间隔可以表示分类预测的正确性及确信度，但成比例地改变参数时，超平面没有改变，函数间隔却成比例地改变，因此需要定义几何间隔。</p>
<p>某一实例点与超平面的距离为</p>
<script type="math/tex; mode=display">
\gamma_i=\frac w {\|w\|}\cdot x_i+\frac b {\|w\|}</script><p>其中<script type="math/tex">\|w\|</script>为<script type="math/tex">L_2</script>范数，如果实例点在超平面负的一侧，取负值即可。</p>
<p>因此定义几何间隔为</p>
<script type="math/tex; mode=display">
\gamma_i=y_i(\frac w {\|w\|}\cdot x_i+\frac b {\|w\|}) \\
\gamma = \min_{i=1,\cdots,N}\gamma_i</script><p>函数间隔和几何间隔满足如下关系</p>
<script type="math/tex; mode=display">
\gamma_i=\frac{\hat\gamma_i}{\|w\|},\quad \gamma=\frac{\hat\gamma}{\|w\|}</script><h3 id="间隔最大化"><a href="#间隔最大化" class="headerlink" title="间隔最大化"></a>间隔最大化</h3><p>SVM学习的基本想法是，求解能够划分训练集并且几何间隔最大的分离超平面。</p>
<p>对于线性可分的训练集，线性可分分离超平面有无穷多个，但集合间隔最大的分离超平面是唯一的。</p>
<p>下面考虑如何求解最大间隔分离超平面，表示为下面的约束最优化问题</p>
<script type="math/tex; mode=display">
\begin{align}
\max_{w,b} \quad&\gamma \\
s.t. \quad&y_i(\frac w {\|w\|}\cdot x_i+\frac b {\|w\|})\geq\gamma, \quad i=1,2,\cdots,N
\end{align}</script><p>利用几何间隔和函数间隔的关系</p>
<script type="math/tex; mode=display">
\begin{align}
\max_{w,b} \quad&\frac{\hat\gamma}{\|w\|} \\
s.t. \quad&y_i( w\cdot x_i+b)\geq\hat\gamma, \quad i=1,2,\cdots,N
\end{align}</script><p>取<script type="math/tex">\hat\gamma=1</script>，注意到最大化<script type="math/tex">\frac 1{\|w\|}</script>与最小化<script type="math/tex">\frac 1 2\|w\|^2</script>是等价的，由此将问题转化为</p>
<script type="math/tex; mode=display">
\begin{align}
\min_{w,b} \quad&\frac 1 2\|w\|^2 \\
s.t. \quad&y_i( w\cdot x_i+b)-1\geq0, \quad i=1,2,\cdots,N
\end{align} \tag{7.1}</script><p>这就是一个凸二次规划问题。</p>
<h4 id="凸优化问题"><a href="#凸优化问题" class="headerlink" title="凸优化问题"></a>凸优化问题</h4><p>凸优化问题是指约束最优化问题</p>
<script type="math/tex; mode=display">
\begin{align}
\min_w \quad& f(w) \\
s.t. \quad& g_i(w)\leq0, \quad i=1,2,\cdots,k\\
\quad &h_i(w)=0,\quad i=1,2,\cdots,l
\end{align}</script><p>其中，<script type="math/tex">f(w)</script>和<script type="math/tex">g_i(w)</script>都是<script type="math/tex">\R^n</script>上连续可微的凸函数，约束函数<script type="math/tex">h_i(w)</script>是<script type="math/tex">\R^n</script>上的仿射函数。</p>
<blockquote>
<script type="math/tex; mode=display">f(x)$$称为仿射函数，如果它满足$$f(x) = a\cdot x+b$$，其中$$a,x\in\mathbb{R}^n,b\in\mathbb{R}</script></blockquote>
<p>当<script type="math/tex">f(w)</script>是二次函数，且约束函数<script type="math/tex">g_i(w)</script>是仿射函数时，凸优化问题称为凸二次规划问题。</p>
<p>可以证明，最大间隔分离超平面是存在且唯一的。</p>
<h4 id="支持向量和间隔边界"><a href="#支持向量和间隔边界" class="headerlink" title="支持向量和间隔边界"></a>支持向量和间隔边界</h4><p>在线性可分情况下，训练集中的样本点与分离超平面距离最近的，称为支持向量。</p>
<p>支持向量满足等式</p>
<script type="math/tex; mode=display">
y_i(w\cdot x_i+b)-1=0</script><p>定义超平面</p>
<script type="math/tex; mode=display">
H_1: w\cdot x+b=1 \\
H_2: w\cdot x+b=-1</script><p>显然，在<script type="math/tex">H_1</script>和<script type="math/tex">H_2</script>上的点就是支持向量，这两个超平面成为间隔边界。。</p>
<p>注意到这两个超平面平行，并且没有实例点落在其中，由此形成一条长带。</p>
<p>两个超平面之间的距离成为间隔，它依赖于分离超平面的法向量<script type="math/tex">w</script>，等于<script type="math/tex">\frac 2{\|w\|}</script>。</p>
<p><img src="/2020/08/19/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/2.png" alt></p>
<p>在决定分离超平面时，只有支持向量起作用。如果在间隔边界以外移动其他实例点，甚至去掉这些点，超平面是不会改变的。</p>
<p>因为支持向量的决定性作用，所以讲这种分类模型称为支持向量机。</p>
<p>支持向量的个数一般很少，所以SVM由很少的“重要的”训练样本确定。</p>
<h3 id="学习的对偶算法"><a href="#学习的对偶算法" class="headerlink" title="学习的对偶算法"></a>学习的对偶算法</h3><p>利用拉格朗日对偶性，通过求解对偶问题得到原始问题的最优解。这样做的优点，一是对偶问题往往更容易求解；二是自然引入核函数，从而推广到非线性分类问题。</p>
<p>首先构造拉格朗日函数</p>
<script type="math/tex; mode=display">
L(w,b,\alpha) = \frac1 2{\|w\|}^2-\sum_{i=1}^N\alpha_iy_i(w\cdot x_i+b)+\sum_{i=1}^N\alpha_i \\
\alpha = (\alpha_1,\alpha_2,\cdots,\alpha_N)^T</script><p>根据对偶性，原始问题的对偶问题是</p>
<script type="math/tex; mode=display">
\max_\alpha\min_{w,b}L(w,b,\alpha)</script><p>分别求偏导数并令其等于0。</p>
<script type="math/tex; mode=display">
\nabla_wL(w,b,\alpha) = w-\sum_{i=1}^N\alpha_iy_ix_i = 0\\
\nabla_bL(w,b,\alpha) = -\sum_{i=1}^N\alpha_iy_i = 0</script><p>由此得到</p>
<script type="math/tex; mode=display">
w = \sum_{i=1}^N\alpha_iy_ix_i \\
\sum_{i=1}^N\alpha_iy_i=0</script><p>将其代入原函数</p>
<script type="math/tex; mode=display">
\begin{align}
L(w,b,\alpha) &= \frac12\sum_{i=1}^N\sum_{j=1}^N\alpha_i\alpha_jy_iy_j(x_i\cdot x_j) - \sum_{i=1}^N\alpha_iy_i((\sum_{j=1}^N\alpha_jy_jx_j)\cdot x_i+b)+\sum_{i=1}^N\alpha_i \\
&= -\frac12\sum_{i=1}^N\sum_{j=1}^N\alpha_i\alpha_jy_iy_j(x_i\cdot x_j)+\sum_{i=1}^N\alpha_i
\end{align}</script><p>对其求极大值</p>
<script type="math/tex; mode=display">
\begin{align}
\max_\alpha \quad& -\frac12\sum_{i=1}^N\sum_{j=1}^N\alpha_i\alpha_jy_iy_j(x_i\cdot x_j)+\sum_{i=1}^N\alpha_i \\
s.t. \quad& \sum_{i=1}^N\alpha_iy_i=0\\
\quad &\alpha_i\geq0,\quad i=1,2,\cdots,N
\end{align}</script><p>也即</p>
<script type="math/tex; mode=display">
\begin{align}
\min_\alpha \quad& \frac12\sum_{i=1}^N\sum_{j=1}^N\alpha_i\alpha_jy_iy_j(x_i\cdot x_j)-\sum_{i=1}^N\alpha_i \\
s.t. \quad& \sum_{i=1}^N\alpha_iy_i=0\\
\quad &\alpha_i\geq0,\quad i=1,2,\cdots,N
\end{align} \tag{7.2}</script><p>原始问题(7.1)转化为求解对偶问题(7.2)</p>
<p>假设<script type="math/tex">\alpha^*=(\alpha_1^*,\alpha_2^*,\cdots,\alpha_l^*)^T</script>为对偶最优化问题的解，则原始问题的解可通过如下关系求得</p>
<script type="math/tex; mode=display">
w^*=\sum_{i=1}^N\alpha_i^*y_ix_i \\
b^* = y_j-\sum_{i=1}^N\alpha_i^*y_i(x_i\cdot x_j),\quad\alpha_j^*>0</script><p>由此求得分离超平面和分类决策函数</p>
<script type="math/tex; mode=display">
w^*\cdot x+b^*=0 \\
f(x) = sign(w^*\cdot x+b^*)</script><p>对于线性可分问题，上述学习算法是完美的，但现实问题中，样本中会出现噪声或特异点，此时需要更一般的学习算法。</p>
<h2 id="7-2-线性SVM与软间隔最大化"><a href="#7-2-线性SVM与软间隔最大化" class="headerlink" title="7.2 线性SVM与软间隔最大化"></a>7.2 线性SVM与软间隔最大化</h2><h3 id="线性SVM"><a href="#线性SVM" class="headerlink" title="线性SVM"></a>线性SVM</h3><p>线性可分SVM的学习方法，对于线性不可分训练数据是不适用的，需要修改硬间隔最大化，使其成为软间隔最大化。</p>
<p>通常情况是，训练数据中有一些特异点（outlier），去除这些点后，剩下的样本点组成的集合是线性可分的。</p>
<p>通过引入松弛变量</p>
<script type="math/tex; mode=display">
y_i(w\cdot x_i+b)\geq1-\xi_i,\quad\xi_i\geq0</script><p>这样，目标函数变成</p>
<script type="math/tex; mode=display">
\frac12\|w\|^2\rightarrow\frac12\|w\|^2+C\sum_{i=1}^N\xi_i,\quad C>0</script><p>这里，C称为惩罚参数，使间隔尽量大，同时误分类点的个数尽量小。</p>
<p>由此，线性SVM的学习问题变成如下凸二次规划问题</p>
<script type="math/tex; mode=display">
\begin{align}
\min_{w,b,\xi} \quad&\frac12\|w\|^2+C\sum_{i=1}^N\xi_i \\
s.t. \quad&y_i( w\cdot x_i+b)\geq1-\xi_i,\quad  i=1,2,\cdots,N\\
\quad&\xi_i\geq0,\quad  i=1,2,\cdots,N
\end{align} \tag{7.3}</script><h3 id="学习的对偶算法-1"><a href="#学习的对偶算法-1" class="headerlink" title="学习的对偶算法"></a>学习的对偶算法</h3><p>通过拉格朗日函数，可以推导出(7.3)的对偶问题即为</p>
<script type="math/tex; mode=display">
\begin{align}
\min_\alpha \quad& \frac12\sum_{i=1}^N\sum_{j=1}^N\alpha_i\alpha_jy_iy_j(x_i\cdot x_j)-\sum_{i=1}^N\alpha_i \\
s.t. \quad& \sum_{i=1}^N\alpha_iy_i=0\\
\quad &0\leq\alpha_i\leq C_i,\quad i=1,2,\cdots,N
\end{align} \tag{7.4}</script><h3 id="支持向量"><a href="#支持向量" class="headerlink" title="支持向量"></a>支持向量</h3><p>在线性不可分的情况下，将对偶问题(7.4)的解<script type="math/tex">\alpha^*=(\alpha_1^*,\alpha^*_2,\cdots \alpha^*_N)^T</script>中对应于<script type="math/tex">\alpha^*_i>0</script>的样本点的实例称为支持向量。</p>
<p><img src="/2020/08/19/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/3.png" alt></p>
<p>若<script type="math/tex">\alpha^*_i<C</script>，则<script type="math/tex">\xi_i=0</script>，支持向量恰好落在间隔边界上。</p>
<p>若<script type="math/tex">\alpha^*_i=C，0<\xi_i<1</script>，分类正确，支持向量落在间隔边界与分离超平面之间。</p>
<p>若<script type="math/tex">\alpha^*_i=C，\xi_i=1</script>，则支持向量在分离超平面上。</p>
<p>若<script type="math/tex">\alpha^*_i=C，\xi_i>1</script>，分类错误，支持向量位于分离超平面误分一侧。</p>
<h3 id="合页损失函数"><a href="#合页损失函数" class="headerlink" title="合页损失函数"></a>合页损失函数</h3><p>线性SVM还有另外一种解释，就是最小化以下目标函数</p>
<script type="math/tex; mode=display">
\sum_{i=1}^N[1-y_i(w\cdot x_i+b)]_++\lambda\|w\|^2</script><p>其中第一项是经验损失，使用到了合页损失函数</p>
<script type="math/tex; mode=display">
[z]_+=\begin{cases}z,\quad z>0\\0,\quad z\leq0\end{cases}</script><p>当样本点正确分类，并且函数间隔大于1时，损失为0，否则计算损失。</p>
<p>线性SVM原始最优化问题(7.3)等价于最优化问题</p>
<script type="math/tex; mode=display">
\min_{w,b}\quad\sum_{i=1}^N[1-y_i(w\cdot x_i+b)]_++\lambda\|w\|^2\tag{7.5}</script><p>事实上，记</p>
<script type="math/tex; mode=display">
\xi_i=[1-y_i(w\cdot x_i+b)]_+</script><p>满足原问题约束条件</p>
<script type="math/tex; mode=display">
y_i( w\cdot x_i+b)\geq1-\xi_i,\quad  i=1,2,\cdots,N\\
\xi_i\geq0,\quad  i=1,2,\cdots,N</script><p>取<script type="math/tex">\lambda=\frac1{2C}</script>，则等价于</p>
<script type="math/tex; mode=display">
\min_{w,b}\quad\frac1C(\frac12\|w\|^2+C\sum_{i=1}^N\xi_i)</script><p>即与原问题等价。</p>
<p><img src="/2020/08/19/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/4.png" alt></p>
<h2 id="7-3-非线性SVM与核函数"><a href="#7-3-非线性SVM与核函数" class="headerlink" title="7.3 非线性SVM与核函数"></a>7.3 非线性SVM与核函数</h2><h3 id="Kernel-trick"><a href="#Kernel-trick" class="headerlink" title="Kernel trick"></a>Kernel trick</h3><p>对于一些问题，需要利用非线性模型才能很好地进行分类。</p>
<p>给定训练集T，如果能用<script type="math/tex">\mathbb{R}^n</script>中的一个超曲面将正负例正确分开，则成为非线性可分问题。</p>
<p><img src="/2020/08/19/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/5.png" alt></p>
<p>非线性问题往往不容易求解，所以常采用非线性变换，将其转化为线性问题。</p>
<p>设原空间为<script type="math/tex">{\cal X}\subset\mathbb{R}^2,x=(x^{(1)},x^{(2)})^T\in\cal X</script>，新空间为<script type="math/tex">{\cal Z}\subset\mathbb{R}^2,z=(z^{(1)},z^{(2)})^T\in\cal Z</script>，定义映射</p>
<script type="math/tex; mode=display">
z=\phi(x)=((x^{(1)})^2,(x^{(2)})^2)^T</script><p>经过变换<script type="math/tex">z=\phi(x)</script>，原空间变为新空间，原空间中的椭圆变换成为新空间中的直线</p>
<script type="math/tex; mode=display">
w_1(x^{(1)})^2+w_2(x^{(2)})^2+b=0 \\
\rightarrow w_1z^{(1)}+w_2z^{(2)}+b=0</script><h4 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h4><p>设<script type="math/tex">\cal X</script>是输入空间，<script type="math/tex">\cal H</script>为特征空间，如果存在映射</p>
<script type="math/tex; mode=display">
\phi(x): \cal X\rightarrow H</script><p>使得</p>
<script type="math/tex; mode=display">
\forall x,z\in{\cal X},\quad K(x,z)=\phi(x)\phi(z)</script><p>则称<script type="math/tex">K(x,z)</script>为核函数，<script type="math/tex">\phi(x)</script>为映射函数。</p>
<p>Kernel trick的想法是，在学习与预测中只定义<script type="math/tex">K(x,z)</script>，而不显式定义映射函数。</p>
<p>通常，直接计算<script type="math/tex">K(x,z)</script>比较容易，而通过映射函数计算<script type="math/tex">K(x,z)</script>并不容易。</p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>注意到，在线性SVM的对偶问题(7.4)中，目标函数和决策函数都只设计输入实例与实力之间的内积，可以用核函数来代替，此时对偶问题的目标函数成为</p>
<script type="math/tex; mode=display">
W(\alpha)=\frac12\sum_{i=1}^N\sum_{j=1}^N\alpha_i\alpha_jy_iy_jK(x_i,x_j)-\sum_{i=1}^N\alpha_i</script><p>分类决策函数成为</p>
<script type="math/tex; mode=display">
\begin{align}
f(x) &= sign(\sum_{i=1}^N\alpha^*_iy_i\phi(x_i)\cdot\phi(x)+b^*)\\
&= sign(\sum_{i=1}^N\alpha^*_iy_iK(x_i,x)+b^*)
\end{align}</script><h3 id="正定核"><a href="#正定核" class="headerlink" title="正定核"></a>正定核</h3><p>设<script type="math/tex">K:{\cal X}\times{\cal X}\rightarrow\mathbb{R}</script>是对称函数，则<script type="math/tex">K(x,z)</script>为正定核函数的充要条件是<script type="math/tex">\forall x_i\in{\cal X},i=1,2,\cdots,m</script>，<script type="math/tex">K(x,z)</script>对应的Gram矩阵：</p>
<script type="math/tex; mode=display">
K=[K(x_i,x_j)]_{m\times m}</script><p>是半正定矩阵。</p>
<h3 id="常见核函数"><a href="#常见核函数" class="headerlink" title="常见核函数"></a>常见核函数</h3><h4 id="多项式核函数"><a href="#多项式核函数" class="headerlink" title="多项式核函数"></a>多项式核函数</h4><script type="math/tex; mode=display">
K(x,z) = (x\cdot z+1)^p</script><p>对应的SVM是一个p次多项式分类器，此时分类决策函数为</p>
<script type="math/tex; mode=display">
f(x) = sign(\sum_{i=1}^N\alpha_i^*y_i(x_i\cdot x+1)^p+b^*)</script><h4 id="高斯核函数"><a href="#高斯核函数" class="headerlink" title="高斯核函数"></a>高斯核函数</h4><h4 id="字符串核函数"><a href="#字符串核函数" class="headerlink" title="字符串核函数"></a>字符串核函数</h4><h3 id="非线性SVM"><a href="#非线性SVM" class="headerlink" title="非线性SVM"></a>非线性SVM</h3><p>给定非线性分类训练集，通过核函数与软间隔最大化，或凸二次优化，学习得到的分类决策函数</p>
<script type="math/tex; mode=display">
f(x) = sign(\sum_{i=1}^N\alpha^*_iy_iK(x_i,x)+b^*)</script><p>称为非线性SVM，其中<script type="math/tex">K(x,z)</script>是正定核函数。</p>
<h2 id="7-4-序列最小最优化算法"><a href="#7-4-序列最小最优化算法" class="headerlink" title="7.4 序列最小最优化算法"></a>7.4 序列最小最优化算法</h2><p>已知SVM的学习问题可以形式化为求解凸二次规划问题，这样的凸二次规划问题具有全局最优解，但是当训练样本容量很大时，常见的最优化算法变得非常低效。</p>
<p>序列最小最优化（SMO）算法，就是高效实现SVM学习的一种算法。</p>
<p>SMO算法求解如下问题：</p>
<script type="math/tex; mode=display">
\begin{align}
\min_\alpha \quad& \frac12\sum_{i=1}^N\sum_{j=1}^N\alpha_i\alpha_jy_iy_jK(x_i,x_j)-\sum_{i=1}^N\alpha_i \\
s.t. \quad& \sum_{i=1}^N\alpha_iy_i=0\\
\quad &0\leq\alpha_i\leq C_i,\quad i=1,2,\cdots,N
\end{align} \tag{7.4}</script><p>TO BE COMPLETED</p>
]]></content>
      <categories>
        <category>统计学习方法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>SVM</tag>
        <tag>Kernel trick</tag>
      </tags>
  </entry>
  <entry>
    <title>统计学习方法（三）k近邻法</title>
    <url>/2020/08/13/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89k%E8%BF%91%E9%82%BB%E6%B3%95/</url>
    <content><![CDATA[<p>k近邻法，是一种基本分类与回归方法。输入为特征向量，输出为类别。</p>
<a id="more"></a>
<h2 id="3-1-k近邻算法"><a href="#3-1-k近邻算法" class="headerlink" title="3.1 k近邻算法"></a>3.1 k近邻算法</h2><p>给定一个训练集，对新的输入实例，在训练集中找到最邻近的k个实例，将输入实例分为多数类。</p>
<ul>
<li>输入：训练数据集T，实例特征向量x。</li>
<li>输出：实例x所属的类y。</li>
<li>根据给定的距离度量，在T中找出与x最邻近的k个点。</li>
<li>在邻域中根据分类决策规则（如多数表决）决定x的类别y。</li>
<li>k=1时，称为最近邻算法，将与x最邻近点的类作为x的类。</li>
</ul>
<h2 id="3-2-k近邻模型"><a href="#3-2-k近邻模型" class="headerlink" title="3.2 k近邻模型"></a>3.2 k近邻模型</h2><h3 id="距离度量"><a href="#距离度量" class="headerlink" title="距离度量"></a>距离度量</h3><script type="math/tex; mode=display">L_p$$距离定义为</script><p>L_p(x_i, x_j) = (\sum _{l=1} ^n |x_i^{(l)}-x_j^{(l)}|^p)^{\frac 1 p}</p>
<script type="math/tex; mode=display">
p=1时，称为曼哈顿距离</script><p>L_1(x_i, x_j) = (\sum _{l=1} ^n |x_i^{(l)}-x_j^{(l)}|)</p>
<script type="math/tex; mode=display">
p=2时，即为欧式距离</script><p>L_2(x_i, x_j) = (\sum _{l=1} ^n |x_i^{(l)}-x_j^{(l)}|^2)^{\frac 1 2}</p>
<script type="math/tex; mode=display">
p=∞时，称为切比雪夫距离，为各个坐标距离的最大值</script><p>L_\infty(x_i, x_j) = \max_l |x_i^{(l)}-x_j^{(l)}|</p>
<script type="math/tex; mode=display">
下图给出了与原点距离为1的图形

![](统计学习方法（三）k近邻法/1.png)

### 分类决策规则

k近邻法中的分类决策规则往往是多数表决，即由k个临近点的多数类决定输入类。

如果分类的损失函数为0-1损失函数，分类函数为</script><p>f: \mathbf R^n \rightarrow \{c_1, c_2, …, c_K\}</p>
<script type="math/tex; mode=display">
那么误分类的概率为</script><p>P(Y\neq f(X)) = 1- P(Y=f(X)) \\<br>\Leftrightarrow \frac 1 k \sum _{x_i\in N_k(x)} I(y_i\neq c_j) = 1 - \frac 1 k \sum _{x_i\in N_k(x)} I(y_i= c_j)</p>
<p>$$</p>
<h2 id="3-3-k近邻法的实现：kd树"><a href="#3-3-k近邻法的实现：kd树" class="headerlink" title="3.3 k近邻法的实现：kd树"></a>3.3 k近邻法的实现：kd树</h2><h3 id="构造kd树"><a href="#构造kd树" class="headerlink" title="构造kd树"></a>构造kd树</h3><p>kd树是二叉树，表示对k维空间的一个划分。</p>
<p>构造kd树相当于不断地用超平面切分k维空间，构成一系列的k维超矩形区域，kd树的每个节点对应于一个k维超矩形区域。</p>
<p>构造算法如下</p>
<ol>
<li>开始：构造根节点，对应于包含T的k维空间的超矩形区域。<ul>
<li>选择<script type="math/tex">x^{(1)}</script>为坐标轴，以T中所有实例的<script type="math/tex">x^{(1)}</script>坐标的中位数为切分点，将根节点对应的超矩形区域切分为两个子区域。</li>
<li>由此生成深度为一的左右子节点，左子节点对应于坐标<script type="math/tex">x^{(1)}</script>小于切分点的子区域。</li>
</ul>
</li>
<li>重复：对深度为j的节点，选择<script type="math/tex">x^{(l)}</script>为切分的坐标轴，其中<script type="math/tex">l=j(mod k)+1</script>，以坐标的中位数为切分点。<ul>
<li>由此生成深度为j+1的左右子节点，左子节点对应于坐标<script type="math/tex">x^{(l)}</script>小于切分点的子区域。</li>
</ul>
</li>
<li>直到两个子区域没有实例存在时停止，形成kd树的区域划分。</li>
</ol>
<p><img src="/2020/08/13/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89k%E8%BF%91%E9%82%BB%E6%B3%95/2.png" alt></p>
<h3 id="搜索kd树"><a href="#搜索kd树" class="headerlink" title="搜索kd树"></a>搜索kd树</h3><p>给定一个目标点，搜索其最近邻，首先找到包含目标点的叶节点。从叶节点出发，依次回退到父节点，不断查找与目标点最邻近的节点。</p>
<p>给定如图所示的kd树，根节点为A，子节点为B、C等，输入实例点为S，求S的最近邻。</p>
<ul>
<li>首先找到包含S的叶结点D，以D作为近似最近邻。</li>
<li>返回D的父节点B，在B的另一子节点F的区域内搜索。</li>
<li>继续返回上一级父节点A，在A的另一子节点C的区域内搜索。</li>
<li>点E比点D更近，成为最近邻。</li>
</ul>
<p><img src="/2020/08/13/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89k%E8%BF%91%E9%82%BB%E6%B3%95/3.png" alt></p>
<h2 id="Scikit-learn"><a href="#Scikit-learn" class="headerlink" title="Scikit-learn"></a>Scikit-learn</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"></span><br><span class="line">clf_sk = KNeighborsClassifier()</span><br><span class="line">clf_sk.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">clf_sk.score(X_test, y_test)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>统计学习方法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>KNN</tag>
      </tags>
  </entry>
  <entry>
    <title>统计学习方法（九）EM算法及其推广</title>
    <url>/2020/08/26/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%EF%BC%88%E4%B9%9D%EF%BC%89EM%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E6%8E%A8%E5%B9%BF/</url>
    <content><![CDATA[<p>EM算法是一种迭代算法，用于含隐变量的概率模型参数的极大似然估计，或极大后验概率估计。</p>
<a id="more"></a>
<h2 id="9-1-EM算法的引入"><a href="#9-1-EM算法的引入" class="headerlink" title="9.1 EM算法的引入"></a>9.1 EM算法的引入</h2><h3 id="三硬币模型"><a href="#三硬币模型" class="headerlink" title="三硬币模型"></a>三硬币模型</h3><p>假设有三枚硬币，记作A、B、C，这些硬币正面出现的概率分别为π、p、q。进行如下实验：先掷硬币A，根据结果选择硬币，正面选B，反面选C；然后掷选出的硬币，正面记作1，反面记作0；独立重复n次，得到观测结果。</p>
<p>假设只能观测到掷硬币的结果，不能观测过程，问如何估计三硬币正面出现的概率。</p>
<script type="math/tex; mode=display">
\begin{align}
P(y|\theta)=\sum_zP(y,z|\theta)&=\sum_zP(z|\theta)P(y|z,\theta) \\
&= \pi p^y(1-p)^{1-y}+(1-\pi)q^y(1-q)^{1-y}
\end{align}</script><p>其中，y表示观测变量，z为隐变量，表示硬币A的结果，θ为模型参数。</p>
<p>将观测数据表示为<script type="math/tex">Y=(Y_1,Y_2,\cdots Y_n)^T</script>，未观测数据表示为<script type="math/tex">Z=(Z_1,Z_2,\cdots Z_n)^T</script>，则似然函数为</p>
<script type="math/tex; mode=display">
\begin{align}
P(Y|\theta)&=\sum_ZP(Z|\theta)P(Y|Z,\theta) \\
&= \prod_{j=1}^n[\pi p^{y_i}(1-p)^{1-y_i}+(1-\pi)q^{y_i}(1-q)^{1-y_i}]
\end{align}</script><p>考虑<script type="math/tex">\theta=(\pi,p,q)</script>的极大似然估计</p>
<script type="math/tex; mode=display">
\hat\theta=\arg\max_\theta\log P(Y|\theta)</script><p>这个问题没有解析解，只能通过迭代求解，EM算法就是这样一种迭代算法。</p>
<h3 id="EM算法"><a href="#EM算法" class="headerlink" title="EM算法"></a>EM算法</h3><p>输入：观测变量数据Y，隐变量数据Z，联合分布<script type="math/tex">P(Y,Z|\theta)</script>，条件分布<script type="math/tex">P(Z|Y,\theta)</script>；</p>
<p>输出：模型参数<script type="math/tex">\theta</script>。</p>
<ul>
<li><p>选择参数的初值<script type="math/tex">\theta^{(0)}</script>，开始迭代；</p>
</li>
<li><p>E步：记<script type="math/tex">\theta^{(i)}</script>表示第i次迭代时参数的估计值，在第i+1次迭代，计算</p>
<script type="math/tex; mode=display">
\begin{align}
Q(\theta,\theta^{(i)})&=E_Z[\log P(Y,Z|\theta)|Y,\theta^{(i)}]\\
&=\sum_Z\log P(Y,Z|\theta)P(Z|Y,\theta^{(i)})
\end{align}</script></li>
<li><p>M步：求使得<script type="math/tex">Q(\theta,\theta^{(i)})</script>极大化的参数值，确定第i+1次迭代的参数值</p>
<script type="math/tex; mode=display">
\theta^{(i+1)}=\arg\max_\theta Q(\theta,\theta^{(i)})</script></li>
<li><p>重复上述步骤，直到收敛。</p>
</li>
</ul>
<p>参数的初值可以任意选择，但EM算法对初值是敏感的。</p>
<p>停止迭代的条件一般是</p>
<script type="math/tex; mode=display">
\|\theta^{(i+1)}-\theta^{(i)}\|<\epsilon_1 \quad or \quad \|Q(\theta^{(i+1)},\theta^{(i)})-Q(\theta^{(i)},\theta^{(i)})\|<\epsilon_2</script><h3 id="EM算法的导出"><a href="#EM算法的导出" class="headerlink" title="EM算法的导出"></a>EM算法的导出</h3><p>面对一个含有隐变量的概率模型，我们希望极大化观测数据关于参数的对数似然函数，即</p>
<script type="math/tex; mode=display">
\begin{align}
L(\theta)&=\log P(Y|\theta)=\log\sum_ZP(Y,Z|\theta) \\
&= \log(\sum_ZP(Z|\theta)P(Y|Z,\theta))
\end{align}</script><p>EM算法通过迭代，逐步近似最大化函数，考虑</p>
<script type="math/tex; mode=display">
L(\theta)-L(\theta^{(i)})=\log(\sum_ZP(Z|\theta)P(Y|Z,\theta))-\log P(Y|\theta^{(i)})</script><p>利用Jensen不等式</p>
<script type="math/tex; mode=display">
\begin{align}
L(\theta)-L(\theta^{(i)})&=\log(\sum_ZP(Z|Y,\theta^{(i)})\frac{P(Z|\theta)P(Y|Z,\theta)}{P(Z|Y,\theta^{(i)})})-\log P(Y|\theta^{(i)})\\
&\geq\sum_ZP(Z|Y,\theta^{(i)})\log\frac{P(Z|\theta)P(Y|Z,\theta)}{P(Z|Y,\theta^{(i)})}-\log P(Y|\theta^{(i)})\\
&=\sum_ZP(Z|Y,\theta^{(i)})\log\frac{P(Z|\theta)P(Y|Z,\theta)}{P(Z|Y,\theta^{(i)})P(Y|\theta^{(i)})}
\end{align}</script><blockquote>
<script type="math/tex; mode=display">\log\sum_j\lambda_jy_j\geq\sum_j\lambda_j\log y_j,\quad\lambda_j\geq0,\quad\sum_j\lambda_j=1</script></blockquote>
<p>记</p>
<script type="math/tex; mode=display">
B(\theta,\theta^{(i)})\hat=L(\theta^{(i)})+\sum_ZP(Z|Y,\theta^{(i)})\log\frac{P(Z|\theta)P(Y|Z,\theta)}{P(Z|Y,\theta^{(i)})P(Y|\theta^{(i)})}</script><p>则有</p>
<script type="math/tex; mode=display">
L(\theta)\geq B(\theta,\theta^{(i)})</script><p>即<script type="math/tex">B(\theta,\theta^{(i)})</script>是<script type="math/tex">L(\theta)</script>的一个下界，为了使<script type="math/tex">L(\theta)</script>尽可能大地增长，选择</p>
<script type="math/tex; mode=display">
\theta^{(i+1)}=\arg\max_\theta B(\theta,\theta^{(i)})</script><p>省去常数项，得到</p>
<script type="math/tex; mode=display">
\begin{align}
\theta^{(i+1)}&=\arg\max_\theta(L(\theta^{(i)})+\sum_ZP(Z|Y,\theta^{(i)})\log\frac{P(Z|\theta)P(Y|Z,\theta)}{P(Z|Y,\theta^{(i)})P(Y|\theta^{(i)})})\\
&=\arg\max_\theta(\sum_ZP(Z|Y,\theta^{(i)})\log P(Z|\theta)P(Y|Z,\theta))\\
&=\arg\max_\theta(\sum_ZP(Z|Y,\theta^{(i)})\log P(Y,Z|\theta))\\
&=\arg\max_\theta Q(\theta,\theta^{(i)})
\end{align}</script><p><img src="/2020/08/26/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%EF%BC%88%E4%B9%9D%EF%BC%89EM%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E6%8E%A8%E5%B9%BF/1.png" alt></p>
<h2 id="9-2-EM算法的收敛性"><a href="#9-2-EM算法的收敛性" class="headerlink" title="9.2 EM算法的收敛性"></a>9.2 EM算法的收敛性</h2><p><strong>定理 9.1</strong>    设<script type="math/tex">P(Y|\theta)</script>为观测数据的似然函数，则<script type="math/tex">P(Y|\theta^{(i)})</script>是单调递增的。</p>
<p><strong>定理 9.2</strong>    设<script type="math/tex">L(\theta)=\log P(Y|\theta)</script>为观测数据的对数似然函数，则有</p>
<ul>
<li>如果<script type="math/tex">P(Y|\theta)</script>有上界，则<script type="math/tex">L(\theta^{(i)}=\log P(Y|\theta^{(i)})</script>收敛到某一值。</li>
<li>在<script type="math/tex">Q(\theta,\theta')</script>与<script type="math/tex">L(\theta)</script>满足一定条件下，由EM算法得到的参数估计序列的收敛值是<script type="math/tex">L(\theta)</script>的稳定点。</li>
</ul>
<h2 id="9-3-EM算法在高斯混合模型学习中的应用"><a href="#9-3-EM算法在高斯混合模型学习中的应用" class="headerlink" title="9.3 EM算法在高斯混合模型学习中的应用"></a>9.3 EM算法在高斯混合模型学习中的应用</h2><h3 id="高斯混合模型"><a href="#高斯混合模型" class="headerlink" title="高斯混合模型"></a>高斯混合模型</h3><p>高斯混合模型是指具有如下形式的概率分布模型</p>
<script type="math/tex; mode=display">
P(y|\theta)=\sum_{k=1}^K\alpha_k\phi(y|\theta_k),\quad\alpha_k\geq0,\quad\sum_{k=1}\alpha_k=1</script><p>其中<script type="math/tex">\phi(y|\theta_k)</script>是高斯分布密度，<script type="math/tex">\theta_k=(\mu_k,\sigma_k^2)</script>，称为第k个分模型。</p>
<script type="math/tex; mode=display">
\phi(y|\theta_k)=\frac1{\sqrt{2\pi}\sigma_k}\exp(-\frac{(y-\mu_k)^2}{2\sigma_k^2})</script><h3 id="高斯混合模型参数估计的EM算法"><a href="#高斯混合模型参数估计的EM算法" class="headerlink" title="高斯混合模型参数估计的EM算法"></a>高斯混合模型参数估计的EM算法</h3><p>假设观测数据由高斯混合模型生成，我们用EM算法估计高斯混合模型的参数。</p>
<h4 id="明确隐变量，写出对数似然函数"><a href="#明确隐变量，写出对数似然函数" class="headerlink" title="明确隐变量，写出对数似然函数"></a>明确隐变量，写出对数似然函数</h4><p>明确隐变量</p>
<script type="math/tex; mode=display">
\gamma_{jk}=\begin{cases}1,\quad第j个观测来自第k个模型\\0,\quad否则\end{cases}\\
j=1,2,\cdots,N;\quad k=1,2,\cdots,K</script><p>写出似然函数</p>
<script type="math/tex; mode=display">
\begin{align}
P(y,\gamma|\theta)&=\prod_{j=1}^NP(y_j,\gamma_{j1},\gamma_{j2},\cdots,\gamma_{jK}|\theta)\\
&=\prod_{k=1}^K\prod_{j=1}^N[\alpha_k\phi(y_j|\theta_k)]^{\gamma_{jk}}\\
&=\prod_{k=1}^K\alpha_k^{n_k}\prod_{j=1}^N[\phi(y_j|\theta_k)]^{\gamma_{jk}}\\
&=\prod_{k=1}^K\alpha_k^{n_k}\prod_{j=1}^N[\frac1{\sqrt{2\pi}\sigma_k}\exp(-\frac{(y-\mu_k)^2}{2\sigma_k^2}]^{\gamma_{jk}}
\end{align}</script><p>其中，<script type="math/tex">n_k=\sum_{j=1}^N\gamma_{jk}</script>，<script type="math/tex">\sum_{k=1}^Kn_k=N</script></p>
<p>那么对数似然函数为</p>
<script type="math/tex; mode=display">
\log P(y,\gamma|\theta)=\sum_{k=1}^K\{n_k\log\alpha_k+\sum_{j=1}^N\gamma_{jk}[\log(\frac1{\sqrt{2\pi}})-\log\sigma_k-\frac1{2\sigma_k^2}(y-\mu_k)^2]\}</script><h4 id="EM算法的E步：确定Q函数"><a href="#EM算法的E步：确定Q函数" class="headerlink" title="EM算法的E步：确定Q函数"></a>EM算法的E步：确定Q函数</h4><script type="math/tex; mode=display">
\begin{align}
Q(\theta,\theta^{(i)})&=E[\log P(y,\gamma|\theta)|y,\theta^{(i)}]\\
&=E\{\sum_{k=1}^K\{n_k\log\alpha_k+\sum_{j=1}^N\gamma_{jk}[\log(\frac1{\sqrt{2\pi}})-\log\sigma_k-\frac1{2\sigma_k^2}(y-\mu_k)^2]\}\}\\
&=\sum_{k=1}^K\{\sum_{j=1}^N(E\gamma_{jk})\log\alpha_k+\sum_{j=1}^N(E\gamma_{jk})[\log(\frac1{\sqrt{2\pi}})-\log\sigma_k-\frac1{2\sigma_k^2}(y-\mu_k)^2]\}
\end{align}</script><p>这里需要计算<script type="math/tex">E(\gamma_{jk}|y,\theta)</script></p>
<script type="math/tex; mode=display">
\begin{align}
\hat\gamma_{jk}&=E(\gamma_{jk}|y,\theta)=P(\gamma_{jk}=1|y,\theta)\\
&=\frac{P(\gamma_{jk}=1,y_j|\theta)}{\sum_{k=1}^KP(\gamma_{jk}=1,y_j|\theta)}\\
&=\frac{P(y_j|\gamma_{jk}=1,\theta)P(\gamma_{jk}=1|\theta)}{\sum_{k=1}^KP(y_j|\gamma_{jk}=1,\theta)P(\gamma_{jk}=1|\theta)}\\
&=\frac{\alpha_k\phi(y_j|\theta_k)}{\sum_{k=1}^K\alpha_k\phi(y_j|\theta_k)},\quad j=1,2,\cdots,N;\quad k=1,2,\cdots,N
\end{align}</script><p>代回原式</p>
<script type="math/tex; mode=display">
Q(\theta,\theta^{(i)})=\sum_{k=1}^K\{n_k\log\alpha_k+\sum_{j=1}^N\hat\gamma_{jk}[\log(\frac1{\sqrt{2\pi}})-\log\sigma_k-\frac1{2\sigma_k^2}(y-\mu_k)^2]\}</script><h4 id="确定EM算法的M步"><a href="#确定EM算法的M步" class="headerlink" title="确定EM算法的M步"></a>确定EM算法的M步</h4><script type="math/tex; mode=display">
\theta^{(i+1)}=\arg\max_\theta Q(\theta,\theta^{(i)})</script><p>将<script type="math/tex">Q(\theta,\theta^{(i)})</script>分别对<script type="math/tex">\mu_k,\sigma_k^2</script>求偏导数，令其为0；求<script type="math/tex">\hat\alpha_k</script>是在<script type="math/tex">\sum_{k=1}^K\alpha_k=1</script>条件下求偏导数并令其为0得到的。</p>
<script type="math/tex; mode=display">
\hat\mu_k=\frac{\sum_{j=1}^N\hat\gamma_{jk}y_j}{\sum_{j=1}^N\hat\gamma_{jk}},\quad k=1,2,\cdots,K\\
\hat\sigma_k^2=\frac{\sum_{j=1}^N\hat\gamma_{jk}(y_j-\mu_k)^2}{\sum_{j=1}^N\hat\gamma_{jk}},\quad k=1,2,\cdots,K\\
\hat\alpha_k=\frac{n_k}N=\frac{\sum_{j=1}^N\hat\gamma_{jk}}{N},\quad k=1,2,\cdots,K\\</script><h2 id="9-4-EM算法的推广"><a href="#9-4-EM算法的推广" class="headerlink" title="9.4 EM算法的推广"></a>9.4 EM算法的推广</h2><p>暂略，有空再补。</p>
<h3 id="F函数的极大-极大算法"><a href="#F函数的极大-极大算法" class="headerlink" title="F函数的极大-极大算法"></a>F函数的极大-极大算法</h3><h3 id="GEM算法"><a href="#GEM算法" class="headerlink" title="GEM算法"></a>GEM算法</h3><h2 id="Scikit-learn"><a href="#Scikit-learn" class="headerlink" title="Scikit-learn"></a>Scikit-learn</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.mixture <span class="keyword">import</span> GaussianMixture</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化观测数据</span></span><br><span class="line">data = np.array([<span class="number">-67</span>, <span class="number">-48</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">41</span>, <span class="number">49</span>, <span class="number">56</span>, <span class="number">60</span>,</span><br><span class="line">                 <span class="number">75</span>]).reshape(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 聚类</span></span><br><span class="line">gmmModel = GaussianMixture(n_components=<span class="number">2</span>)</span><br><span class="line">gmmModel.fit(data)</span><br><span class="line">labels = gmmModel.predict(data)</span><br><span class="line">print(<span class="string">&quot;labels =&quot;</span>, labels)</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于含隐变量的模型，分E步和M步，分别求期望和极大值，得到参数的新的估计值，迭代以极大化函数。</p>
]]></content>
      <categories>
        <category>统计学习方法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>EM算法</tag>
      </tags>
  </entry>
  <entry>
    <title>统计学习方法（二）感知机</title>
    <url>/2020/08/12/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89%E6%84%9F%E7%9F%A5%E6%9C%BA/</url>
    <content><![CDATA[<p>感知机，是二分类的线性分类模型。输入为实例的特征向量，输出为±1，旨在求出将训练数据进行线性划分的分离超平面，是神经网络与SVM的基础。</p>
<a id="more"></a>
<h2 id="2-1-感知机模型"><a href="#2-1-感知机模型" class="headerlink" title="2.1 感知机模型"></a>2.1 感知机模型</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><script type="math/tex; mode=display">
f(x) = sign(w·x + b) \\
{\cal X} \subset R^n, \quad {\cal Y} = \{-1, +1\}</script><p>其中w和b为感知机模型参数，w称为权值（向量），b称为偏置（bias）。</p>
<script type="math/tex; mode=display">
sign(x) = \begin{cases} +1, \quad x\geq 0 \\ -1, \quad x < 0\end{cases}</script><h3 id="几何解释"><a href="#几何解释" class="headerlink" title="几何解释"></a>几何解释</h3><p>线性方程</p>
<script type="math/tex; mode=display">
w·x + b = 0</script><p>对应于特征空间中的一个超平面S，w表示超平面的法向量，b为超平面的截距。</p>
<p><img src="/2020/08/12/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89%E6%84%9F%E7%9F%A5%E6%9C%BA/perc1.png" alt></p>
<h2 id="2-2-感知机学习策略"><a href="#2-2-感知机学习策略" class="headerlink" title="2.2 感知机学习策略"></a>2.2 感知机学习策略</h2><h3 id="数据集的线性可分性"><a href="#数据集的线性可分性" class="headerlink" title="数据集的线性可分性"></a>数据集的线性可分性</h3><p>给定一个数据集，如果存在超平面S，能够将数据集的正实例点和负实例点完全正确划分，则称数据及为线性可分数据集。</p>
<h4 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h4><p>损失函数的一个自然选择是误分类点的总数，但这样不是参数的连续可导函数，不易优化。</p>
<p>感知机选择的损失函数是误分类点到超平面S的总距离，输入空间任一点到超平面S的距离为</p>
<script type="math/tex; mode=display">
\frac 1 {\|w\|} |w·x_0+b|,其中\|w\|为w的L_2范数</script><p>对于误分类的数据来说，始终有</p>
<script type="math/tex; mode=display">
-y_i(w·x_i+b) > 0</script><p>所以距离为</p>
<script type="math/tex; mode=display">
- \frac 1 {\|w\|}y_i(w·x_i+b)</script><p>假设误分类点集合为M，求和即得</p>
<script type="math/tex; mode=display">
- \frac 1 {\|w\|}\sum _{x_i\in M}y_i(w·x_i+b)</script><p>不考虑系数，损失函数即为</p>
<script type="math/tex; mode=display">
L(w, b) = - \sum _{x_i\in M}y_i(w·x_i+b)</script><p>误分类点越少，损失函数值越小，如果没有误分类点，损失函数值为0。</p>
<h2 id="2-3-感知机学习算法"><a href="#2-3-感知机学习算法" class="headerlink" title="2.3 感知机学习算法"></a>2.3 感知机学习算法</h2><h3 id="形式化"><a href="#形式化" class="headerlink" title="形式化"></a>形式化</h3><p>给定训练集</p>
<script type="math/tex; mode=display">
T = \{(x_1, y_1), (x_2, y_2), ... , (x_N, y_N)\} \\
x_i\in {\cal X} = R^n, y_i \in {\cal Y} = \{-1, +1\}</script><p>求参数w和b，使得损失函数极小化</p>
<script type="math/tex; mode=display">
\min_{w,b} L(w,b) = - \sum _{x_i\in M}y_i(w·x_i+b)</script><p>学习算法是误分类驱动的，具体采用随机梯度下降法，首先任意选取一个超平面，之后用梯度下降法不断极小化目标函数。</p>
<p>损失函数的梯度为</p>
<script type="math/tex; mode=display">
\nabla_w L(w,b) = -\sum _{x_i\in M} y_ix_i \\
\nabla_b L(w,b) = -\sum _{x_i\in M} y_i</script><p>随机选取一个误分类点，对参数进行更新</p>
<script type="math/tex; mode=display">
w \leftarrow w + \eta y_ix_i \\
b \leftarrow b + \eta y_i \\
\eta \in (0, 1]</script><h3 id="原始形式"><a href="#原始形式" class="headerlink" title="原始形式"></a>原始形式</h3><ol>
<li><p>选取参数初值<script type="math/tex">w_0,b_0</script></p>
</li>
<li><p>在训练集中选取数据<script type="math/tex">(x_i, y_i)</script></p>
</li>
<li><p>如果<script type="math/tex">y_i(wx_i+b)\leq 0</script>，则更新参数</p>
<script type="math/tex; mode=display">
w \leftarrow w + \eta y_ix_i \\
b \leftarrow b + \eta y_i</script></li>
<li><p>转至2直至没有误分类点</p>
</li>
</ol>
<h3 id="收敛性"><a href="#收敛性" class="headerlink" title="收敛性"></a>收敛性</h3><p>(<strong>Novikoff</strong>) 存在满足条件的超平面，且感知机算法的误分类次数k满足不等式</p>
<script type="math/tex; mode=display">
k \leq (\frac R \gamma)^2</script><h3 id="对偶形式"><a href="#对偶形式" class="headerlink" title="对偶形式"></a>对偶形式</h3><p>基本想法是，将w和b表示为实例x与标记y的线性组合，通过求解系数求得w和b。</p>
<p>最后学习到的w和b可表示为</p>
<script type="math/tex; mode=display">
w = \sum _{i=1} ^N \alpha_iy_ix_i \\
b = \sum _{i=1} ^N \alpha_iy_i</script><p>训练过程</p>
<ol>
<li><p>选取α和b为0,</p>
</li>
<li><p>在训练集中选取数据</p>
</li>
<li><p>若<script type="math/tex">y_i(\sum _{j=1} ^N \alpha_jy_jx_j\cdot x_i+b)\leq 0</script>，则更新参数</p>
</li>
</ol>
<script type="math/tex; mode=display">
\alpha_i \leftarrow \alpha_i + \eta \\
b \leftarrow b + \eta y_i</script><ol>
<li>转至2直至没有误分类数据</li>
</ol>
<blockquote>
<p>Gram矩阵？</p>
</blockquote>
<h2 id="Scikit-learn"><a href="#Scikit-learn" class="headerlink" title="Scikit-learn"></a>Scikit-learn</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Perceptron</span><br><span class="line"></span><br><span class="line">clf = Perceptron(fit_intercept=<span class="literal">True</span>, </span><br><span class="line">                 max_iter=<span class="number">1000</span>, </span><br><span class="line">                 shuffle=<span class="literal">True</span>)</span><br><span class="line">clf.fit(X, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Weights assigned to the features.</span></span><br><span class="line">print(clf.coef_)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Constants in decision function.</span></span><br><span class="line">print(clf.intercept_)</span><br><span class="line"></span><br><span class="line">y_ = -(clf.coef_[<span class="number">0</span>][<span class="number">0</span>]*x_ponits + clf.intercept_)/clf.coef_[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">plt.plot(x_ponits, y_)</span><br><span class="line">plt.plot(x_ponits, y_)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>统计学习方法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>感知机</tag>
      </tags>
  </entry>
  <entry>
    <title>统计学习方法（五）决策树</title>
    <url>/2020/08/15/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E5%86%B3%E7%AD%96%E6%A0%91/</url>
    <content><![CDATA[<p>决策树是一种基本的分类与回归方法，在分类问题中，用树形结构表示基于特征对实例进行分类的过程。</p>
<a id="more"></a>
<h2 id="5-1-决策树模型与学习"><a href="#5-1-决策树模型与学习" class="headerlink" title="5.1 决策树模型与学习"></a>5.1 决策树模型与学习</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>决策树是一种描述对实例进行分类的树形结构，由节点和有向边组成。</p>
<p>节点有两种类型：内部节点和叶子节点，内部节点表示特征或属性，叶子结点表示一个类。</p>
<p>决策树分类时，从根节点开始，对实例的某一特征进行测试，根据测试结果将其分配到子节点。如此递归，直至到达叶节点，最后分到叶节点的类中。</p>
<p><img src="/2020/08/15/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E5%86%B3%E7%AD%96%E6%A0%91/1.png" alt></p>
<h3 id="决策树学习"><a href="#决策树学习" class="headerlink" title="决策树学习"></a>决策树学习</h3><p>可以把决策树看成if-then规则的集合，每个实例只被一条路径或一条规则所覆盖。</p>
<p>也可以从条件概率分布的角度理解，定义在特征空间的划分上，将特征空间分为互不相交的单元或区域，在每个单元上定义一个类的概率分布就构成了一个条件概率分布。</p>
<p><img src="/2020/08/15/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E5%86%B3%E7%AD%96%E6%A0%91/2.png" alt></p>
<p>决策树学习在本质上，是从训练集中归纳出一组分类规则，我们需要的是一个与训练集矛盾较小的决策树，同时具有很好的泛化能力。</p>
<p>决策树的损失函数通常是正则化的极大似然函数，学习策略是最小化损失函数。</p>
<h2 id="5-2-特征选择"><a href="#5-2-特征选择" class="headerlink" title="5.2 特征选择"></a>5.2 特征选择</h2><p>特征选择，是决定用哪个特征来划分特征空间。</p>
<h3 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h3><p>首先给出熵与条件熵的定义</p>
<script type="math/tex; mode=display">
H(X)=-\sum_{i=1}^np_i\log p_i \\
0 \leq H(p) \leq \log n</script><p>熵越大，随机变量的不确定性就越大。</p>
<script type="math/tex; mode=display">
H(Y|X) = \sum_{i=1}^nP(X=x_i)H(Y|X=x_i)</script><p>当熵和条件熵中的概率由数据估计得到时，称为经验熵与经验条件熵。</p>
<p>信息增益，定义为集合D的经验熵与特征A给定条件D下的经验条件熵之差</p>
<script type="math/tex; mode=display">
g(D,A) = H(D) - H(D|A)</script><blockquote>
<p>一般，熵与条件熵之差称为互信息，信息增益等价于训练集中类与特征的互信息。</p>
</blockquote>
<p>对于训练数据集D，计算每个特征的信息增益，比较大小，选择信息增益最大的特征。</p>
<h3 id="信息增益比"><a href="#信息增益比" class="headerlink" title="信息增益比"></a>信息增益比</h3><script type="math/tex; mode=display">
g_k(D,A) = \frac {g(D,A)} {H(D)}</script><h2 id="5-3-决策树的生成"><a href="#5-3-决策树的生成" class="headerlink" title="5.3 决策树的生成"></a>5.3 决策树的生成</h2><h3 id="ID3算法"><a href="#ID3算法" class="headerlink" title="ID3算法"></a>ID3算法</h3><p>ID3算法，核心是在决策树每个节点上应用信息增益准则选择特征，递归地构建决策树。</p>
<p>输入：训练数据集D，特征集A，阈值ε</p>
<p>输出：决策树T</p>
<ul>
<li><p>若D中所有实例属于同一类<script type="math/tex">C_k</script>，则T为单节点树，返回T；</p>
</li>
<li><p>若A为空集，则返回T；</p>
</li>
<li><p>否则，计算A中各特征对D的信息增益，选择信息增益最大的特征<script type="math/tex">A_g</script>；</p>
</li>
<li><p>若<script type="math/tex">A_g</script>的信息增益小于阈值，则返回T；</p>
</li>
<li><p>否则，对<script type="math/tex">A_g</script>的每一可能值，以此将D分割成若干非空子集，将实例树最大的类作为标记，构建子节点，由节点及其子节点构成树T，返回T；</p>
</li>
<li><p>对第i个子节点，以<script type="math/tex">D_i</script>为训练集，<script type="math/tex">A-{A_g}</script>为特征集，递归调用上述步骤，得到子树<script type="math/tex">T_i</script>，返回<script type="math/tex">T_i</script>。</p>
</li>
</ul>
<p>ID3算法只有树的生成，容易产生过拟合。</p>
<h3 id="C4-5算法"><a href="#C4-5算法" class="headerlink" title="C4.5算法"></a>C4.5算法</h3><p>改进处在于，用信息增益比来选择特征。 </p>
<h2 id="5-4-决策树的剪枝"><a href="#5-4-决策树的剪枝" class="headerlink" title="5.4 决策树的剪枝"></a>5.4 决策树的剪枝</h2><p>剪枝是为了解决过拟合现象，对已生成的决策树进行简化。</p>
<p>剪枝往往通过极小化损失函数或代价函数来实现。</p>
<p>设树T的叶子结点个数为|T|，t为T的叶子结点，t有<script type="math/tex">N_t</script>个样本点，其中k类的样本点有<script type="math/tex">N_{tk}</script>个，<script type="math/tex">H_t(T)</script>为t的经验熵，则损失函数可以定义为</p>
<script type="math/tex; mode=display">
C_\alpha(T) = \sum_{t=1}^{|T|}N_tH_t(T)+\alpha|T| \\
H_t(T) = -\sum_k\frac{N_{tk}}{N_t}\log\frac{N_{tk}}{N_t}</script><p>记</p>
<script type="math/tex; mode=display">
C(T) = \sum_{t=1}^{|T|}N_tH_t(T) = -\sum_{t=1}^{|T|}\sum_{k=1}^KN_{tk}\log\frac{N_{tk}}{N_t}</script><p>则有</p>
<script type="math/tex; mode=display">
C_\alpha(T) = C(T) + \alpha|T|</script><p>剪枝算法</p>
<p>输入：生成算法产生的整个树T，参数α</p>
<p>输出：修剪后的子树<script type="math/tex">T_\alpha</script></p>
<ul>
<li>计算每个节点的经验熵</li>
<li>递归地从树的叶子结点向上回溯<ul>
<li>设叶节点回溯到父节点之前与之后的树分别为<script type="math/tex">T_B</script>与<script type="math/tex">T_A</script>，如果<script type="math/tex">C_\alpha(T_A)\leq C_\alpha(T_B)</script>，则进行剪枝，将父节点变为新的叶子结点。</li>
</ul>
</li>
<li>直至不能继续为止，得到损失函数最小的子树</li>
</ul>
<p><img src="/2020/08/15/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E5%86%B3%E7%AD%96%E6%A0%91/3.png" alt></p>
<h2 id="5-5-CART算法"><a href="#5-5-CART算法" class="headerlink" title="5.5 CART算法"></a>5.5 CART算法</h2><p>CART同样由特征选择、树的生成及剪枝组成，既可以用于分类也可以用于回归。</p>
<h3 id="CART生成"><a href="#CART生成" class="headerlink" title="CART生成"></a>CART生成</h3><h4 id="回归树"><a href="#回归树" class="headerlink" title="回归树"></a>回归树</h4><p>X与Y为输入和输出变量，Y是连续变量，给定训练集</p>
<script type="math/tex; mode=display">
D = \{(x_1,y_1),(x_2,y_2),...,(x_N,y_N)\}</script><p>假设已将输入空间划分为M个单元<script type="math/tex">R_1,R_2,...,R_M</script>，并且在每个单元<script type="math/tex">R_m</script>上有一个固定的输出值<script type="math/tex">c_m</script>，那么回归树模型可表示为</p>
<script type="math/tex; mode=display">
f(x) = \sum_{m=1}^Mc_mI(x\in R_m)</script><p>当输入空间的划分确定时，可以用平方误差来表示回归树的预测误差</p>
<script type="math/tex; mode=display">
\sum_{x_i\in R_m}(y_i-f(x_i))^2 \\
\hat c_m = {\rm ave} (y_i|x_i\in R_m)</script><p>采用启发式的方法对输入空间进行划分，选择第j个变量<script type="math/tex">x^{(j)}</script>和取值s，作为切分变量和切分点，并定义两个区域：</p>
<script type="math/tex; mode=display">
R_1(j,s) = \{x|x^{(j)}\leq s\} \quad R_2(j,s) = \{x|x^{(j)}> s\}</script><p>由此找到最优切分点s</p>
<script type="math/tex; mode=display">
\hat c_1 = {\rm ave} (y_i|x_i\in R_1(j,s)) \quad \hat c_2 = {\rm ave} (y_i|x_i\in R_2(j,s))</script><p>遍历所有变量，找到最优的切分变量j，以此划分输入空间，然后对每个区域重复上述过程，知道满足条件，由此生成一棵回归树，通常称为最小二乘回归树。</p>
<h4 id="分类树"><a href="#分类树" class="headerlink" title="分类树"></a>分类树</h4><p>分类树用基尼指数选择最优特征，同时决定该特征的最优二值切分点。</p>
<p>分类问题中，假如有K个类，样本点属于第k类的概率为<script type="math/tex">p_k</script>，则基尼指数定义为</p>
<script type="math/tex; mode=display">
Gini(p) = \sum_{k=1}^Kp_k(1-p_k) = 1 - \sum_{k=1}^Kp_k^2</script><p>K=2时</p>
<script type="math/tex; mode=display">
Gini(p) = 2p(1-p)</script><p>如果样本集合D根据特征A是否取可能值进行分割，即</p>
<script type="math/tex; mode=display">
D_1 = \{(x,y)\in D|A(x)=a\}, \quad D_2 = D - D_1</script><p>在特征A的条件下，基尼指数定义为</p>
<script type="math/tex; mode=display">
Gini(D,A) = \frac {|D_1|} {D} Gini(D_1)+\frac {|D_2|} {D} Gini(D_2)</script><p>基尼指数表示集合D的不确定性，基尼指数越大，样本集合的不确定性越大。</p>
<p>在分类树中，选择基尼指数最小的特征作为最优特征。</p>
<h3 id="CART剪枝"><a href="#CART剪枝" class="headerlink" title="CART剪枝"></a>CART剪枝</h3><p>输入：CART生成的决策树<script type="math/tex">T_0</script></p>
<p>输出：最优决策树<script type="math/tex">T_\alpha</script></p>
<ul>
<li><p>设<script type="math/tex">k=0，T=T_0</script></p>
</li>
<li><p>设<script type="math/tex">\alpha=+\infty</script></p>
</li>
<li><p>自下而上地对各内部节点计算<script type="math/tex">C(T_t)，|T_t|</script>以及</p>
<script type="math/tex; mode=display">
g(t) = \frac {C(t) - C(T_t)} {|T_t|-1}</script><script type="math/tex; mode=display">
\alpha = min(\alpha, g(t))</script></li>
<li><p>自上而下地访问内部节点，如果<script type="math/tex">g(t) = \alpha</script>，进行剪枝，并以多数表决法决定其类，得到T</p>
</li>
<li><p>设<script type="math/tex">k=k+1，\alpha_k=\alpha，T_k=T</script></p>
</li>
<li><p>如果T不是由根节点单独构成的树，回到第四步</p>
</li>
<li><p>采用交叉验证法，在子树序列中选取最优子树</p>
</li>
</ul>
<h2 id="Scikit-learn"><a href="#Scikit-learn" class="headerlink" title="Scikit-learn"></a>Scikit-learn</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> export_graphviz</span><br><span class="line"><span class="keyword">import</span> graphviz</span><br><span class="line"></span><br><span class="line">clf = DecisionTreeClassifier()</span><br><span class="line">clf.fit(X_train, y_train,)</span><br><span class="line"></span><br><span class="line">clf.score(X_test, y_test)</span><br><span class="line"></span><br><span class="line">tree_pic = export_graphviz(clf, out_file=<span class="string">&quot;mytree.pdf&quot;</span>)</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;mytree.pdf&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    dot_graph = f.read()</span><br><span class="line">    </span><br><span class="line">graphviz.Source(dot_graph)</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总体思路就是构造决策树，根据损失函数进行剪枝，具体细节没怎么看懂，回头找份代码瞧瞧。</p>
]]></content>
      <categories>
        <category>统计学习方法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>决策树</tag>
      </tags>
  </entry>
  <entry>
    <title>统计学习方法（八）提升方法</title>
    <url>/2020/08/25/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89%E6%8F%90%E5%8D%87%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>提升方法，在分类问题中通过改变训练样本的权重，学习多个分类器，并将分类器线性组合，提高分类的性能。</p>
<a id="more"></a>
<h2 id="8-1-AdaBoost算法"><a href="#8-1-AdaBoost算法" class="headerlink" title="8.1 AdaBoost算法"></a>8.1 AdaBoost算法</h2><p>提升方法的思想是，对于一个复杂任务来说，综合多个专家的判断得出的判断效果更好。</p>
<ul>
<li><strong>强可学习</strong>：在概率近似正确学习（PAC）的框架中，一个概念（一个类），如果存在一个多项式的学习算法<br>能够学习它，并且正确率很高，那么就称这个概念是强可学习的-</li>
<li><strong>弱可学习</strong>：一个概念，如果存在一个多项式的学习算法能够学习它，学习的正确率仅比随机猜测略好，那么就称这个概念是弱可学习的。</li>
</ul>
<p>Schapire后来证明强可学习与弱可学习是等价的，也即在PAC学习的框架下，一个概念是强可学习的充要条件是这个概念是弱可学习的。</p>
<p>利用这个前提，如果在学习中发现了”弱学习算法“，可以将其提升为”强学习算法“。对于分类问题而言，给定训练集，从弱学习算法出发，反复学习，得到一系列弱分类器，组合这些弱分类器构成一个强分类器。</p>
<p>给定一个二分类训练集</p>
<script type="math/tex; mode=display">
T = \{(x_1,y_1),(x_2,y_2),\cdots,(x_N,y_N)\} \\
x\in{\cal X}\subset{\mathbb R}^n,\quad y_i\in{\cal Y}=\{-1.+1\}</script><p>初始化训练数据的权值分布</p>
<script type="math/tex; mode=display">
D_1=(w_{11},\cdots,w_{1i},\cdots,w_{1N}),\quad w_{1i}=\frac1N,\quad i=1,2,\cdots,N</script><p>使用权值分布为<script type="math/tex">D_m</script>的训练集学习，得到基本分类器</p>
<script type="math/tex; mode=display">
G_m(x):{\cal X}\rightarrow\{-1,+1\}</script><p>计算分类器在训练集上的分类误差率</p>
<script type="math/tex; mode=display">
e_m=\sum_{i=1}^NP(G_m(x_i)\neq y_i)=\sum_{i=1}^Nw_{mi}I(G_m(x_i)\neq y_i)</script><p>计算分类器的系数，取自然对数</p>
<script type="math/tex; mode=display">
\alpha_m=\frac12\log\frac{1-e_m}{e_m}</script><p>更新训练集的权值分布</p>
<script type="math/tex; mode=display">
D_{m+1}=(w_{m+1.1},\cdots,w_{m+1,i},\cdots,w_{m+1,N})\\
w_{m+1,i}=\frac{w_{mi}}{Z_m}\exp(-\alpha_my_iG_m(x_i)),\quad i=1,2,\cdots,N</script><p>其中，<script type="math/tex">Z_m</script>是规范化因子，使得<script type="math/tex">D_{m+1}</script>成为一个概率分布。</p>
<script type="math/tex; mode=display">
Z_m = \sum_{i=1}^N{w_{mi}}\exp(-\alpha_my_iG_m(x_i))</script><p>根据基本分类器，构造线性组合，得到最终分类器</p>
<script type="math/tex; mode=display">
f(x)=\sum_{m=1}^M\alpha_mG_m(x) \\
G(x)=sign(f(x))</script><p>计算<script type="math/tex">G_m(x)</script>系数<script type="math/tex">\alpha_m</script>时，<script type="math/tex">e_m\leq\frac12</script>时，<script type="math/tex">\alpha_m\geq0</script>，并且<script type="math/tex">\alpha_m</script>关于<script type="math/tex">e_m</script>递减，所以分类误差率越小的基本分类器，在最终分类器中的作用越大。</p>
<p>更新权值时，可以写成如下形式：</p>
<script type="math/tex; mode=display">
\begin{align}
w_{m+1,i}=\begin{cases}\frac{w_{mi}}{Z_m}e^{-\alpha_m},\quad &G_m(x_i)=y_i\\\frac{w_{mi}}{Z_m}e^{\alpha_m},\quad &G_m(x_i)\neq y_i\end{cases}
\end{align}</script><p>所以误分类样本的权值得以扩大，在下一轮学习中起更大的作用。不改变训练数据，而不断改变训练数据权值的分布，这是AdaBoost的一个特点。</p>
<blockquote>
<p>注意，<script type="math/tex">\sum\alpha_m\neq1</script></p>
</blockquote>
<h2 id="8-2-AdaBoost算法的训练误差分析"><a href="#8-2-AdaBoost算法的训练误差分析" class="headerlink" title="8.2 AdaBoost算法的训练误差分析"></a>8.2 AdaBoost算法的训练误差分析</h2><p><strong>定理 8.1</strong>    AdaBoost算法最终分类器的训练误差界为</p>
<script type="math/tex; mode=display">
\frac1N\sum_{i=1}^NI(G(x_i)\neq y_i)\leq\frac1N\sum_i\exp(-y_if(x_i))\neq y_i)=\prod_mZ_m</script><p><strong>定理8.2</strong>    二分类问题中，AdaBoost的训练误差界为</p>
<script type="math/tex; mode=display">
\begin{align}
\prod_{m=1}^MZ_m&=\prod_{m=1}^M[2\sqrt{e_m(1-e_m)}]\\
&=\prod_{m=1}^M\sqrt{(1-4\gamma_m^2)}\\
&\leq\exp(-2\sum_{m=1}^M\gamma_m^2)
\end{align}</script><p>其中，<script type="math/tex">\gamma_m=\frac12-e_m</script></p>
<h2 id="8-3-AdaBoost算法的解释"><a href="#8-3-AdaBoost算法的解释" class="headerlink" title="8.3 AdaBoost算法的解释"></a>8.3 AdaBoost算法的解释</h2><h3 id="前向分步算法"><a href="#前向分步算法" class="headerlink" title="前向分步算法"></a>前向分步算法</h3><p>考虑加法模型</p>
<script type="math/tex; mode=display">
f(x)=\sum_{m=1}^M\beta_mb(x;\gamma_m)</script><p>其中，<script type="math/tex">b(x;\gamma_m)</script>为基函数，<script type="math/tex">\gamma_m</script>为函数的参数。</p>
<p>给定训练集及损失函数<script type="math/tex">L(y,f(x))</script>的条件下，学习加法模型即为损失函数极小化问题</p>
<script type="math/tex; mode=display">
\min_{\beta_m,\gamma_m}\sum_{i=1}^NL(y_i,\sum_{m=1}^M\beta_mb(x_i;\gamma_m))</script><p>通常这是一个复杂的优化问题，前向分步算法的想法是：因为学习的是加法模型，如果能够从前向后，每步只学习一个基函数与系数，逐步逼近，就可以简化复杂度，即每步只考虑优化如下函数</p>
<script type="math/tex; mode=display">
\min_{\beta,\gamma}\sum_{i=1}^NL(y_i,\beta b(x_i;\gamma))</script><h3 id="前向分步与AdaBoost"><a href="#前向分步与AdaBoost" class="headerlink" title="前向分步与AdaBoost"></a>前向分步与AdaBoost</h3><p><strong>定理8.3</strong>    AdaBoost是前向分步算法的特例。这时，模型是由基本分类器组成的加法模型，损失函数是指数函数。</p>
<h2 id="8-4-提升树"><a href="#8-4-提升树" class="headerlink" title="8.4 提升树"></a>8.4 提升树</h2><h3 id="提升树模型"><a href="#提升树模型" class="headerlink" title="提升树模型"></a>提升树模型</h3><p>提升方法实际采用加法模型与前向分步算法，以决策树为基函数的提升方法就称为提升树。</p>
<p>提升树模型可以表示为决策树的加法模型</p>
<script type="math/tex; mode=display">
f_M(x)=\sum_{m=1}^MT(x;\Theta_m)</script><p>其中，<script type="math/tex">T(x;\Theta_m)</script>表示决策树，<script type="math/tex">M</script>表示树的个数。</p>
<h3 id="提升树算法"><a href="#提升树算法" class="headerlink" title="提升树算法"></a>提升树算法</h3><p>首先初始化提升树<script type="math/tex">f_0(x)=0</script>，第m步的模型是</p>
<script type="math/tex; mode=display">
f_m(x)=f_{m-1}(x)+T(x;\Theta_m)</script><p>通过经验风险最小化确定下一棵决策树的参数</p>
<script type="math/tex; mode=display">
\hat\Theta_m=\arg\min_{\Theta_m}\sum_{i=1}^NL(y_i,f_{m-1}(x_i)+T(x_i;\Theta_m))</script><p>对于二分类问题，提升树算法只需要将AdaBoost的基本分类器限制为二类分类树即可，此时的提升树算法是AdaBoost的特殊情况。</p>
<h3 id="梯度提升"><a href="#梯度提升" class="headerlink" title="梯度提升"></a>梯度提升</h3><p>对于提升树算法，当损失函数是平方损失和指数损失函数时，每一步优化是很简单的。</p>
<p>对于一般损失函数，Freidman提出了梯度提升算法，利用损失函数的负梯度值</p>
<script type="math/tex; mode=display">
-[\frac{\partial L(y,f(x_i))}{\partial f(x_i)}]_{f(x)=f_{m-1}(x)}</script><p>作为回归问题中残差的近似值，拟合回归树。</p>
<h2 id="Scikit-learn"><a href="#Scikit-learn" class="headerlink" title="Scikit-learn"></a>Scikit-learn</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> AdaBoostClassifier</span><br><span class="line"></span><br><span class="line">clf = AdaBoostClassifier(n_estimators=<span class="number">100</span>, learning_rate=<span class="number">0.5</span>)</span><br><span class="line">clf.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">clf.score(X_test, y_test)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>统计学习方法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>提升方法</tag>
      </tags>
  </entry>
  <entry>
    <title>统计学习方法（六）Logistic回归与最大熵模型</title>
    <url>/2020/08/17/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89Logistic%E5%9B%9E%E5%BD%92%E4%B8%8E%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>Logistic回归是统计学习中的分类方法，最大熵是概率模型学习的一个准则，推广到分类问题得到最大熵模型。</p>
<a id="more"></a>
<h2 id="6-1-Logistic回归模型"><a href="#6-1-Logistic回归模型" class="headerlink" title="6.1 Logistic回归模型"></a>6.1 Logistic回归模型</h2><h3 id="Logistic分布"><a href="#Logistic分布" class="headerlink" title="Logistic分布"></a>Logistic分布</h3><p>设X为连续随机变量，X服从Logistic分布是指</p>
<script type="math/tex; mode=display">
F(x) = P(X\leq x) = \frac 1 {1+e^{-(x-\mu)/\gamma}} \\
f(x) = F'(x) = \frac {e^{-(x-\mu)/\gamma}} {\gamma(1+e^{-(x-\mu)/\gamma})^2}</script><p>其中<script type="math/tex">\mu</script>为位置参数，<script type="math/tex">\gamma > 0</script>为形状参数</p>
<p>分布函数的图形是S形曲线，关于点<script type="math/tex">(\mu, \frac 1 2)</script>中心对称</p>
<script type="math/tex; mode=display">
F(\mu-x) + F(x-\mu) = 1</script><p><img src="/2020/08/17/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89Logistic%E5%9B%9E%E5%BD%92%E4%B8%8E%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B/1.png" alt></p>
<h3 id="二项Logistic回归模型"><a href="#二项Logistic回归模型" class="headerlink" title="二项Logistic回归模型"></a>二项Logistic回归模型</h3><p>二项Logistic回归模型是一种分类模型，由条件概率<script type="math/tex">P(Y|X)</script>表示，其中随机变量Y取值为1或0，条件概率分布如下：</p>
<script type="math/tex; mode=display">
P(Y=1|x) = \frac {\exp(w\cdot x+b)} {1 + \exp(w\cdot x+b)} \\
P(Y=0|x) = \frac {1} {1 + \exp(w\cdot x+b)}</script><p>w称为权值向量，b称为偏置。</p>
<p>有时为了方便，用如下记法</p>
<script type="math/tex; mode=display">
P(Y=1|x) = \frac {\exp(w\cdot x)} {1 + \exp(w\cdot x)} \\
P(Y=0|x) = \frac {1} {1 + \exp(w\cdot x)} \\
w = (w^{(1)}, w^{(2)},\cdots, w^{(n)}, b) ,\quad x = (x^{(1)}, x^{(2)}, \cdots, x^{(n)}, 1)</script><p>注意到</p>
<script type="math/tex; mode=display">
\log\frac{P(Y=1|x)}{1 - P(Y=1|x)} = w\cdot x</script><p>输出Y=1的对数几率是输入x的线性函数表示的模型，即Logistic模型。</p>
<h3 id="模型参数估计"><a href="#模型参数估计" class="headerlink" title="模型参数估计"></a>模型参数估计</h3><p>对于给定的训练集T，可以用极大似然估计法估计模型参数。</p>
<script type="math/tex; mode=display">
P(Y=1|x) = \pi(x),\quad P(Y=0|x) = 1-\pi(x)</script><p>似然函数为</p>
<script type="math/tex; mode=display">
\prod_{i=1}^N[\pi(x_i)]^{y_i}[1-\pi(x_i)]^{1-y_i}</script><p>对数似然函数为</p>
<script type="math/tex; mode=display">
\begin{align}
L(w) &= \sum_{i=1}^N[y_i\log\pi(x_i)+(1-y_i)log(1-\pi(x_i))] \\
&= \sum_{i=1}^N[y_i\log\frac{\pi(x_i)}{1-\pi(x_i)}+log(1-\pi(x_i))] \\
&= \sum_{i=1}^N[y_i(w\cdot x_i)-log(1+\exp(w\cdot x_i))]
\end{align}</script><p>对L(w)求极大值，得到w的估计值。</p>
<p>这样问题就变成了以L(w)为目标函数的最优化问题，通常采用梯度下降法及拟牛顿法。</p>
<h3 id="多项Logistic回归"><a href="#多项Logistic回归" class="headerlink" title="多项Logistic回归"></a>多项Logistic回归</h3><p>上述的模型是二分类模型，可以推广为多分类模型。</p>
<p>假设Y的取值集合是<script type="math/tex">\{1,2,\cdots,K\}</script>，则多项Logistic模型为</p>
<script type="math/tex; mode=display">
P(Y=k|x) = \frac {\exp(w_k\cdot x+b)} {1 + \sum_k\exp(w_k\cdot x+b)} \\
P(Y=K|x) = \frac 1 {1 + \sum_k\exp(w_k\cdot x+b)} \\
k = 1,2, \cdots, K-1</script><h2 id="6-2-最大熵模型"><a href="#6-2-最大熵模型" class="headerlink" title="6.2 最大熵模型"></a>6.2 最大熵模型</h2><h3 id="最大熵原理"><a href="#最大熵原理" class="headerlink" title="最大熵原理"></a>最大熵原理</h3><p>假设离散随机变量X的概率分布是P(X)，则熵为</p>
<script type="math/tex; mode=display">
H(P) = -\sum_xP(x)\log P(x)</script><p>熵满足下列不等式</p>
<script type="math/tex; mode=display">
0 \leq H(P) \leq \log |X|</script><p>当且仅当X服从均匀分布时，熵最大。</p>
<h3 id="模型定义"><a href="#模型定义" class="headerlink" title="模型定义"></a>模型定义</h3><p>假设分类模型是条件概率分布，给定训练集T，学习的目标是用最大熵原理选择最好的分类模型。</p>
<p>训练集的经验分布</p>
<script type="math/tex; mode=display">
\widetilde P(X=x, Y=y) = \frac {\nu(X=x,Y=y)}{N}\\
\widetilde P(X=x) = \frac {\nu(X=x)}{N}</script><p>其中<script type="math/tex">\nu(X=x,Y=y)</script>表示样本出现的频数。</p>
<p>用特征函数描述输入与输出的关系</p>
<script type="math/tex; mode=display">
f(x,y) = \begin{cases} 1, \quad x与y满足某一事实 \\ 0, \quad否则\end{cases}</script><p>经验分布</p>
<script type="math/tex; mode=display">
E_{\widetilde{P}}(f) = \sum_{x,y}\widetilde P(x,y)f(x,y) \\
E_{\widetilde{P}}(f) = \sum_{x,y}\widetilde P(x)P(y|x)f(x,y)</script><p>如果模型能够获取训练集中的数据，即可认为两个期望值相等。</p>
<p>假设满足所有约束条件的模型集合为</p>
<script type="math/tex; mode=display">
{\cal C} = \{P\in {\cal P}|E_P(f_i) = E_{\widetilde P}(f_i), \quad i=1,2,\cdots,n\}</script><p>定义在条件概率分布P(Y|X)熵的条件熵为</p>
<script type="math/tex; mode=display">
H(P) = -\sum_{x,y}\widetilde P(x)P(y|x)\log P(y|x)</script><p>则模型集合中条件熵最大的模型称为最大熵模型。</p>
<h3 id="模型学习"><a href="#模型学习" class="headerlink" title="模型学习"></a>模型学习</h3><p>给定训练集以及特征函数，最大熵模型的学习等价于约束最优化问题</p>
<script type="math/tex; mode=display">
\begin{align}
\min_{\cal P\in C}&& &-H(P) = \sum_{x,y}\widetilde P(x)P(y|x)\log P(y|x) \\
s.t.&& &E_P(f_i) - E_{\widetilde P}(f_i)=0,\quad i=1,2,\cdots,n \\
&& &\sum_yP(y|x) = 1 \\
\end{align}</script><p>将约束最优化的原始问题转化为无约束最优化的对偶问题，通过拉格朗日乘数法求解。</p>
<p>引入拉格朗日乘子，定义拉格朗日函数</p>
<script type="math/tex; mode=display">
\begin{align}
L(P,w) &= -H(P) + w_o(1-\sum_yP(y|x))+\sum_{i=1}^nw_i(E_P(f_i) - E_{\widetilde P}(f_i)) \\
&= \sum_{x,y}\widetilde P(x)P(y|x)\log P(y|x) + w_o(1-\sum_yP(y|x))
\\ &\quad +\sum_{i=1}^nw_i(\sum_{x,y}\widetilde P(x,y)f_i(x,y) - \sum_{x,y}\widetilde P(x)P(y|x)f_i(x,y))
\end{align}</script><p>原始问题是</p>
<script type="math/tex; mode=display">
\min_{\cal P\in C}\max_wL(P,w)</script><p>对偶问题是</p>
<script type="math/tex; mode=display">
\max_{w}\min_{\cal P\in C}L(P,w)</script><p>具体地</p>
<script type="math/tex; mode=display">
\begin{align}
\frac {\part L(P,w)} {\part P(y|x)} &= \sum_{x,y}\widetilde P(x)(logP(y|x)+1)-\sum_yw_0-\sum_{x,y}(\widetilde P(x)\sum_{i=1}^nw_if_i(x,y)) \\
&= \sum_{x,y}\widetilde P(x)(logP(y|x)+1-w_0-\sum_{i=1}^nw_if_i(x,y))
\end{align}</script><p>令<script type="math/tex">\frac {\part L(P,w)} {\part P(y|x)}=0</script>，得到</p>
<script type="math/tex; mode=display">
P_w(y|x) = \frac 1 {Z_w(x)}\exp(\sum_{i=1}^nw_if_i(x,y)) \\
Z_w(x) = \sum_y\exp(\sum_{i=1}^nw_if_i(x,y))</script><script type="math/tex; mode=display">Z_w(x)$$称为规范化因子，$$f_i(x,y)$$是特征函数，由此表示的模型$$P_w$$就是最大熵模型。

对偶函数的极大化，等价于最大熵模型的极大似然估计。

## 6.3 模型学习的最优化算法

### 改进的迭代尺度法

改进的迭代尺度法（improved iterative scaling，IIS）基本想法是，找到新的参数向量$$w+\delta$$，使得模型的对数似然函数值增大，即</script><p>\begin{align}<br>L(w+\delta) - L(w) &amp;= \sum_{x,y}\widetilde P(x,y)\log P_{w+\delta}(y|x) - \widetilde P(x,y)\log P_{w}(y|x) \\<br>&amp;= \sum_{x,y}\widetilde P(x,y)\sum_{i=1}^n\delta_if_i(x,y) - \sum_x\widetilde P(x)\log \frac{Z_{w+\delta}(x)}{Z_w(x)} \geq 0<br>\end{align}</p>
<script type="math/tex; mode=display">
利用不等式</script><p>-\log\alpha\geq1-\alpha,\quad\alpha&gt;0</p>
<script type="math/tex; mode=display">
由此</script><p>\begin{align}<br>L(w+\delta) - L(w) &amp;\geq \sum_{x,y}\widetilde P(x,y)\sum_{i=1}^n\delta_if_i(x,y)+1-\sum_x\widetilde P(x)\frac{Z_{w+\delta}(x)}{Z_w(x)} \\<br>&amp;= \sum_{x,y}\widetilde P(x,y)\sum_{i=1}^n\delta_if_i(x,y)+1-\sum_x\widetilde P(x)\sum_yP_w(y|x)\exp\sum_{i=1}^n\delta_if_i(x,y) \\<br>&amp;= A(\delta|w)<br>\end{align}</p>
<script type="math/tex; mode=display">
即$$A(\delta|w)$$是改变量的一个下界，IIS试图每次只优化其中一个变量$$\delta_i$$，而固定其他变量。

通过推算，可以得到新的（相对不紧的）下界</script><p>L(w+\delta)-L(w)\geq B(\delta|w)</p>
<script type="math/tex; mode=display">
通过对$$B(\delta|w)$$求偏导数，并令其为0，得到相应的等式，依次求解方程即可。

#### 算法

**输入**：特征函数，经验分布，模型

**输出**：最优参数值，最优模型

**步骤**：

- $$\forall i\in\{1,2,\cdots,n\},\quad w_i=0</script><ul>
<li><script type="math/tex; mode=display">\forall i\in\{1,2,\cdots,n\}</script><ul>
<li><script type="math/tex; mode=display">\delta_i$$满足方程</script><p>\sum_{x,y}\widetilde P(x)P(y|x)f_i(x,y)\exp(\delta_if^#(x,y)) = E_{\widetilde P}(f_i)</p>
<script type="math/tex; mode=display">
其中</script><p>f^#(x,y) = \sum_{i=1}^nf_i(x,y)<br>$$</p>
</li>
<li><p>更新<script type="math/tex">w_i</script>：<script type="math/tex">w_i\leftarrow w_i+\delta_i</script></p>
</li>
</ul>
</li>
<li><p>重复直至所有<script type="math/tex">w_i</script>都收敛</p>
</li>
</ul>
<h3 id="拟牛顿法"><a href="#拟牛顿法" class="headerlink" title="拟牛顿法"></a>拟牛顿法</h3><p>略。</p>
<h2 id="Scikit-learn"><a href="#Scikit-learn" class="headerlink" title="Scikit-learn"></a>Scikit-learn</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"></span><br><span class="line"><span class="comment"># solver: liblinear, lbfgs, newton-cg, sag</span></span><br><span class="line">clf = LogisticRegression(max_iter=<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">clf.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">clf.score(X_test, y_test)</span><br><span class="line"></span><br><span class="line">print(clf.coef_, clf.intercept_)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>统计学习方法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>Logistic回归</tag>
      </tags>
  </entry>
  <entry>
    <title>统计学习方法（四）朴素贝叶斯法</title>
    <url>/2020/08/14/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%B3%95/</url>
    <content><![CDATA[<p>朴素贝叶斯法基于贝叶斯定理，对于训练集，首先根据特征条件假设联合概率分布，基于此，对给定的输入，利用贝叶斯定理求出后验概率最大的输出。</p>
<a id="more"></a>
<h2 id="4-1-朴素贝叶斯法的学习与分类"><a href="#4-1-朴素贝叶斯法的学习与分类" class="headerlink" title="4.1 朴素贝叶斯法的学习与分类"></a>4.1 朴素贝叶斯法的学习与分类</h2><h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><p>先验概率分布</p>
<script type="math/tex; mode=display">
P(Y=c_k), \quad k=1,2,...K \tag{4.1}</script><p>条件概率分布</p>
<script type="math/tex; mode=display">
P(X=x|Y=c_k) = P(X^{(1)}=x^{(1)},...,X^{(n)}=x^{(n)}|Y=c_k) \tag{4.2}</script><p>基本假设是条件独立性</p>
<script type="math/tex; mode=display">
\begin{align}
P(X=x|Y=c_k) &= P(X^{(1)}x^{(1)},...,X^{(n)}=x^{(n)}|Y=c_k) \\
&= \prod _{j=1}^nP(X^{(j)}=x^{(j)}|Y=c_k) \\
\end{align}
\tag{4.3}</script><p>后验概率计算</p>
<script type="math/tex; mode=display">
P(Y=c_k|X=x)=\frac {P(X=x|Y=c_k)P(Y=c_k)} {P(X=x)}= \frac {P(X=x|Y=c_k)P(Y=c_k)} {\sum_j P(X=x|Y=c_j)P(Y=c_j)} \tag{4.4}</script><p>代入(4.3)即得</p>
<script type="math/tex; mode=display">
\begin{align}
P(Y=c_k|X=x)= \frac {P(Y=c_k)\prod_{j=1}^nP(X^{(j)}=x^{(j)}|Y=c_k)} {\sum_j P(Y=c_j)\prod _{i=1}^nP(X^{(i)}=x^{(i)}|Y=c_j)} \tag{4.5}
\end{align}</script><p>所以朴素贝叶斯分类器可表示为</p>
<script type="math/tex; mode=display">
\begin{align}
y=f(x)&= \arg\max_{c_k}\frac {P(Y=c_k)\prod _{j=1}^nP(X^{(j)}=x^{(j)}|Y=c_k)} {\sum_j P(Y=c_j)\prod _{i=1}^nP(X^{(i)}=x^{(i)}|Y=c_j)} \\ 
&=\arg\max_{c_k}P(Y=c_k)\prod _{j=1}^nP(X^{(j)}=x^{(j)}|Y=c_k)
\end{align}
\tag{4.6}</script><h3 id="后验概率最大化"><a href="#后验概率最大化" class="headerlink" title="后验概率最大化"></a>后验概率最大化</h3><p>假设选择0-1损失函数，这时期望风险函数为</p>
<script type="math/tex; mode=display">
\begin{align}
R_{exp}(f) &= E[L(Y,f(X))]\\
&= E_X\sum_{k=1}^K[L(c_k,f(X))]P(c_k|X)
\end{align}</script><p>为最小化期望风险，只需对X=x逐个极小化</p>
<script type="math/tex; mode=display">
\begin{align}
f(x) &= \arg\min_{y\in \cal Y}\sum_{k=1}^KL(c_k,y)P(c_k|X=x) \\
&= \arg\min_{y\in \cal Y}\sum_{k=1}^KP(y\neq c_k|X=x) \\
&= \arg\min_{y\in \cal Y}\sum_{k=1}^K(1-P(y= c_k|X=x)) \\
&= \arg\max_{y\in \cal Y}\sum_{k=1}^KP(y= c_k|X=x)
\end{align}</script><h2 id="4-2-朴素贝叶斯法的参数估计"><a href="#4-2-朴素贝叶斯法的参数估计" class="headerlink" title="4.2 朴素贝叶斯法的参数估计"></a>4.2 朴素贝叶斯法的参数估计</h2><h3 id="极大似然估计"><a href="#极大似然估计" class="headerlink" title="极大似然估计"></a>极大似然估计</h3><p>先验概率的极大似然估计是</p>
<script type="math/tex; mode=display">
P(Y=c_k) = \frac{\sum_{i=1}^NI(y_i=c_k)}{N},\quad k=1,2,..,K \tag{4.7}</script><p>条件概率的极大似然估计是</p>
<script type="math/tex; mode=display">
P(X^{(j)}=a_{ji}|Y=c_k) = \frac{\sum_{i=1}^NI(x_i^{(j)}=a_{ji},y_i=c_k)}{\sum_{i=1}^NI(y_i=c_k)},\quad k=1,2,..,K \tag{4.8}</script><h3 id="朴素贝叶斯算法"><a href="#朴素贝叶斯算法" class="headerlink" title="朴素贝叶斯算法"></a>朴素贝叶斯算法</h3><ul>
<li>计算先验概率及条件概率<script type="math/tex; mode=display">
\begin{align}
&P(Y=c_k) = \frac{\sum_{i=1}^NI(y_i=c_k)}{N},\quad k=1,2,..,K \\
&P(X^{(j)}=a_{ji}|Y=c_k) = \frac{\sum_{i=1}^NI(x_i^{(j)}=a_{ji},y_i=c_k)}{\sum_{i=1}^NI(y_i=c_k)},\quad k=1,2,..,K \\
&j=1,2,...,n;\quad k=1,2,...,K
\end{align}</script></li>
<li>对于给定实例，计算<script type="math/tex; mode=display">
P(Y=c_k)\prod _{j=1}^nP(X^{(j)}=x^{(j)}|Y=c_k)</script></li>
<li>确定实例x的类<script type="math/tex; mode=display">
y=\arg\max_{c_k}P(Y=c_k)\prod _{j=1}^nP(X^{(j)}=x^{(j)}|Y=c_k)</script></li>
</ul>
<h3 id="贝叶斯估计"><a href="#贝叶斯估计" class="headerlink" title="贝叶斯估计"></a>贝叶斯估计</h3><p>极大似然估计可能会出现所要估计的概率值为0的情况，这时会影响后验概率的计算结果，使分类产生偏差。</p>
<p>条件概率的贝叶斯估计是</p>
<script type="math/tex; mode=display">
P_\lambda(X^{(j)}=a_{ji}|Y=c_k) = \frac {\sum_{i=1}^NI(x_i^{(j)}=a_{ji},y_i=c_k)+\lambda}{\sum_{i=1}^NI(y_i=c_k)+S_j\lambda}, \quad \lambda\geq0 \tag{4.9}</script><p>等价于在随机变量每个取值的频数上赋予一个正数，λ=0时即为极大似然估计，常取λ=1，称为拉普拉斯平滑。</p>
<p>显然有</p>
<script type="math/tex; mode=display">
P_\lambda(X^{(j)}=a_{ji}|Y=c_k) > 0 \\
\sum_{l=1}^{S_j}P(X^{(j)}=a_{ji}|Y=c_k) = 1</script><p>先验概率的贝叶斯估计是</p>
<script type="math/tex; mode=display">
P_\lambda(Y=c_k) = \frac {\sum_{i=1}^NI(y_i=c_k)+\lambda}{N+K\lambda}, \quad \lambda\geq0 \tag{4.10}</script><h2 id="Scikit-learn"><a href="#Scikit-learn" class="headerlink" title="Scikit-learn"></a>Scikit-learn</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> GaussianNB</span><br><span class="line"><span class="comment"># from sklearn.naive_bayes import BernoulliNB, MultinomialNB</span></span><br><span class="line"></span><br><span class="line">clf = GaussianNB()</span><br><span class="line">clf.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">clf.score(X_test, y_test)</span><br><span class="line"></span><br><span class="line">clf.predict([[<span class="number">4.4</span>,  <span class="number">3.2</span>,  <span class="number">1.3</span>,  <span class="number">0.2</span>]])</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>给定先验分布，利用贝叶斯定理求出后验概率最大的类。</p>
]]></content>
      <categories>
        <category>统计学习方法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>贝叶斯</tag>
      </tags>
  </entry>
  <entry>
    <title>《C++ Primer》 Chapter 1 开始</title>
    <url>/2020/11/23/%E3%80%8AC++%20Primer%E3%80%8B%20Chapter%201%20%E5%BC%80%E5%A7%8B%20/</url>
    <content><![CDATA[<p>初识C++。</p>
<a id="more"></a>
<h2 id="编写一个简单的C-程序"><a href="#编写一个简单的C-程序" class="headerlink" title="编写一个简单的C++程序"></a>编写一个简单的C++程序</h2><p>每个C++程序都包含若干个函数，其中一个必须命名为main，操作系统通过调用main运行C++程序。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="编译、运行程序"><a href="#编译、运行程序" class="headerlink" title="编译、运行程序"></a>编译、运行程序</h3><p>程序运行后，可以通过echo命令访问main的返回值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> $? // UNIX</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$ERRORLEVEL</span>% // Windows</span><br></pre></td></tr></table></figure>
<h2 id="初识输入输出"><a href="#初识输入输出" class="headerlink" title="初识输入输出"></a>初识输入输出</h2><div class="table-container">
<table>
<thead>
<tr>
<th>对象</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>cin</td>
<td>标准输入</td>
</tr>
<tr>
<td>cout</td>
<td>标准输出</td>
</tr>
<tr>
<td>cerr</td>
<td>标准错误</td>
</tr>
<tr>
<td>clog</td>
<td>程序运行时的一般性信息</td>
</tr>
</tbody>
</table>
</div>
<h3 id="注释简介"><a href="#注释简介" class="headerlink" title="注释简介"></a>注释简介</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单行注释</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    多行注释</span></span><br><span class="line"><span class="comment">    不能嵌套</span></span><br><span class="line"><span class="comment">/*</span></span><br></pre></td></tr></table></figure>
<h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><p>while &amp; for &amp; if</p>
<h3 id="读取数量不定的输入数据"><a href="#读取数量不定的输入数据" class="headerlink" title="读取数量不定的输入数据"></a>读取数量不定的输入数据</h3><p>当遇到文件结束符（EOF）或遇到一个无效输入时，istream对象的状态会变成无效，条件为假。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; value)</span><br><span class="line">        sum += value;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Sum is &quot;</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Windows系统中，输入EOF的方式是Ctrl + Z；UNIX中，方法是Ctrl + D。</p>
</blockquote>
<h3 id="统计输入的词频"><a href="#统计输入的词频" class="headerlink" title="统计输入的词频"></a>统计输入的词频</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> currVal = <span class="number">0</span>, val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; currVal) &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; val)</span><br><span class="line">            <span class="keyword">if</span> (val == currVal)</span><br><span class="line">                ++cnt;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; currVal &lt;&lt; <span class="string">&quot; occurs &quot;</span></span><br><span class="line">                          &lt;&lt; cnt &lt;&lt; <span class="string">&quot; times &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                currVal = val;</span><br><span class="line">                cnt = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; currVal &lt;&lt; <span class="string">&quot; occurs &quot;</span></span><br><span class="line">                  &lt;&lt; cnt &lt;&lt; <span class="string">&quot; times &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类简介"><a href="#类简介" class="headerlink" title="类简介"></a>类简介</h2><blockquote>
<p>包含来自标准库的头文件，使用&lt;&gt;包含头文件名；不属于标准库的头文件，使用””包围。</p>
</blockquote>
]]></content>
      <categories>
        <category>《C++ Primer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>《C++ Primer》 Chapter 2 变量和基本类型</title>
    <url>/2020/11/23/%E3%80%8AC++%20Primer%E3%80%8B%20Chapter%202%20%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>介绍C++的基本内置类型和复合类型，包括引用和指针的声明，以及const限定符的使用方法。</p>
<a id="more"></a>
<h2 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h2><p>下表列出了各内置类型的最小尺寸。</p>
<p><img src="/2020/11/23/%E3%80%8AC++%20Primer%E3%80%8B%20Chapter%202%20%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/image-20201123150453260.png" alt="image-20201123150453260"></p>
<blockquote>
<p>2^31 - 1= 2147483647是个常见的数字。</p>
</blockquote>
<h3 id="带符号类型和无符号类型"><a href="#带符号类型和无符号类型" class="headerlink" title="带符号类型和无符号类型"></a>带符号类型和无符号类型</h3><p>无符号类型只能表示大于等于0的值，带符号类型可以表示正负数和0。</p>
<p>8bit的unsigned char可以表示0~255之间的值，signed char则为-128~127。</p>
<blockquote>
<p>执行浮点数运算时选用double</p>
</blockquote>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul>
<li>当把非bool的算术值赋给bool时，初始值为0结果为false，否则为true。</li>
<li>把bool值赋给非bool时，初始值为false则结果为0，true则结果为1。</li>
<li>赋给无符号类型一个超出表示范围的值，结果是取模后的余数。<ul>
<li>赋-1给unsigned char，结果是255。</li>
<li><strong>切勿混用带符号类型和无符号类型！</strong></li>
<li>因为无符号数非负，所以下面这段代码为死循环。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">10</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h3 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h3><p>C++规定的转义序列如下</p>
<p><img src="/2020/11/23/%E3%80%8AC++%20Primer%E3%80%8B%20Chapter%202%20%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/image-20201123153641722.png" alt="image-20201123153641722"></p>
<p>C++还可以对常量添加前缀和后缀，改变默认类型。</p>
<ul>
<li>比如L’a’定义了宽字符型字面值，类型是wchar_t。</li>
</ul>
<p><img src="/2020/11/23/%E3%80%8AC++%20Primer%E3%80%8B%20Chapter%202%20%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/image-20201123153731472.png" alt="image-20201123153731472"></p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><p>以下四条语句都可以定义一个int变量并初始化为0。</p>
<p>在C++11，可以用花括号来初始化变量，称为列表初始化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> cnt = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cnt</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> cnt&#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>初始化：创建变量时，赋予其一个初始值。</p>
<p>赋值：把对象的当前值擦除，用一个新值代替。</p>
</blockquote>
<p>定义在函数体内部的内置类型变量将不被初始化，此时值是未定义的。</p>
<h3 id="变量定义-amp-声明"><a href="#变量定义-amp-声明" class="headerlink" title="变量定义&amp;声明"></a>变量定义&amp;声明</h3><ul>
<li>变量声明：规定了变量的类型和名字</li>
<li>变量定义：还申请存储空间，也可能会为变量赋一个初始值。</li>
<li>如果想声明一个变量而非定义，要添加关键字extern。</li>
<li>变量的定义只出现在一个文件中，其他使用该变量的文件对其声明，但不能重复定义。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i; <span class="comment">// 声明变量</span></span><br><span class="line"><span class="keyword">int</span> j;          <span class="comment">// 声明并定义</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>; <span class="comment">// 定义</span></span><br></pre></td></tr></table></figure>
<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><ul>
<li>标识符以字母或数字开头，大小写敏感。</li>
<li>变量名一般小写，类名一般以大写字母开头。</li>
<li>标识符由多个单词组成，应有区分，如student_loan或studentLoan。</li>
</ul>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ul>
<li>如果函数要用到全局变量，则不宜再定义一个同名的局部变量。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">// 用::cnt显式访问全局变量</span></span><br><span class="line">    <span class="comment">// result: 10 20</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ::cnt &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h2><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul>
<li>引用为对象起另外一个名字</li>
<li>无法令引用重新绑定到另外一个对象，所以引用必须初始化。</li>
<li>引用只能绑定在对象上，引用自身不是对象。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;refVal = val;</span><br><span class="line"><span class="keyword">int</span> refVal;        <span class="comment">// 报错：引用必须初始化</span></span><br></pre></td></tr></table></figure>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><ul>
<li>指针存放某个对象的地址，使用取地址符&amp;获取地址。</li>
<li>使用解引用符*访问指针指向的对象。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;val;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p &lt;&lt; *p; <span class="comment">// result: 008FF9F8 1024</span></span><br></pre></td></tr></table></figure>
<p>空指针不指向任何对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="number">0</span>; <span class="comment">// 指针不能指向字面值常量，0表示空指针。</span></span><br><span class="line"><span class="keyword">int</span> *p3 = <span class="literal">NULL</span>; <span class="comment">// include &lt;cstdlib&gt;</span></span><br></pre></td></tr></table></figure>
<p>void*是一种特殊的指针，可以指向任意非常量，不能执行解引用操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> pi = <span class="number">3.14</span>, *pd = &amp; pi;</span><br><span class="line"><span class="keyword">void</span> *pv = &amp;pi;</span><br><span class="line">pv = pd;</span><br></pre></td></tr></table></figure>
<h3 id="理解复合类型的声明"><a href="#理解复合类型的声明" class="headerlink" title="理解复合类型的声明"></a>理解复合类型的声明</h3><p>定义指针和引用时，最好将*和&amp;与变量名连在一起，以免引起误导。</p>
<p>指针可以指向指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> *pi = &amp;val;</span><br><span class="line"><span class="keyword">int</span> **ppi = &amp;pi;</span><br></pre></td></tr></table></figure>
<p>引用不是对象，所以不存在指向引用的指针。</p>
<p>但指针是对象，所以引用可以绑定指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;i;</span><br><span class="line"><span class="keyword">int</span> *&amp;r = p;    <span class="comment">// r是一个对指针p的引用</span></span><br><span class="line"></span><br><span class="line">r = &amp;i;</span><br><span class="line">*r = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h2 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h2><h3 id="const的引用"><a href="#const的引用" class="headerlink" title="const的引用"></a>const的引用</h3><p>使用const定义变量时，变量的值不能被改变，const对象必须初始化。</p>
<blockquote>
<p>一般const对象仅在文件内有效，多个文件中出现同名的const变量，等同于在不同文件中分别定义了独立的变量。</p>
<p>如果想共享const变量，需要用extern修饰。</p>
</blockquote>
<p>可以把引用绑定到const对象上，称为对常量的引用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> val = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;refVal = val;</span><br><span class="line">refVal = <span class="number">10</span>;        <span class="comment">// 错误：对常量的引用不能修改绑定的对象</span></span><br><span class="line"><span class="keyword">int</span> &amp;refVal2 = val; <span class="comment">// 错误：非常量引用不能绑定常量对象</span></span><br></pre></td></tr></table></figure>
<p>允许为一个常量引用绑定非常量的对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = i * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r4 = r1 * <span class="number">2</span>;    <span class="comment">// 错误：r1是常量引用，r4是非常量引用。</span></span><br></pre></td></tr></table></figure>
<p>常量引用绑定非常量对象时，不能通过常量引用改变值，但可以通过其他途径改变绑定对象的值。</p>
<h3 id="const与指针"><a href="#const与指针" class="headerlink" title="const与指针"></a>const与指针</h3><p>指向常量指针不能改变所指对象的值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *p = &amp;pi;</span><br><span class="line">*p = <span class="number">10</span>;        <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
<p>const指针不能改变指针本身的值，而非指向的那个值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> pi = <span class="number">3.14</span>, i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">double</span> *<span class="keyword">const</span> p = &amp;pi;</span><br><span class="line">p = &amp;i;            <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
<h3 id="顶层const"><a href="#顶层const" class="headerlink" title="顶层const"></a>顶层const</h3><p><strong>顶层const表示指针本身是常量，底层const表示指针指向的对象是一个常量。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> ci = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p1 = &amp;i;        <span class="comment">// top-level</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p2 = &amp;ci;    <span class="comment">// low-level</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p3 = p2; <span class="comment">// low-level &amp; top-level</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r = ci;        <span class="comment">// low-level</span></span><br></pre></td></tr></table></figure>
<h3 id="constexpr和常量表达式"><a href="#constexpr和常量表达式" class="headerlink" title="constexpr和常量表达式"></a>constexpr和常量表达式</h3><p>常量表达式是指值不会改变并且在编译过程中就能得到计算结果的表达式。</p>
<h2 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h2><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>有两种方法可以定义类型别名</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> wages;</span><br><span class="line"><span class="keyword">using</span> wages = <span class="keyword">double</span>;</span><br></pre></td></tr></table></figure>
<h3 id="auto-amp-decltype"><a href="#auto-amp-decltype" class="headerlink" title="auto &amp; decltype"></a>auto &amp; decltype</h3><p>auto让编译器去分析表达式所属的类型，auto定义的变量必须有初始值。</p>
<p>decltype可以返回操作数的数据类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(f()) sum = x;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>, *p = &amp;i;</span><br><span class="line"><span class="keyword">decltype</span>(*p) c; <span class="comment">// 错误：c是int&amp;，必须初始化。</span></span><br></pre></td></tr></table></figure>
<h2 id="自定义数据结构"><a href="#自定义数据结构" class="headerlink" title="自定义数据结构"></a>自定义数据结构</h2><h3 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SALES_DATA_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SALES_DATA_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>《C++ Primer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>《C++ Primer》 Chapter 3 字符串、向量和数组</title>
    <url>/2020/11/23/%E3%80%8AC++%20Primer%E3%80%8B%20Chapter%203%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>介绍标准库string和vector，以及迭代器和数组的使用。</p>
<a id="more"></a>
<h3 id="命名空间的using声明"><a href="#命名空间的using声明" class="headerlink" title="命名空间的using声明"></a>命名空间的using声明</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>::name;</span><br></pre></td></tr></table></figure>
<p>头文件不应该包含using声明。</p>
<h2 id="标准库类型string"><a href="#标准库类型string" class="headerlink" title="标准库类型string"></a>标准库类型string</h2><p>string定义在命名空间std中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std::string;</span><br></pre></td></tr></table></figure>
<h3 id="定义和初始化"><a href="#定义和初始化" class="headerlink" title="定义和初始化"></a>定义和初始化</h3><p>如果使用等号，实际上执行的是拷贝初始化。反之，执行的是直接初始化。</p>
<p><img src="/2020/11/23/%E3%80%8AC++%20Primer%E3%80%8B%20Chapter%203%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/image-20201130133107639.png" alt="image-20201130133107639"></p>
<h3 id="string对象上的操作"><a href="#string对象上的操作" class="headerlink" title="string对象上的操作"></a>string对象上的操作</h3><p><img src="/2020/11/23/%E3%80%8AC++%20Primer%E3%80%8B%20Chapter%203%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/image-20201130125844111.png" alt="image-20201130125844111"></p>
<h4 id="读写"><a href="#读写" class="headerlink" title="读写"></a>读写</h4><p>执行读取操作时，会自动忽略开头的空白字符，直至遇到下一处空白。</p>
<p>输入”    Hello World!    “，输出则为”Hello”。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以用getline读取一整行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">line</span>;</span><br><span class="line">    <span class="keyword">while</span> (getline(<span class="built_in">cin</span>, <span class="built_in">line</span>))</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">line</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="empty-amp-size"><a href="#empty-amp-size" class="headerlink" title="empty&amp;size"></a>empty&amp;size</h4><p>empty判断string对象是否为空，返回bool。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (getline(<span class="built_in">cin</span>, <span class="built_in">line</span>))</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">line</span>.empty())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">line</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>size返回string对象的长度，类型为string::size_type。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (getline(<span class="built_in">cin</span>, <span class="built_in">line</span>))</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">line</span>.empty())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">line</span>.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此时，空字符也会计数。</p>
</blockquote>
<p>当使用size_type进行比较时，注意不要与int混用，因为负值的带符号数会转化为大整数的无符号数。</p>
<h4 id="比较-amp-加法"><a href="#比较-amp-加法" class="headerlink" title="比较&amp;加法"></a>比较&amp;加法</h4><p>string对象逐字符比较，按字典序比较。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> s2 = <span class="string">&quot;abc def&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> s3 = <span class="string">&quot;abdef&quot;</span>;</span><br><span class="line"><span class="comment">// res: s1 &lt; s2 &lt; s3</span></span><br></pre></td></tr></table></figure>
<p>两个string对象可以相加，字面值也可以和string对象相加。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s1 = <span class="string">&quot;hello&quot;</span>, s2 = <span class="string">&quot;world&quot;</span>。</span><br><span class="line"><span class="built_in">string</span> s3 = s1 + s2。</span><br><span class="line"><span class="built_in">string</span> s4 = s1 + <span class="string">&quot; &quot;</span> + s2 + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> s5 = <span class="string">&quot;hello&quot;</span> + <span class="string">&quot; &quot;</span> + s2; <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>运算时，应保证+两侧的运算对象至少有一个是string。</p>
</blockquote>
<h3 id="处理string中的字符"><a href="#处理string中的字符" class="headerlink" title="处理string中的字符"></a>处理string中的字符</h3><p>下表给出了一些关于字符属性的函数。</p>
<p><img src="/2020/11/23/%E3%80%8AC++%20Primer%E3%80%8B%20Chapter%203%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/image-20201130125720977.png" alt="image-20201130125720977"></p>
<blockquote>
<p>C++标准库为了兼容C，将C的头文件如name.h，命名为cname。</p>
<p>C++程序应该使用cname形式的头文件，以区分从C继承的头文件。</p>
</blockquote>
<p>为了遍历string对象，可以使用下标，也可以使用范围for语句（推荐）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> c : s)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>如果想要改变字符，需要把循环变量定义为引用类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : s)</span><br><span class="line">    c = <span class="built_in">toupper</span>(c);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s;</span><br></pre></td></tr></table></figure>
<p>有时候只需要处理部分字符，可以使用下标，也可以使用迭代器（后续介绍）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现单词首字母大写</span></span><br><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">decltype</span>(s.<span class="built_in">size</span>()) index = <span class="number">0</span>;</span><br><span class="line">     index != s.<span class="built_in">size</span>(); ++index) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span> &amp;&amp; <span class="built_in">isalpha</span>(s[index])) &#123;</span><br><span class="line">        s[index] = <span class="built_in">toupper</span>(s[index]);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isalpha</span>(s[index]) &amp;&amp; !<span class="built_in">isalpha</span>(s[index<span class="number">-1</span>]))</span><br><span class="line">        s[index] = <span class="built_in">toupper</span>(s[index]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s; <span class="comment">// output: &quot;Hello world&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用下标时，切忌下标越界，应该时刻检查下标的合法性。</p>
</blockquote>
<h2 id="标准库类型vector"><a href="#标准库类型vector" class="headerlink" title="标准库类型vector"></a>标准库类型vector</h2><p>vector表示相同类型对象的集合，每个对象都有一个索引用于访问对象。因此vector也被称为容器，vector同时也是一个类模板（距离还比较遥远）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br></pre></td></tr></table></figure>
<p>模板实例化时，需要提供对象类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec;                <span class="comment">// 元素是int</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; file;    <span class="comment">// 元素是存放string的vector</span></span><br></pre></td></tr></table></figure>
<p>vector作为类模板，不是类型。</p>
<p>引用不是对象，不存在包含引用的vector。</p>
<h3 id="定义和初始化vector对象"><a href="#定义和初始化vector对象" class="headerlink" title="定义和初始化vector对象"></a>定义和初始化vector对象</h3><p><img src="/2020/11/23/%E3%80%8AC++%20Primer%E3%80%8B%20Chapter%203%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/image-20201130133133358.png" alt="image-20201130133133358"></p>
<p>注意区分列表初始化和元素数量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1&#123;<span class="number">10</span>&#125;; <span class="comment">// 列表初始化，v1有1个元素，值为10。</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// v2有10个元素，值为0。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v3&#123;<span class="number">10</span>, <span class="number">1</span>&#125;; <span class="comment">// 列表初始化，v3有2个元素，值为10和1。</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v4</span><span class="params">(<span class="number">10</span>, <span class="number">1</span>)</span></span>; <span class="comment">// v4有10个元素，值为1。</span></span><br></pre></td></tr></table></figure>
<h3 id="向vector对象添加元素"><a href="#向vector对象添加元素" class="headerlink" title="向vector对象添加元素"></a>向vector对象添加元素</h3><p>可以用vector的成员函数push_back添加元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">    v.push_back(i);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>与C不同，C++推荐先定义一个空的vector对象，运行时向其中添加具体值。</p>
</blockquote>
<h3 id="其他vector操作"><a href="#其他vector操作" class="headerlink" title="其他vector操作"></a>其他vector操作</h3><p><img src="/2020/11/23/%E3%80%8AC++%20Primer%E3%80%8B%20Chapter%203%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/image-20201130133935086.png" alt="image-20201130133935086"></p>
<p>vector同样支持范围for语句。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : v)    <span class="comment">// 使用引用对vector的元素赋值</span></span><br><span class="line">    i *= <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : v)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure>
<p>与string类似，vector的size函数返回类型为vector<T>::size_type。</T></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 统计各分数段内的人数</span></span><br><span class="line"><span class="comment">// input: 42 65 95 100 39 67 95 76 88 76 83 92 76 93 101</span></span><br><span class="line"><span class="comment">// output: 0 0 0 1 1 0 2 3 2 4 1</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span>&gt; <span class="title">scores</span><span class="params">(<span class="number">11</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">unsigned</span> grade = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; grade) &#123;</span><br><span class="line">    <span class="keyword">if</span> (grade &lt;= <span class="number">100</span>)</span><br><span class="line">        ++scores[grade/<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : scores)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="迭代器介绍"><a href="#迭代器介绍" class="headerlink" title="迭代器介绍"></a>迭代器介绍</h2><h3 id="使用迭代器"><a href="#使用迭代器" class="headerlink" title="使用迭代器"></a>使用迭代器</h3><p>有迭代器的类型拥有名为begin和end的成员。</p>
<p>begin成员返回指向第一个元素的迭代器，end成员返回指向容器“尾后”元素的迭代器，通常被称作尾后迭代器。</p>
<p>如果容器为空，begin和end返回的是同一个迭代器，都是尾后迭代器。</p>
<p><img src="/2020/11/23/%E3%80%8AC++%20Primer%E3%80%8B%20Chapter%203%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/image-20201130135012221.png" alt="image-20201130135012221"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isalpha</span>(*it))</span><br><span class="line">        *it = <span class="built_in">toupper</span>(*it);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>C++习惯在for循环中使用!=进行判断，因为大多数迭代器都没有定义&lt;运算符。</p>
</blockquote>
<p>迭代器也有const类型，能读取但不能修改vector。</p>
<p>为了便捷，C++11引入了两个新函数cbegin和cend。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line"><span class="keyword">auto</span> it1 = v1.<span class="built_in">begin</span>();    <span class="comment">// type: vector&lt;int&gt;::iterator</span></span><br><span class="line"><span class="keyword">auto</span> it2 = v2.<span class="built_in">begin</span>();  <span class="comment">// type: vector&lt;int&gt;::const_iterator</span></span><br><span class="line"><span class="keyword">auto</span> it3 = v1.cbegin(); <span class="comment">// type: vector&lt;int&gt;::const_iterator</span></span><br></pre></td></tr></table></figure>
<p>为了简化解引用和成员访问操作一起使用，C++定义了箭头运算符。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">*it.empty;   <span class="comment">// error</span></span><br><span class="line">(*it).empty;</span><br><span class="line">it-&gt;empty;</span><br></pre></td></tr></table></figure>
<h3 id="迭代器运算"><a href="#迭代器运算" class="headerlink" title="迭代器运算"></a>迭代器运算</h3><p><img src="/2020/11/23/%E3%80%8AC++%20Primer%E3%80%8B%20Chapter%203%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/image-20201130135031052.png" alt="image-20201130135031052"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 得到最接近中间元素的迭代器</span></span><br><span class="line"><span class="keyword">auto</span> mid = v.<span class="built_in">begin</span>() + v.<span class="built_in">size</span>() / <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>C++定义了迭代器的差值，类型为difference_type。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二分搜索</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="built_in">text</span>;</span><br><span class="line"><span class="built_in">string</span> sought;</span><br><span class="line"><span class="keyword">auto</span> beg = <span class="built_in">text</span>.<span class="built_in">begin</span>(), <span class="built_in">end</span> = <span class="built_in">text</span>.<span class="built_in">end</span>();</span><br><span class="line"><span class="keyword">auto</span> mid = <span class="built_in">text</span>.<span class="built_in">begin</span>() + (<span class="built_in">end</span> - beg) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (mid != <span class="built_in">end</span> &amp;&amp; *mid != sought) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sought &lt; *mid) <span class="comment">// 在前半部分则忽略后半部分</span></span><br><span class="line">        <span class="built_in">end</span> = mid;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        beg = mid + <span class="number">1</span>; <span class="comment">// 否则忽略前半部分</span></span><br><span class="line">    mid = beg + (<span class="built_in">end</span> - beg) /<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>与vector不同，数组的大小确定不变，不能随意增加元素。</p>
<h3 id="定义和初始化-1"><a href="#定义和初始化-1" class="headerlink" title="定义和初始化"></a>定义和初始化</h3><p>数组的长度在编译时必须已知，所以维度必须是常量表达式。</p>
<p>定义数组时，必须指定类型，不能使用auto。和vector一样，不存在引用的数组。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> cnt = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">unsigned</span> sz = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> *parr[sz];     <span class="comment">// 包含42个整型指针的数组</span></span><br><span class="line"><span class="built_in">string</span> bad[cnt]; <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
<p>数组也支持列表初始化，此时可以不指明长度，编译器会自动计算。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> sz = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> ial[sz] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a2[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a3[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;    <span class="comment">// a3[] = &#123;0, 1, 2, 0, 0&#125;</span></span><br></pre></td></tr></table></figure>
<p>值得注意的是，在使用字符数组时，会在结尾添加一个空字符。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> a1[] = &#123;<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;+&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> a2[] = &#123;<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;    <span class="comment">// 显式添加空字符</span></span><br><span class="line"><span class="keyword">char</span> a3[] = <span class="string">&quot;C++&quot;</span>;    <span class="comment">// 自动添加空字符</span></span><br><span class="line"><span class="keyword">char</span> a4[<span class="number">6</span>] = <span class="string">&quot;Daniel&quot;</span>; <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
<p>上述表达式中，a1长度为3，a2和a3的长度都是4，a4长度应改为7。</p>
<p>数组不允许拷贝和赋值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a2[] = a; <span class="comment">// error</span></span><br><span class="line">a2 = a; <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
<p>为了理解复杂的数组声明，可以从内向外阅读。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptrs[<span class="number">10</span>]; <span class="comment">// 含有10个整型指针的数组</span></span><br><span class="line"><span class="keyword">int</span> &amp;refs[<span class="number">10</span>]; <span class="comment">// 不存在引用的数组</span></span><br><span class="line"><span class="keyword">int</span> (*Parray)[<span class="number">10</span>] = &amp;arr; <span class="comment">// Parray指向一个含有10个整数的数组</span></span><br><span class="line"><span class="keyword">int</span> (&amp;arrRef)[<span class="number">10</span>] = arr;  <span class="comment">// arrRef引用一个含有10个整数的数组</span></span><br><span class="line"><span class="keyword">int</span> *(&amp;arry)[<span class="number">10</span>] = ptrs;  <span class="comment">// arry是数组的引用，该数组含有10个指针</span></span><br></pre></td></tr></table></figure>
<h3 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h3><p>数组也可以用范围for语句或下标运算符访问。</p>
<p>数组下标被定义为size_t类型，定义在cstddef头文件中。</p>
<h3 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h3><p>使用数组的时候，编译器一般会把它转换成指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> nums[] = &#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">string</span> *p1 = &amp;nums[<span class="number">0</span>]; <span class="comment">// p1指向nums的第一个元素</span></span><br><span class="line"><span class="built_in">string</span> *p2 = &amp;nums;       <span class="comment">// p2和p1等价</span></span><br></pre></td></tr></table></figure>
<p>尽管能计算得到数组的尾后指针，但容易出错。C++11引入两个函数begin和end，与容器的同名成员功能类似。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *beg = <span class="built_in">begin</span>(ia);</span><br><span class="line"><span class="keyword">int</span> *last = <span class="built_in">end</span>(ia);</span><br></pre></td></tr></table></figure>
<p>与容器相似，指针相减的类型名为ptrdiff_t，也定义在cstddef中。</p>
<h4 id="C风格字符串"><a href="#C风格字符串" class="headerlink" title="C风格字符串"></a>C风格字符串</h4><blockquote>
<p>尽管C++支持，但最好不好使用。</p>
</blockquote>
<p><img src="/2020/11/23/%E3%80%8AC++%20Primer%E3%80%8B%20Chapter%203%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/image-20201130144349734.png" alt="image-20201130144349734"></p>
<h4 id="与旧代码的接口"><a href="#与旧代码的接口" class="headerlink" title="与旧代码的接口"></a>与旧代码的接口</h4><p>允许使用字符串字面值初始化string对象，反过来则不行，需要使用c_str函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">&quot;hello world&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">char</span> *str = s; <span class="comment">// error</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *str = s.c_str();</span><br></pre></td></tr></table></figure>
<p>可以使用数组初始化vector对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> int_arr[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ivec</span><span class="params">(<span class="built_in">begin</span>(int_arr), <span class="built_in">end</span>(int_arr))</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>C++应当尽量使用vector和迭代器，而非内置数组和指针；应当尽量使用string，而非C风格字符串。</p>
</blockquote>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>多维数组实际上就是数组的数组。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ia1[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;,</span><br><span class="line">    &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> ia2[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> ia3[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123; <span class="number">0</span> &#125;, &#123; <span class="number">1</span> &#125;, &#123; <span class="number">2</span> &#125;&#125;; <span class="comment">// 初始化每行的第一个元素</span></span><br><span class="line"><span class="keyword">int</span> ia4[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>&#125;; <span class="comment">// 初始化第一行</span></span><br></pre></td></tr></table></figure>
<p>可以通过下标运算符访问多维数组的元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">size_t</span> rowCnt = <span class="number">3</span>, colCnt = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> ia[rowCnt][colCnt];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != rowCnt; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j != colCnt; ++j) &#123;</span><br><span class="line">        ia[i][j] = i * colCnt + j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以用范围for语句访问，实现同样的效果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">size_t</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;row : ia) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;col : row) &#123;</span><br><span class="line">        col = cnt;</span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为循环中要赋值，所以选用引用类型。其实除了内层循环，其他所有循环的控制变量都应该是引用类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> row : ia)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> col : row)</span><br></pre></td></tr></table></figure>
<p>上面这段语句将无法通过编译，因为row不是引用类型，所以row的类型是int*。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *ip[<span class="number">4</span>];   <span class="comment">// 整形指针的数组</span></span><br><span class="line"><span class="keyword">int</span> (*ip)[<span class="number">4</span>]; <span class="comment">// 指向含有4个整数的数组</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>《C++ Primer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>现代密码学（一）绪论</title>
    <url>/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%80%EF%BC%89%E7%BB%AA%E8%AE%BA/</url>
    <content><![CDATA[<p>介绍密码学的基本概念。</p>
<a id="more"></a>
<h2 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h2><p>密码学是一门研究秘密信息隐写技术的学科。</p>
<ul>
<li>可以使消息的内容对所有人（除了发送者和接收者）保密</li>
<li>可以使接收者验证消息的正确性</li>
</ul>
<p>常用的术语如下</p>
<ul>
<li>明文 plaintext</li>
<li>密文 ciphertext</li>
<li>密码算法 cipher</li>
<li>密钥 key</li>
<li>编码 encipher/encode</li>
<li>译码 decipher/decode</li>
<li>密码分析 cryptanalysis/codebreaking</li>
<li>密码学 cryptology</li>
</ul>
<h3 id="符号记法"><a href="#符号记法" class="headerlink" title="符号记法"></a>符号记法</h3><p>加密 Encryption</p>
<script type="math/tex; mode=display">
C = EK(P)</script><p>解密 Decryption</p>
<script type="math/tex; mode=display">
P = EK_{-1}(C)</script><p>可以把密码系统理解为明文空间到密文空间的变换，其中密钥取自密钥空间。</p>
<script type="math/tex; mode=display">
P\xrightarrow{EK}C \\
C\xrightarrow{EK_{-1}}P</script><h2 id="算法分类"><a href="#算法分类" class="headerlink" title="算法分类"></a>算法分类</h2><ul>
<li>私钥加密算法<ul>
<li>分组密码</li>
<li>流密码（序列密码）</li>
</ul>
</li>
<li>公钥加密算法</li>
<li>数字签名算法</li>
<li>哈希函数</li>
</ul>
<h2 id="密码分析"><a href="#密码分析" class="headerlink" title="密码分析"></a>密码分析</h2><p>密码分析学是指在没有加密密钥的情况下，攻击密文的过程。</p>
<ul>
<li>唯密文攻击<ul>
<li>只知道算法与一些密文</li>
<li>利用统计方法</li>
<li>需要能够识别明文</li>
</ul>
</li>
<li>已知明文攻击<ul>
<li>知道一些明文/密文对</li>
<li>利用已知的明文/密文对进行攻击</li>
</ul>
</li>
<li>选择明文攻击<ul>
<li>能够选择明文并得到相应的密文</li>
<li>利用算法的结构进行攻击</li>
</ul>
</li>
<li>选择密文攻击<ul>
<li>能够选择密文并得到相应的明文</li>
<li>利用对算法结构的知识进行攻击</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>现代密码学</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>现代密码学（七）数字签名算法</title>
    <url>/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%83%EF%BC%89%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>现代密码学（三）分组密码</title>
    <url>/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<p>介绍分组密码，包括Feistel Cipher、DES和IDEA等。</p>
<a id="more"></a>
<h2 id="分组密码"><a href="#分组密码" class="headerlink" title="分组密码"></a>分组密码</h2><p>分组密码（Block Cipher），是指将明文分成许多块，利用加密算法对每一块进行加密，形式如下。</p>
<p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201227181933426.png" alt="image-20201227181933426" style="zoom:67%;"></p>
<p>分组密码希望使用对每一块使用尽可能大的替换模块，但并不现实。</p>
<p>当分组长度为64bit时，即需要<script type="math/tex">2^{64}</script>个实体的替换表，因此使用乘积密码的思想，用一些小的模块替代。</p>
<h2 id="替换-置换密码"><a href="#替换-置换密码" class="headerlink" title="替换-置换密码"></a>替换-置换密码</h2><p>Shannon在那篇著名的文章中，介绍了替换-置换（S-P）网络的概念。</p>
<ul>
<li>替换 Substitution</li>
<li>置换 Permutation</li>
</ul>
<p>其实和古典密码的思想类似，替换运算用另一个二进制字代替原来的字。</p>
<p>替换函数就构成密钥，可以看成一个大的查表运算，替换函数也被称为S-box。</p>
<p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201227182545313.png" alt="image-20201227182545313" style="zoom:67%;"></p>
<p>置换运算则打乱一个二进制字的次序，重新排列的方法构成密钥，称为P-box。</p>
<p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201227182648209.png" alt="image-20201227182648209" style="zoom: 67%;"></p>
<p>S-P网络就是将这两种运算组合在一起，称为混合变换。</p>
<p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201227182900185.png" alt="image-20201227182900185" style="zoom:67%;"></p>
<h2 id="Feistel-Cipher"><a href="#Feistel-Cipher" class="headerlink" title="Feistel Cipher"></a>Feistel Cipher</h2><p>Feitel密码将输入块分为左右两部分L(i-1)和R(i-1)，在密码变换的第i轮只使用R(i-1)。</p>
<p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201227183335455.png" alt="image-20201227183335455" style="zoom:67%;"></p>
<p>变换过程可以表示为</p>
<script type="math/tex; mode=display">
\begin{align}
L(i) &= R(i-1) \\
R(i) &= L(i-1) \oplus g(K(i), R(i-1))
\end{align}</script><p>S盒提供输入bits混合作用（confusion）。</p>
<ul>
<li>使密钥和密文之间关系复杂化</li>
<li>极小化统计特性，使统计分析攻击不能奏效。</li>
</ul>
<p>P盒提供扩散作用（diffusion）</p>
<ul>
<li>将明文和密钥的影响尽可能散步到较多个输出的密文中（将明文冗余度分散到密文中）。</li>
</ul>
<h3 id="雪崩效应"><a href="#雪崩效应" class="headerlink" title="雪崩效应"></a>雪崩效应</h3><ul>
<li>输入改变1bit，导致近半的bit发生变化。</li>
<li>对于一个函数<script type="math/tex">f</script>来说，较好的雪崩特性是指<ul>
<li>对于<script type="math/tex">2^m</script>个明文向量，分为<script type="math/tex">2^{m-1}</script>个向量对<script type="math/tex">(x_i, x_i')</script>，每对向量只有一个bit不同。</li>
<li>定义<script type="math/tex">v_i = f(x) \oplus f(x_i)</script>，则近半的<script type="math/tex">v_i</script>为1。</li>
</ul>
</li>
</ul>
<h3 id="完备性效应"><a href="#完备性效应" class="headerlink" title="完备性效应"></a>完备性效应</h3><ul>
<li>每个输出比特是所有输入比特的复杂函数的输出。</li>
<li>对于一个函数<script type="math/tex">f</script>来说，较好的完备性是指<ul>
<li>对密文输出向量的每一个比特j，至少存在一个明文对<script type="math/tex">(x_i, x_i')</script>。</li>
<li>此明文对只在第i比特不同，且<script type="math/tex">f(x_i)</script>与<script type="math/tex">f(x_i')</script>的第j比特不同。</li>
</ul>
</li>
</ul>
<h3 id="Feistel-Cipher设计"><a href="#Feistel-Cipher设计" class="headerlink" title="Feistel Cipher设计"></a>Feistel Cipher设计</h3><p>雪崩特性保证了小的输入变化会导致大的输出变化，完备性保证了每个输出比特依赖于所有的输入比特。</p>
<p>设计密码时需要以下参数</p>
<ul>
<li>分组大小</li>
<li>密钥大小</li>
<li>轮数</li>
<li>子密钥生成</li>
<li>轮函数</li>
</ul>
<p>设计一个快速/安全的算法是困难的。</p>
<h2 id="Lucifer"><a href="#Lucifer" class="headerlink" title="Lucifer"></a>Lucifer</h2><p>第一个可用的替换-置换密码。</p>
<p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201227190818450.png" alt="image-20201227190818450" style="zoom:67%;"></p>
<p>分组长度128bit，密钥长度128bit，每一轮的子密钥是密钥的左半部分。</p>
<p>密钥每次向左旋转56bit，密钥的每部分都参与运算。</p>
<script type="math/tex; mode=display">
\begin{align}
L_i &= R_{i-1} \\
R_i &= L_{i-1} \oplus P(K_{i-1}\oplus S(K_{i-1})) \\
K_i &= ROL(K_{i-1})
\end{align}</script><p>Lucifer共有16轮数据计算，使用8对4bitS盒实现替换，用几个8-bit置换组成64bit的简单置换。</p>
<p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201227191928132.png" alt="image-20201227191928132" style="zoom:67%;"></p>
<h2 id="S-DES"><a href="#S-DES" class="headerlink" title="S-DES"></a>S-DES</h2><p>S-DES即Simplified DES，供教学使用，有着和DES相似的特性和结构，但参数小。</p>
<p>S-DES主要有以下几个函数</p>
<ul>
<li>初始置换IP（initial permutation）</li>
<li>复合函数<script type="math/tex">f_k</script><ul>
<li>由密钥K确定，具有转换和替换的运算。</li>
</ul>
</li>
<li>转换函数SW</li>
</ul>
<p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201227193325791.png" alt="image-20201227193325791" style="zoom:67%;"></p>
<p>加密算法可以表示为</p>
<script type="math/tex; mode=display">
cipher = IP_{-1}(f_{k2}(SW(f_{k1}(IP(plain)))))</script><p>其中</p>
<script type="math/tex; mode=display">
K_1 = P_8(移位(P_{10}(K))) \\
K_2 = P_8(移位(移位(P_{10}(K))）)</script><p>密钥生成可以用下图表示，LS代表循环左移</p>
<p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/image-20201227193303826.png" alt="image-20201227193303826" style="zoom:67%;"></p>
<p>初始置换</p>
<script type="math/tex; mode=display">
IP = \begin{pmatrix} 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 \\ 2 & 6 & 3 & 1 & 4 & 8 & 5 & 7 \end{pmatrix}</script><script type="math/tex; mode=display">
IP_{-1} = \begin{pmatrix} 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 \\ 4 & 1 & 3 & 5 & 7 & 2 & 8 & 6 \end{pmatrix}</script><h2 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h2><h2 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h2>]]></content>
      <categories>
        <category>现代密码学</category>
      </categories>
      <tags>
        <tag>分组密码</tag>
      </tags>
  </entry>
  <entry>
    <title>现代密码学（五）公钥密码</title>
    <url>/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%BA%94%EF%BC%89%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>现代密码学（二）古典密码</title>
    <url>/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<p>介绍古典代换密码和古典置换密码。</p>
<a id="more"></a>
<h2 id="古典密码"><a href="#古典密码" class="headerlink" title="古典密码"></a>古典密码</h2><p>古典密码只要有两种加密方式，替换和置换（substitution and transposition）。</p>
<p>替换是用新的字符代替原字符，置换是不改变原文字母集，打乱字符顺序。</p>
<h2 id="古典代换密码"><a href="#古典代换密码" class="headerlink" title="古典代换密码"></a>古典代换密码</h2><h3 id="Caesar-Cipher-恺撒密码"><a href="#Caesar-Cipher-恺撒密码" class="headerlink" title="Caesar Cipher-恺撒密码"></a>Caesar Cipher-恺撒密码</h3><p>恺撒密码的替换方法是，每个字母用其后的第三个字母替换。</p>
<script type="math/tex; mode=display">
\alpha\leftarrow\alpha+3</script><p>恺撒密码可以表示为</p>
<ul>
<li>Plain: ABCDEFGHIJKLMNOPQRSTUVWXYZ</li>
<li>Cipher: DEFGHIJKLMNOPQRSTUVWXYZABC</li>
</ul>
<p>如密文L FDPH L VDZ L FRQTXHUHG，对应的明文即为移位三位，I CAME I SAW CONQUERED。</p>
<p>当然，恺撒密码也可以将移位的长度改成1-25的任一个，换言之，共有25种可能的密码算法（移位0不可用）。</p>
<h3 id="混合单表替换密码"><a href="#混合单表替换密码" class="headerlink" title="混合单表替换密码"></a>混合单表替换密码</h3><p>单字母替换密码用一个字母代替另外一个字母，相当于构造了字母表到字母表的双射，密钥长度是26个字母。</p>
<h3 id="Vigenere-Cipher"><a href="#Vigenere-Cipher" class="headerlink" title="Vigenère Cipher"></a>Vigenère Cipher</h3><p>发明了多字母替换密码，一个字母可以被多个字母替换，通过密钥选择对每个字母使用哪个字母表。</p>
<p>密钥的第i个字母表示使用第i个字母表。</p>
<p>如下例，密钥为CIPHER，分别定义了六张字母表（六个双射）。</p>
<p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/image-20201227175332395.png" alt="image-20201227175332395"></p>
<p>对于明文，用密钥选择字母用哪个字母表，这里的效果相当于明文与密钥相加减一。</p>
<p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/image-20201227175322132.png" alt="image-20201227175322132"></p>
<h3 id="Ciphers-Machines"><a href="#Ciphers-Machines" class="headerlink" title="Ciphers Machines"></a>Ciphers Machines</h3><ul>
<li>Jefferson Cylinder</li>
<li>Wheatstone disc</li>
<li>the German Enigma</li>
<li>the Swedish Hagelin</li>
<li>the Janpanese Purple</li>
</ul>
<h2 id="古典置换密码"><a href="#古典置换密码" class="headerlink" title="古典置换密码"></a>古典置换密码</h2><p>置换密码的核心思想是，按一定规则写出明文，按另一规则读出密文。</p>
<p>密钥就是用于读密文和写明文的方法。</p>
<h3 id="Scytale密码"><a href="#Scytale密码" class="headerlink" title="Scytale密码"></a>Scytale密码</h3><p>消息沿着圆柱横写，密钥是纸条和圆柱的宽度。</p>
<p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/image-20201227180058573.png" alt="image-20201227180058573"></p>
<h3 id="Rail-Fence-Cipher-轨道栅栏密码"><a href="#Rail-Fence-Cipher-轨道栅栏密码" class="headerlink" title="Rail Fence Cipher-轨道栅栏密码"></a>Rail Fence Cipher-轨道栅栏密码</h3><p>在不同行写下消息字母，按行读取消息。</p>
<p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/image-20201227180208972.png" alt="image-20201227180208972"></p>
<h3 id="几何图形密码"><a href="#几何图形密码" class="headerlink" title="几何图形密码"></a>几何图形密码</h3><p>以一种形式写，用另一种形式读。</p>
<p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/image-20201227180223935.png" alt="image-20201227180223935"></p>
<h3 id="行变换密码"><a href="#行变换密码" class="headerlink" title="行变换密码"></a>行变换密码</h3><p>按行写出字母，以密钥给出的顺序按行读出密文。</p>
<p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/image-20201227180454135.png" alt="image-20201227180454135"></p>
<p>对上图的解释：</p>
<ul>
<li>给定明文，分组长度为5，按25413的顺序对字母重新编排，如THESI变成STIEH。</li>
<li>给定密文，分组长度为5，按41532的顺序读取信息，如STIEH变成THESI。</li>
</ul>
<p>其实相当于定义了置换</p>
<script type="math/tex; mode=display">
\sigma = \begin{pmatrix} 1 & 2 & 3 & 4 & 5 \\ 2 & 5 & 4 & 1 & 3 \end{pmatrix}</script><p>对应的逆置换即为</p>
<script type="math/tex; mode=display">
\sigma^{-1} = \begin{pmatrix} 2 & 5 & 4 & 1 & 3 \\ 1 & 2 & 3 & 4 & 5 \end{pmatrix} = \begin{pmatrix} 1 & 2 & 3 & 4 & 5 \\ 4 & 1 & 5 & 3 & 2 \end{pmatrix}</script><h4 id="密码分析"><a href="#密码分析" class="headerlink" title="密码分析"></a>密码分析</h4><p>我们希望猜测密钥周期，再对可能的行列变换进行猜测。</p>
<p><img src="/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/image-20201227181407687.png" alt="image-20201227181407687"></p>
]]></content>
      <categories>
        <category>现代密码学</category>
      </categories>
      <tags>
        <tag>古典密码</tag>
      </tags>
  </entry>
  <entry>
    <title>现代密码学（八）信息隐藏与隐写分析</title>
    <url>/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%85%AB%EF%BC%89%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F%E4%B8%8E%E9%9A%90%E5%86%99%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>现代密码学（六）认证与哈希函数</title>
    <url>/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%85%AD%EF%BC%89%E8%AE%A4%E8%AF%81%E4%B8%8E%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>现代密码学（四）序列密码</title>
    <url>/2020/12/27/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E5%9B%9B%EF%BC%89%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
